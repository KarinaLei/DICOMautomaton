.\"t
.\" Automatically generated by Pandoc 2.2.1
.\"
.TH "DICOMautomaton Reference Manual" "" "" "" ""
.hy
.SH Overview
.SS About
.PP
DICOMautomaton is a collection of software tools for processing and
analyzing medical images.
Once a workflow has been developed, the aim of DICOMautomaton is to
require minimal interaction to perform the workflow in an automated way.
However, some interactive tools are also included for workflow
development, exploratory analysis, and contouring.
.PP
DICOMautomaton is meant to be flexible enough to adapt to a wide variety
of situations and has been incorporated into projects to provide: a
local PACs, image analysis for various types of QA, kinetic modeling of
perfusion images, automated fuzzy mapping of ROI names to a standard
lexicon, dosimetric analysis, TCP and NTCP modeling, ROI contour/volume
manipulation, estimation of surface dose, ray casting through patient
and phantom geometry, rudimentary linac beam optimization, radiomics,
and has been used in various ways to explore the relationship between
toxicity and dose in sub\-organ compartments.
.PP
Note: DICOMautomaton should \f[B]NOT\f[] be used for clinical purposes.
It is experimental software.
It is suitable for research or support tool purposes only.
It comes with no warranty or guarantee of any kind, either explicit or
implied.
Users of DICOMautomaton do so fully at their own risk.
.SS Project Home
.PP
This project's homepage can be found at <http://www.halclark.ca/>.
The source code is available at either
<https://gitlab.com/hdeanclark/DICOMautomaton/> or
<https://github.com/hdclark/DICOMautomaton/>.
.SS Download
.PP
DICOMautomaton relies only on open source software and is itself open
source software.
Source code is available at <https://github.com/hdclark/DICOMautomaton>.
.PP
Currently, binaries are not provided.
Only linux is supported and a recent C++ compiler is needed.
A \f[C]PKGBUILD\f[] file is provided for Arch Linux and derivatives, and
CMake can be used to generate deb files for Debian derivatives.
A docker container is available for easy portability to other systems.
DICOMautomaton has successfully run on x86, x86_64, and most ARM
systems.
To maintain flexibility, DICOMautomaton is generally not ABI or API
stable.
.SS License and Copying
.PP
All materials herein which may be copywrited, where applicable, are.
Copyright 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019 hal
clark.
See the \f[C]LICENSE\f[] file for details about the license.
Informally, DICOMautomaton is available under a GPLv3+ license.
The Imebra library is bundled for convenience and was not written by hal
clark; consult its license file in \f[C]src/imebra/license.txt\f[].
.PP
All liability is herefore disclaimed.
The person(s) who use this source and/or software do so strictly under
their own volition.
They assume all associated liability for use and misuse, including but
not limited to damages, harm, injury, and death which may result,
including but not limited to that arising from unforeseen and
unanticipated implementation defects.
.SS Dependencies
.PP
Dependencies are listed in the \f[C]PKGBUILD\f[] file (using Arch Linux
package naming conventions) and in the \f[C]CMakeLists.txt\f[] file
(Debian package naming conventions) bundled with the source code.
See <https://github.com/hdclark/DICOMautomaton>.
Broadly, DICOMautomaton depends on Boost, CGAL, SFML, Eigen, Asio, Wt,
NLopt, and PostgreSQL.
Disabling some functionality at compile time can eliminate some
dependencies.
This instance has been compiled with the following functionality.
.PP
Dependencies enabled for this instance.
.TS
tab(@);
l l.
T{
Dependency
T}@T{
Functionality Enabled?
T}
_
T{
Ygor
T}@T{
true (required)
T}
T{
YgorClustering
T}@T{
true (required; header\-only)
T}
T{
Explicator
T}@T{
true (required)
T}
T{
Imebra
T}@T{
true (required; bundled)
T}
T{
Boost
T}@T{
true (required)
T}
T{
asio
T}@T{
true (required)
T}
T{
zlib
T}@T{
true (required)
T}
T{
MPFR
T}@T{
true (required)
T}
T{
GNU GMP
T}@T{
true (required)
T}
T{
Eigen
T}@T{
true
T}
T{
CGAL
T}@T{
true
T}
T{
NLOpt
T}@T{
true
T}
T{
SFML
T}@T{
true
T}
T{
Wt
T}@T{
true
T}
T{
GNU GSL
T}@T{
true
T}
T{
pqxx
T}@T{
true
T}
T{
Jansson
T}@T{
true
T}
.TE
.PP
Notably, DICOMautomaton depends on the author's `Ygor,' `Explicator,'
and `YgorClustering' projects.
See <https://gitlab.com/hdeanclark/Ygor> (mirrored at
<https://github.com/hdclark/Ygor>),
<https://gitlab.com/hdeanclark/Explicator> (mirrored at
<https://github.com/hdclark/Explicator>), and (only for compilation)
<https://gitlab.com/hdeanclark/YgorClustering> (mirrored at
<https://github.com/hdclark/YgorClustering>).
.SS Feedback
.PP
All feedback, questions, comments, and pull requests are welcomed.
.SS FAQs
.PP
\f[B]Q.\f[] What is the best way to use DICOMautomaton?
.PD 0
.P
.PD
\f[B]A.\f[] DICOMautomaton provides a command\-line interface,
SFML\-based image viewer, and limited web interface.
The command\-line interface is most conducive to automation, the viewer
works best for interactive tasks, and the web interface works well for
specific installations.
.PP
\f[B]Q.\f[] How do I contribute, report bugs, or contact the author?
.PD 0
.P
.PD
\f[B]A.\f[] All feedback, questions, comments, and pull requests are
welcomed.
Please find contact information at
<https://github.com/hdclark/DICOMautomaton>.
.SS Citing
.PP
Several publications and presentations refer to DICOMautomaton or
describe some aspect of it.
Here are a few:
.IP \[bu] 2
H.
Clark, J.
Beaudry, J.
Wu, and S.
Thomas.
Making use of virtual dimensions for visualization and contouring.
Poster presentation at the International Conference on the use of
Computers in Radiation Therapy, London, UK.
June 27\-30,
.RS 2
.RE
.IP \[bu] 2
H.
Clark, S.
Thomas, V.
Moiseenko, R.
Lee, B.
Gill, C.
Duzenli, and J.
Wu.
Automated segmentation and dose\-volume analysis with DICOMautomaton.
In the Journal of Physics: Conference Series, vol.\ 489, no.
1, p.\ 012009.
IOP Publishing, 2014.
.IP \[bu] 2
H.
Clark, J.
Wu, V.
Moiseenko, R.
Lee, B.
Gill, C.
Duzenli, and S.
Thomas.
Semi\-automated contour recognition using DICOMautomaton.
In the Journal of Physics: Conference Series, vol.\ 489, no.
1, p.\ 012088.
IOP Publishing, 2014.
.IP \[bu] 2
H.
Clark, J.
Wu, V.
Moiseenko, and S.
Thomas.
Distributed, asynchronous, reactive dosimetric and outcomes analysis
using DICOMautomaton.
Poster presentation at the COMP Annual Scientific Meeting, Banff,
Canada.
July 9\[en]12, 2014.
.PP
If you use DICOMautomaton in an academic work, we ask that you please
cite the most relevant publication for that work, if possible.
.SS Components
.SS dicomautomaton_dispatcher
.SS Description
.PP
The core command\-line interface to DICOMautomaton is the
\f[C]dicomautomaton_dispatcher\f[] program.
It is presents an interface based on chaining of discrete operations on
collections of images, DICOM images, DICOM radiotherapy files (RTSTRUCTS
and RTDOSE), and various other types of files.
\f[C]dicomautomaton_dispatcher\f[] has access to all defined operations
described in Operations.
It can be used to launch both interactive and non\-interactive tasks.
Data can be sourced from a database or files in a variety of formats.
.PP
Name/label selectors in dicomautomaton_dispatcher generally support
fuzzy matching via
libexplicator (https://gitlab.com/hdeanclark/Explicator) or regular
expressions.
The operations and parameters that provide these options are documented
in Operations.
.PP
Filetype support differs in some cases.
A custom FITS file reader and writer are supported, and DICOM files are
generally supported.
There is currently no support for RTPLANs, though DICOM image, RTSTRUCT,
and RTDOSE files are well supported.
There is limited support for writing files \[en] currently JPEG, PNG,
and FITS images; RTDOSE files; and Boost.Serialize archive writing are
supported.
.SS Usage Examples
.IP \[bu] 2
\f[C]dicomautomaton_dispatcher\ \-\-help\f[]
.PD 0
.P
.PD
\f[I]Print a listing of all available options.\f[]
.IP \[bu] 2
\f[C]dicomautomaton_dispatcher\ CT*dcm\f[]
.PD 0
.P
.PD
\f[I]Launch the default interactive viewer to inspect a collection of
computed tomography images.\f[]
.IP \[bu] 2
\f[C]dicomautomaton_dispatcher\ MR*dcm\f[]
.PD 0
.P
.PD
\f[I]Launch the default interactive viewer to inspect a collection of
magnetic resonance images.\f[]
.IP \[bu] 2
\f[C]dicomautomaton_dispatcher\ \-o\ SFML_Viewer\ MR*dcm\f[]
.PD 0
.P
.PD
\f[I]Launch the default interactive viewer to inspect a collection of
magnetic resonance images. Note that files specified on the command line
are always loaded \f[BI]prior\f[I] to running any operations. Injecting
files midway through the operation chain must make use of an operation
designed to do so.\f[]
.IP \[bu] 2
\f[C]dicomautomaton_dispatcher\ CT*dcm\ RTSTRUCT*dcm\ RTDOSE*dcm\ \-o\ Average\ \-o\ SFML_Viewer\f[]
.PD 0
.P
.PD
\f[I]Load DICOM files, perform an averaging operation, and then launch
the SFML viewer to inspect the output.\f[]
.IP \[bu] 2
\f[C]dicomautomaton_dispatcher\ ./RTIMAGE.dcm\ \-o\ AnalyzePicketFence:ImageSelection=\[aq]last\[aq]:InteractivePlots=\[aq]false\[aq]\f[]
.PD 0
.P
.PD
\f[I]Perform a picket fence analysis of an RTIMAGE file.\f[]
.IP \[bu] 2
\f[C]dicomautomaton_dispatcher\ \-f\ create_temp_view.sql\ \-f\ select_records_from_temp_view.sql\ \-o\ ComputeSomething\f[]
.PD 0
.P
.PD
\f[I]Load a SQL common file that creates a SQL view, issue a query
involving the view which returns some DICOM file(s). Perform analysis
`ComputeSomething' with the files.\f[]
.IP \[bu] 2
\f[C]dicomautomaton_dispatcher\ \-f\ common.sql\ \-f\ seriesA.sql\ \-n\ \-f\ seriesB.sql\ \-o\ SFML_Viewer\f[]
.PD 0
.P
.PD
\f[I]Load two distinct groups of data. The second group does not `see'
the file `common.sql' side effects \[en] the queries are totally
separate.\f[]
.IP \[bu] 2
\f[C]dicomautomaton_dispatcher\ fileA\ fileB\ \-s\ fileC\ adir/\ \-m\ PatientID=XYZ003\ \-o\ ComputeXYZ\ \-o\ SFML_Viewer\f[]
.PD 0
.P
.PD
\f[I]Load standalone files and all files in specified directory. Inform
the analysis `ComputeXYZ' of the patient's ID, launch the analysis, and
then interactively view.\f[]
.IP \[bu] 2
\f[C]dicomautomaton_dispatcher\ CT*dcm\ \-o\ ModifyingOperation\ \-o\ BoostSerializeDrover\f[]
.PD 0
.P
.PD
\f[I]Launch the default interactive viewer to inspect a collection of
computed tomography images, perform an operation that modifies them, and
serialize the internal state for later using the BoostSerializeDrover
operation.\f[]
.SS dicomautomaton_webserver
.SS Description
.PP
This web server presents most operations in an interactive web page.
Some operations are disabled by default (e.g., BuildLexiconInteractively
because they are not designed to be operated via remote procedure calls.
This routine should be run within a capability\-limiting environment,
but access to an X server is required.
A Docker script is bundled with DICOMautomaton sources which includes
everything needed to function properly.
.SS Usage Examples
.IP \[bu] 2
\f[C]dicomautomaton_webserver\ \-\-help\f[]
.PD 0
.P
.PD
\f[I]Print a listing of all available options. Note that most
configuration is done via editing configuration files. See
\f[CI]/etc/DICOMautomaton/\f[I].\f[]
.IP \[bu] 2
\f[C]dicomautomaton_webserver\ \-\-config\ /etc/DICOMautomaton/webserver.conf\ \-\-http\-address\ 0.0.0.0\ \-\-http\-port\ 8080\ \-\-docroot=\[aq]/etc/DICOMautomaton/\[aq]\f[]
.PD 0
.P
.PD
\f[I]Launch the webserver on any interface and port 8080.\f[]
.SS dicomautomaton_bsarchive_convert
.SS Description
.PP
A program for converting Boost.Serialization archives types which
DICOMautomaton can read.
These archives need to be created by the BoostSerializeDrover operation.
Some archive types are concise and not portable (i.e., binary archives),
or verbose (and thus slow to read and write) and portable (i.e., XML,
plain text).
To combat verbosity, on\-the\-fly gzip compression and decompression is
supported.
This program can be used to convert archive types.
.SS Usage Examples
.IP \[bu] 2
\f[C]dicomautomaton_bsarchive_convert\ \-\-help\f[]
.PD 0
.P
.PD
\f[I]Print a listing of all available options.\f[]
.IP \[bu] 2
\f[C]dicomautomaton_bsarchive_convert\ \-i\ file.binary\ \-o\ file.xml\ \-t\ \[aq]XML\[aq]\f[]
.PD 0
.P
.PD
\f[I]Convert a binary archive to a portable XML archive.\f[]
.IP \[bu] 2
\f[C]dicomautomaton_bsarchive_convert\ \-i\ file.binary.gz\ \-o\ file.xml.gz\ \-t\ \[aq]gzip\-xml\[aq]\f[]
.PD 0
.P
.PD
\f[I]Convert a binary archive to a gzipped portable XML archive.\f[]
.IP \[bu] 2
\f[C]dicomautomaton_bsarchive_convert\ \-i\ file.binary.gz\ \-o\ file.xml\ \-t\ \[aq]XML\[aq]\f[]
.PD 0
.P
.PD
\f[I]Convert a gzipped binary archive to a non\-gzipped portable XML
archive.\f[]
.IP \[bu] 2
\f[C]dicomautomaton_bsarchive_convert\ \-i\ file.xml.gz\ \-o\ file.txt\ \-t\ \[aq]txt\[aq]\f[]
.PD 0
.P
.PD
\f[I]Convert a gzipped binary archive to a non\-gzipped, portable, and
inspectable text archive.\f[]
.IP \[bu] 2
\f[C]dicomautomaton_bsarchive_convert\ \-i\ file.txt\ \-o\ file.txt.gz\ \-t\ \[aq]gzip\-txt\[aq]\f[]
.PD 0
.P
.PD
\f[I]Convert an uncompressed text archive to a compressed text archive.
Note that this conversion is effectively the same as simply
\f[CI]gzip\ file.txt\f[I].\f[]
.IP \[bu] 2
\f[C]dicomautomaton_bsarchive_convert\ \-i\ file.xml.gz\ \-o\ file.bin\ \-t\ \[aq]binary\[aq]\f[]
.PD 0
.P
.PD
\f[I]Convert a compressed archive to a binary file.\f[] Note that binary
archives should only expect to be readable on the same hardware with the
same versions and are therefore best for checkpointing calculations that
can fail or may need to be tweaked later.*
.IP \[bu] 2
\f[C]dicomautomaton_bsarchive_convert\ \-i\ file.xml.gz\ \-o\ file.bin.gz\ \-t\ \[aq]gzip\-binary\[aq]\f[]
.PD 0
.P
.PD
\f[I]Convert a compressed archive to a compressed binary file.\f[]
.SS dicomautomaton_dump
.SS Description
.PP
This program is extremely simplistic.
Given a single DICOM file, it prints to stdout the value of one DICOM
tag.
This program is best used in scripts, for example to check the modality
or a file.
.SS Usage Examples
.IP \[bu] 2
\f[C]dicomautomaton_dump\ afile.dcm\ 0x0008\ 0x0060\f[]
.PD 0
.P
.PD
\f[I]Print the value of the DICOM tag (0x0008,0x0060) aka
(0008,0060).\f[]
.SS pacs_ingress
.SS Description
.PP
Given a DICOM file and some additional metadata, insert the data into a
PACs system database.
The file itself will be copied into the database and various bits of
data will be deciphered.
Note that at the moment a `gdcmdump' file must be provided and is stored
alongside the DICOM file in the database filestore.
This sidecar file is meant to support ad\-hoc DICOM queries without
having to index the entire file.
Also note that imports into the database are minimal, leaving files with
multiple NULL values.
This is done to improve ingress times.
A separate database refresh (pacs_refresh) must be performed to replace
NULL values.
.SS Usage Examples
.IP \[bu] 2
\f[C]pacs_ingress\ \-\-help\f[]
.PD 0
.P
.PD
\f[I]Print a listing of all available options.\f[]
.IP \[bu] 2
\f[C]pacs_ingress\ \-f\ \[aq]/tmp/a.dcm\[aq]\ \-g\ \[aq]/tmp/a.gdcmdump\[aq]\ \-p\ \[aq]XYZ\ Study\ 2019\[aq]\ \-c\ \[aq]Study\ concerning\ XYZ.\[aq]\f[]
.PD 0
.P
.PD
\f[I]Insert the file `/tmp/a.dcm' into the database.\f[]
.SS pacs_refresh
.SS Description
.PP
A program for trying to replace database NULLs, if possible, using
stored files.
This program is complementary to pacs_ingress.
Note that the \f[C]\-\-days\-back/\-d\f[] parameter should always be
specified.
.SS Usage Examples
.IP \[bu] 2
\f[C]pacs_refresh\ \-\-help\f[]
.PD 0
.P
.PD
\f[I]Print a listing of all available options.\f[]
.IP \[bu] 2
\f[C]pacs_refresh\ \-d\ 7\f[]
.PD 0
.P
.PD
\f[I]Perform a refresh of the database, restricting to files imported
within the previous 7 days.\f[]
.SS pacs_duplicate_cleaner
.SS Description
.PP
Given a DICOM file, check if it is in the PACS DB.
If so, delete the file.
Note that a full, byte\-by\-byte comparison is NOT performed \[en]
rather only the top\-level DICOM unique identifiers are (currently)
compared.
No other metadata is considered.
So this program is not suitable if DICOM files have been modified
without re\-assigning unique identifiers! (Which is non\-standard
behaviour.) Note that if an \f[I]exact\f[] comparison is desired, using
a traditional file de\-duplicator will work.
.SS Usage Examples
.IP \[bu] 2
\f[C]pacs_duplicate_cleaner\ \-\-help\f[]
.PD 0
.P
.PD
\f[I]Print a listing of all available options.\f[]
.IP \[bu] 2
\f[C]pacs_duplicate_cleaner\ \-f\ \[aq]/path/to/a/dicom/file.dcm\[aq]\f[]
.PD 0
.P
.PD
\f[I]Check if `file.dcm' is already in the PACS DB. If so, delete it
(`file.dcm').\f[]
.IP \[bu] 2
\f[C]pacs_duplicate_cleaner\ \-f\ \[aq]/path/to/a/dicom/file.dcm\[aq]\ \-n\f[]
.PD 0
.P
.PD
\f[I]Check if `file.dcm' is already in the PACS DB, but do not delete
anything.\f[]
.SH List of Available Operations
.IP \[bu] 2
AccumulateRowsColumns
.IP \[bu] 2
AnalyzeHistograms
.IP \[bu] 2
AnalyzeLightRadFieldCoincidence
.IP \[bu] 2
AnalyzePicketFence
.IP \[bu] 2
AnalyzeTPlan
.IP \[bu] 2
ApplyCalibrationCurve
.IP \[bu] 2
AutoCropImages
.IP \[bu] 2
Average
.IP \[bu] 2
BCCAExtractRadiomicFeatures
.IP \[bu] 2
BoostSerializeDrover
.IP \[bu] 2
BuildLexiconInteractively
.IP \[bu] 2
CT_Liver_Perfusion
.IP \[bu] 2
CT_Liver_Perfusion_First_Run
.IP \[bu] 2
CT_Liver_Perfusion_Ortho_Views
.IP \[bu] 2
CT_Liver_Perfusion_Pharmaco_1C2I_5Param
.IP \[bu] 2
CT_Liver_Perfusion_Pharmaco_1C2I_Reduced3Param
.IP \[bu] 2
ClusterDBSCAN
.IP \[bu] 2
ComparePixels
.IP \[bu] 2
ContourBasedRayCastDoseAccumulate
.IP \[bu] 2
ContourBooleanOperations
.IP \[bu] 2
ContourSimilarity
.IP \[bu] 2
ContourViaGeometry
.IP \[bu] 2
ContourViaThreshold
.IP \[bu] 2
ContourVote
.IP \[bu] 2
ContourWholeImages
.IP \[bu] 2
ContouringAides
.IP \[bu] 2
ConvertContoursToMeshes
.IP \[bu] 2
ConvertContoursToPoints
.IP \[bu] 2
ConvertDoseToImage
.IP \[bu] 2
ConvertImageToDose
.IP \[bu] 2
ConvertImageToMeshes
.IP \[bu] 2
ConvertMeshesToContours
.IP \[bu] 2
ConvertNaNsToAir
.IP \[bu] 2
ConvertNaNsToZeros
.IP \[bu] 2
ConvertPixelsToPoints
.IP \[bu] 2
ConvolveImages
.IP \[bu] 2
CopyImages
.IP \[bu] 2
CopyMeshes
.IP \[bu] 2
CopyPoints
.IP \[bu] 2
CountVoxels
.IP \[bu] 2
CropImageDoseToROIs
.IP \[bu] 2
CropImages
.IP \[bu] 2
CropROIDose
.IP \[bu] 2
DCEMRI_IAUC
.IP \[bu] 2
DCEMRI_Nonparametric_CE
.IP \[bu] 2
DICOMExportContours
.IP \[bu] 2
DICOMExportImagesAsCT
.IP \[bu] 2
DICOMExportImagesAsDose
.IP \[bu] 2
DeDuplicateImages
.IP \[bu] 2
DecayDoseOverTimeHalve
.IP \[bu] 2
DecayDoseOverTimeJones2014
.IP \[bu] 2
DecimatePixels
.IP \[bu] 2
DeleteImages
.IP \[bu] 2
DeleteMeshes
.IP \[bu] 2
DeletePoints
.IP \[bu] 2
DetectGrid3D
.IP \[bu] 2
DetectShapes3D
.IP \[bu] 2
DrawGeometry
.IP \[bu] 2
DroverDebug
.IP \[bu] 2
DumpAllOrderedImageMetadataToFile
.IP \[bu] 2
DumpAnEncompassedPoint
.IP \[bu] 2
DumpFilesPartitionedByTime
.IP \[bu] 2
DumpImageMeshes
.IP \[bu] 2
DumpImageMetadataOccurrencesToFile
.IP \[bu] 2
DumpPerROIParams_KineticModel_1C2I_5P
.IP \[bu] 2
DumpPixelValuesOverTimeForAnEncompassedPoint
.IP \[bu] 2
DumpPlanSummary
.IP \[bu] 2
DumpROIContours
.IP \[bu] 2
DumpROIData
.IP \[bu] 2
DumpROISNR
.IP \[bu] 2
DumpROISurfaceMeshes
.IP \[bu] 2
DumpTPlanMetadataOccurrencesToFile
.IP \[bu] 2
DumpVoxelDoseInfo
.IP \[bu] 2
EQDConvert
.IP \[bu] 2
EvaluateDoseVolumeStats
.IP \[bu] 2
EvaluateNTCPModels
.IP \[bu] 2
EvaluateTCPModels
.IP \[bu] 2
ExportFITSImages
.IP \[bu] 2
ExportLineSamples
.IP \[bu] 2
ExportPointClouds
.IP \[bu] 2
ExportSurfaceMeshes
.IP \[bu] 2
ExportWarps
.IP \[bu] 2
ExtractAlphaBeta
.IP \[bu] 2
ExtractImageHistograms
.IP \[bu] 2
ExtractPointsWarp
.IP \[bu] 2
ExtractRadiomicFeatures
.IP \[bu] 2
FVPicketFence
.IP \[bu] 2
GenerateCalibrationCurve
.IP \[bu] 2
GenerateSurfaceMask
.IP \[bu] 2
GenerateSyntheticImages
.IP \[bu] 2
GenerateVirtualDataContourViaThresholdTestV1
.IP \[bu] 2
GenerateVirtualDataDoseStairsV1
.IP \[bu] 2
GenerateVirtualDataImageSphereV1
.IP \[bu] 2
GenerateVirtualDataPerfusionV1
.IP \[bu] 2
GiveWholeImageArrayABoneWindowLevel
.IP \[bu] 2
GiveWholeImageArrayAHeadAndNeckWindowLevel
.IP \[bu] 2
GiveWholeImageArrayAThoraxWindowLevel
.IP \[bu] 2
GiveWholeImageArrayAnAbdominalWindowLevel
.IP \[bu] 2
GiveWholeImageArrayAnAlphaBetaWindowLevel
.IP \[bu] 2
GridBasedRayCastDoseAccumulate
.IP \[bu] 2
GroupImages
.IP \[bu] 2
GrowContours
.IP \[bu] 2
HighlightROIs
.IP \[bu] 2
ImageRoutineTests
.IP \[bu] 2
ImprintImages
.IP \[bu] 2
InterpolateSlices
.IP \[bu] 2
IsolatedVoxelFilter
.IP \[bu] 2
LoadFiles
.IP \[bu] 2
LogScale
.IP \[bu] 2
MakeMeshesManifold
.IP \[bu] 2
MaxMinPixels
.IP \[bu] 2
MeldDose
.IP \[bu] 2
MinkowskiSum3D
.IP \[bu] 2
ModifyContourMetadata
.IP \[bu] 2
ModifyImageMetadata
.IP \[bu] 2
NegatePixels
.IP \[bu] 2
NormalizeLineSamples
.IP \[bu] 2
NormalizePixels
.IP \[bu] 2
OptimizeStaticBeams
.IP \[bu] 2
OrderImages
.IP \[bu] 2
PartitionContours
.IP \[bu] 2
PlotLineSamples
.IP \[bu] 2
PlotPerROITimeCourses
.IP \[bu] 2
PointSeparation
.IP \[bu] 2
PreFilterEnormousCTValues
.IP \[bu] 2
PresentationImage
.IP \[bu] 2
PruneEmptyImageDoseArrays
.IP \[bu] 2
PurgeContours
.IP \[bu] 2
RankPixels
.IP \[bu] 2
ReduceNeighbourhood
.IP \[bu] 2
RemeshSurfaceMeshes
.IP \[bu] 2
SFML_Viewer
.IP \[bu] 2
ScalePixels
.IP \[bu] 2
SeamContours
.IP \[bu] 2
SelectSlicesIntersectingROI
.IP \[bu] 2
SimplifyContours
.IP \[bu] 2
SimplifySurfaceMeshes
.IP \[bu] 2
SimulateRadiograph
.IP \[bu] 2
SpatialBlur
.IP \[bu] 2
SpatialDerivative
.IP \[bu] 2
SpatialSharpen
.IP \[bu] 2
SubdivideSurfaceMeshes
.IP \[bu] 2
SubsegmentContours
.IP \[bu] 2
Subsegment_ComputeDose_VanLuijk
.IP \[bu] 2
SubtractImages
.IP \[bu] 2
SupersampleImageGrid
.IP \[bu] 2
SurfaceBasedRayCastDoseAccumulate
.IP \[bu] 2
ThresholdImages
.IP \[bu] 2
ThresholdOtsu
.IP \[bu] 2
TransformContours
.IP \[bu] 2
TransformMeshes
.IP \[bu] 2
TrimROIDose
.IP \[bu] 2
UBC3TMRI_DCE
.IP \[bu] 2
UBC3TMRI_DCE_Differences
.IP \[bu] 2
UBC3TMRI_DCE_Experimental
.IP \[bu] 2
UBC3TMRI_IVIM_ADC
.IP \[bu] 2
VolumetricCorrelationDetector
.IP \[bu] 2
VolumetricSpatialBlur
.IP \[bu] 2
VolumetricSpatialDerivative
.IP \[bu] 2
VoxelRANSAC
.IP \[bu] 2
WarpPoints
.SH Operations Reference
.SS AccumulateRowsColumns
.SS Description
.PP
This operation generates row\- and column\-profiles of images in which
the entire row or column has been summed together.
It is useful primarily for detection of axes\-aligned edges or ridges.
.SS Notes
.IP \[bu] 2
It is often useful to pre\-process inputs by computing an
in\-image\-plane derivative, gradient magnitude, or similar (i.e.,
something to emphasize edges) before calling this routine.
It is not necessary, however.
.SS Parameters
.IP \[bu] 2
ImageSelection
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS AnalyzeHistograms
.SS Description
.PP
This operation analyzes the selected line samples as if they were
cumulative dose\-volume histograms (DVHs).
Multiple criteria can be specified.
The output is a CSV file that can be concatenated or appended to other
output files to provide a summary of multiple criteria.
.SS Notes
.IP \[bu] 2
This routine will filter out non\-matching line samples.
Currently required: Modality=Histogram; each must be explicitly marked
as a cumulative, unscaled abscissa + unscaled ordinate histogram; and
differential distribution statistics must be available (e.g., min, mean,
and max voxel doses).
.SS Parameters
.IP \[bu] 2
LineSelection
.IP \[bu] 2
SummaryFilename
.IP \[bu] 2
UserComment
.IP \[bu] 2
Description
.IP \[bu] 2
Constraints
.IP \[bu] 2
ReferenceDose
.SS LineSelection
.SS Description
.PP
Select one or more line samples.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth line
sample (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last line sample.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS SummaryFilename
.SS Description
.PP
A summary of the criteria and results will be appended to this file.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
If an existing file is present, rows will be appended without writing a
header.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
Even if left empty, the column will remain in the output to ensure the
outputs from multiple runs can be safely concatenated.
Preceding alphanumeric variables with a `$' will cause them to be
treated as metadata keys and replaced with the corresponding key's
value, if present.
For example, `The modality is
\f[I]M\f[]\f[I]o\f[]\f[I]d\f[]\f[I]a\f[]\f[I]l\f[]\f[I]i\f[]\f[I]t\f[]\f[I]y\f[]′\f[I]m\f[]\f[I]i\f[]\f[I]g\f[]\f[I]h\f[]\f[I]t\f[]\f[I]b\f[]\f[I]e\f[](\f[I]d\f[]\f[I]e\f[]\f[I]p\f[]\f[I]e\f[]\f[I]n\f[]\f[I]d\f[]\f[I]i\f[]\f[I]n\f[]\f[I]g\f[]\f[I]o\f[]\f[I]n\f[]\f[I]t\f[]\f[I]h\f[]\f[I]e\f[]\f[I]m\f[]\f[I]e\f[]\f[I]t\f[]\f[I]a\f[]\f[I]d\f[]\f[I]a\f[]\f[I]t\f[]\f[I]a\f[])\f[I]e\f[]\f[I]x\f[]\f[I]p\f[]\f[I]a\f[]\f[I]n\f[]\f[I]d\f[]\f[I]e\f[]\f[I]d\f[]\f[I]t\f[]\f[I]o\f[]′\f[I]T\f[]\f[I]h\f[]\f[I]e\f[]\f[I]m\f[]\f[I]o\f[]\f[I]d\f[]\f[I]a\f[]\f[I]l\f[]\f[I]i\f[]\f[I]t\f[]\f[I]y\f[]\f[I]i\f[]\f[I]s\f[]\f[I]H\f[]\f[I]i\f[]\f[I]s\f[]\f[I]t\f[]\f[I]o\f[]\f[I]g\f[]\f[I]r\f[]\f[I]a\f[]\f[I]m\f[]′.\f[I]I\f[]\f[I]f\f[]\f[I]t\f[]\f[I]h\f[]\f[I]e\f[]\f[I]m\f[]\f[I]e\f[]\f[I]t\f[]\f[I]a\f[]\f[I]d\f[]\f[I]a\f[]\f[I]t\f[]\f[I]a\f[]\f[I]k\f[]\f[I]e\f[]\f[I]y\f[]\f[I]i\f[]\f[I]s\f[]\f[I]n\f[]\f[I]o\f[]\f[I]t\f[]\f[I]p\f[]\f[I]r\f[]\f[I]e\f[]\f[I]s\f[]\f[I]e\f[]\f[I]n\f[]\f[I]t\f[], \f[I]t\f[]\f[I]h\f[]\f[I]e\f[]\f[I]e\f[]\f[I]x\f[]\f[I]p\f[]\f[I]r\f[]\f[I]e\f[]\f[I]s\f[]\f[I]s\f[]\f[I]i\f[]\f[I]o\f[]\f[I]n\f[]\f[I]w\f[]\f[I]i\f[]\f[I]l\f[]\f[I]l\f[]\f[I]r\f[]\f[I]e\f[]\f[I]m\f[]\f[I]a\f[]\f[I]i\f[]\f[I]n\f[]\f[I]u\f[]\f[I]n\f[]\f[I]e\f[]\f[I]x\f[]\f[I]p\f[]\f[I]a\f[]\f[I]n\f[]\f[I]d\f[]\f[I]e\f[]\f[I]d\f[](\f[I]i\f[].\f[I]e\f[]., \f[I]w\f[]\f[I]i\f[]\f[I]t\f[]\f[I]h\f[]\f[I]a\f[]\f[I]p\f[]\f[I]r\f[]\f[I]e\f[]\f[I]c\f[]\f[I]e\f[]\f[I]e\f[]\f[I]d\f[]\f[I]i\f[]\f[I]n\f[]\f[I]g\f[]′').
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.IP \[bu] 2
\f[C]"$PatientID"\f[]
.SS Description
.SS Description
.PP
A string that will be inserted into the output file which should be used
to describe the constraint and any caveats that the viewer should be
aware of.
Generally, the UserComment is best for broadly\-defined notes whereas
the Description is tailored for each constraint.
Preceding alphanumeric variables with a `$' will cause them to be
treated as metadata keys and replaced with the corresponding key's
value, if present.
For example, `The modality is
\f[I]M\f[]\f[I]o\f[]\f[I]d\f[]\f[I]a\f[]\f[I]l\f[]\f[I]i\f[]\f[I]t\f[]\f[I]y\f[]′\f[I]m\f[]\f[I]i\f[]\f[I]g\f[]\f[I]h\f[]\f[I]t\f[]\f[I]b\f[]\f[I]e\f[](\f[I]d\f[]\f[I]e\f[]\f[I]p\f[]\f[I]e\f[]\f[I]n\f[]\f[I]d\f[]\f[I]i\f[]\f[I]n\f[]\f[I]g\f[]\f[I]o\f[]\f[I]n\f[]\f[I]t\f[]\f[I]h\f[]\f[I]e\f[]\f[I]m\f[]\f[I]e\f[]\f[I]t\f[]\f[I]a\f[]\f[I]d\f[]\f[I]a\f[]\f[I]t\f[]\f[I]a\f[])\f[I]e\f[]\f[I]x\f[]\f[I]p\f[]\f[I]a\f[]\f[I]n\f[]\f[I]d\f[]\f[I]e\f[]\f[I]d\f[]\f[I]t\f[]\f[I]o\f[]′\f[I]T\f[]\f[I]h\f[]\f[I]e\f[]\f[I]m\f[]\f[I]o\f[]\f[I]d\f[]\f[I]a\f[]\f[I]l\f[]\f[I]i\f[]\f[I]t\f[]\f[I]y\f[]\f[I]i\f[]\f[I]s\f[]\f[I]H\f[]\f[I]i\f[]\f[I]s\f[]\f[I]t\f[]\f[I]o\f[]\f[I]g\f[]\f[I]r\f[]\f[I]a\f[]\f[I]m\f[]′.\f[I]I\f[]\f[I]f\f[]\f[I]t\f[]\f[I]h\f[]\f[I]e\f[]\f[I]m\f[]\f[I]e\f[]\f[I]t\f[]\f[I]a\f[]\f[I]d\f[]\f[I]a\f[]\f[I]t\f[]\f[I]a\f[]\f[I]k\f[]\f[I]e\f[]\f[I]y\f[]\f[I]i\f[]\f[I]s\f[]\f[I]n\f[]\f[I]o\f[]\f[I]t\f[]\f[I]p\f[]\f[I]r\f[]\f[I]e\f[]\f[I]s\f[]\f[I]e\f[]\f[I]n\f[]\f[I]t\f[], \f[I]t\f[]\f[I]h\f[]\f[I]e\f[]\f[I]e\f[]\f[I]x\f[]\f[I]p\f[]\f[I]r\f[]\f[I]e\f[]\f[I]s\f[]\f[I]s\f[]\f[I]i\f[]\f[I]o\f[]\f[I]n\f[]\f[I]w\f[]\f[I]i\f[]\f[I]l\f[]\f[I]l\f[]\f[I]r\f[]\f[I]e\f[]\f[I]m\f[]\f[I]a\f[]\f[I]i\f[]\f[I]n\f[]\f[I]u\f[]\f[I]n\f[]\f[I]e\f[]\f[I]x\f[]\f[I]p\f[]\f[I]a\f[]\f[I]n\f[]\f[I]d\f[]\f[I]e\f[]\f[I]d\f[](\f[I]i\f[].\f[I]e\f[]., \f[I]w\f[]\f[I]i\f[]\f[I]t\f[]\f[I]h\f[]\f[I]a\f[]\f[I]p\f[]\f[I]r\f[]\f[I]e\f[]\f[I]c\f[]\f[I]e\f[]\f[I]e\f[]\f[I]d\f[]\f[I]i\f[]\f[I]n\f[]\f[I]g\f[]′').
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Liver"\f[]
.IP \[bu] 2
\f[C]"Lung"\f[]
.IP \[bu] 2
\f[C]"Liver\ \-\ GTV"\f[]
.IP \[bu] 2
\f[C]"$LineName"\f[]
.SS Constraints
.SS Description
.PP
Constraint criteria that will be evaluated against the selected line
samples.
There three general types of constraints will be recognized.
First, constraints in the style of `Dmax < 50.0 Gy'.
The left\-hand\-size (LHS) can be any of {Dmin, Dmean, Dmax}.
The inequality can be any of {<, lt, <=, lte, >, gt, >=, gte}.
The right\-hand\-side (RHS) units can be any of {Gy, %} where `%' means
the RHS number is a percentage of the ReferenceDose.
Second, constraints in the style of `D(coldest 500.0 cc) < 50.4 Gy'.
The inner LHS can be any of {coldest, hottest}.
The inner LHS units can be any of {cc, cm3, cm^3, %} where `%' means the
inner LHS number is a percentage of the total volume.
The inequality can be any of {<, lt, <=, lte, >, gt, >=, gte}.
The RHS units can be any of {Gy, %} where `%' means the RHS number is a
percentage of the ReferenceDose.
Third, constraints in the style of `V(24.5 Gy) < 500.0 cc'.
The inner LHS units can be any of {Gy, %} where `%' means the inner LHS
number is a percentage of the ReferenceDose.
The inequality can be any of {<, lt, <=, lte, >, gt, >=, gte}.
The RHS units can be any of {cc, cm3, cm^3, %} where `%' means the inner
LHS number is a percentage of the total volume.
Multiple constraints can be supplied by separating them with `;'
delimiters.
Each will be evaluated separately.
Newlines can also be used, though constraints should all end with a `;'.
Comments can be included by preceeding with a `#', which facilitate
supplying lists of constraints piped in (e.g., from a file via Bash
process substitution).
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Dmax\ <\ 50.0\ Gy"\f[]
.IP \[bu] 2
\f[C]"Dmean\ lte\ 80\ %"\f[]
.IP \[bu] 2
\f[C]"Dmin\ >=\ 80\ %"\f[]
.IP \[bu] 2
\f[C]"Dmin\ >=\ 65\ Gy"\f[]
.IP \[bu] 2
\f[C]"D(coldest\ 500.0\ cc)\ <=\ 25.0\ Gy"\f[]
.IP \[bu] 2
\f[C]"D(coldest\ 500.0\ cc)\ <=\ 15.0\ %"\f[]
.IP \[bu] 2
\f[C]"D(coldest\ 50%)\ <=\ 15.0\ %"\f[]
.IP \[bu] 2
\f[C]"D(hottest\ 10%)\ gte\ 95.0\ %"\f[]
.IP \[bu] 2
\f[C]"V(24.5\ Gy)\ <\ 500.0\ cc"\f[]
.IP \[bu] 2
\f[C]"V(10%)\ <\ 50.0\ cc"\f[]
.IP \[bu] 2
\f[C]"V(24.5\ Gy)\ <\ 500.0\ cc"\f[]
.IP \[bu] 2
\f[C]"Dmax\ <\ 50.0\ Gy\ ;\ Dmean\ lte\ 80\ %\ ;\ D(hottest\ 10%)\ gte\ 95.0\ %"\f[]
.SS ReferenceDose
.SS Description
.PP
The absolute dose that relative (i.e., percentage) constraint doses will
be considered against.
Generally this will be the prescription dose (in DICOM units; Gy).
If there are multiple prescriptions, either the prescription appropriate
for the constraint should be supplied, or relative dose constraints
should not be used.
.SS Default
.IP \[bu] 2
\f[C]"nan"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"70.0"\f[]
.IP \[bu] 2
\f[C]"42.5"\f[]
.SS AnalyzeLightRadFieldCoincidence
.SS Description
.PP
This operation analyzes the selected images to compare light and
radiation field coincidence for fixed, symmetric field sizes.
Coincidences are extracted automatically by fitting Gaussians to the
peak nearest to one of the specified field boundaries and comparing
offset from one another.
So, for example, a 10x10cm MLC\-defined field would be compared to a
15x15cm field if there are sharp edges (say, metal rulers) that define a
10x10cm field (i.e., considered to represent the light field).
Horizontal and vertical directions (both positive and negative) are all
analyzed separately.
.SS Notes
.IP \[bu] 2
This routine assumes both fields are squarely aligned with the image
axes.
Alignment need not be perfect, but the Gaussians may be significantly
broadened if there is misalignment.
This should be fixed in a future revision.
.IP \[bu] 2
It is often useful to pre\-process inputs by computing an
in\-image\-plane derivative, gradient magnitude, or similar (i.e.,
something to emphasize edges) before calling this routine.
It may not be necessary, however.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
ToleranceLevel
.IP \[bu] 2
EdgeLengths
.IP \[bu] 2
SearchDistance
.IP \[bu] 2
PeakSimilarityThreshold
.IP \[bu] 2
UserComment
.IP \[bu] 2
OutputFileName
.IP \[bu] 2
InteractivePlots
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ToleranceLevel
.SS Description
.PP
Controls detected edge visualization for easy identification of edges
out of tolerance.
Note: this value refers to edge\-to\-edge separation, not
edge\-to\-nominal distances.
This value is in DICOM units.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"inf"\f[]
.SS EdgeLengths
.SS Description
.PP
Comma\-separated list of (symmetric) edge lengths fields should be
analyzed at.
For example, if 50x50, 100x100, 150x150, and 200x200 (all in mm) fields
are to be analyzed, this argument would be `50,100,150,200' and it will
be assumed that the field centre is at DICOM position (0,0,0).
All values are in DICOM units.
.SS Default
.IP \[bu] 2
\f[C]"100"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"100.0"\f[]
.IP \[bu] 2
\f[C]"50,100,150,200,300"\f[]
.IP \[bu] 2
\f[C]"10.273,20.2456"\f[]
.SS SearchDistance
.SS Description
.PP
The distance around the anticipated field edges to search for edges
(actually sharp peaks arising from edges).
If an edge is further away than this value from the anticipated field
edge, then the coincidence will be ignored altogether.
The value should be greater than the largest action/tolerance threshold
with some additional margin (so gross errors can be observed), but small
enough that spurious edges (i.e., unintended features in the image, such
as metal fasteners, or artifacts near the field edge) do not replace the
true field edges.
The `sharpness' of the field edge (resulting from the density of the
material used to demarcate the edge) can impact this value; if the edge
is not sharp, then the peak will be shallow, noisy, and may therefore
travel around depending on how the image is pre\-processed.
Note that both radiation field and light field edges may differ from the
`nominal' anticipated edges, so this wobble factor should be
incorporated in the search distance.
This quantity must be in DICOM units.
.SS Default
.IP \[bu] 2
\f[C]"3.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"2.5"\f[]
.IP \[bu] 2
\f[C]"3.0"\f[]
.IP \[bu] 2
\f[C]"5.0"\f[]
.SS PeakSimilarityThreshold
.SS Description
.PP
Images can be taken such that duplicate peaks will occur, such as when
field sizes are re\-used.
Peaks are therefore de\-duplicated.
This value (as a %, ranging from [0,100]) specifies the threshold of
disimilarity below which peaks are considered duplicates.
A low value will make duplicates confuse the analysis, but a high value
may cause legitimate peaks to be discarded depending on the attenuation
cababilties of the field edge markers.
.SS Default
.IP \[bu] 2
\f[C]"25"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"5"\f[]
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"15"\f[]
.IP \[bu] 2
\f[C]"50"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
If left empty, the column will be omitted from the output.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"6MV"\f[]
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Test\ with\ thick\ metal\ edges"\f[]
.SS OutputFileName
.SS Description
.PP
A filename (or full path) in which to append field edge coincidence data
generated by this routine.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS InteractivePlots
.SS Description
.PP
Whether to interactively show plots showing detected edges.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS AnalyzePicketFence
.SS Description
.PP
This operation extracts MLC positions from a picket fence image.
.SS Notes
.IP \[bu] 2
This routine requires data to be pre\-processed.
The gross picket area should be isolated and the leaf junction areas
contoured (one contour per junction).
Both can be accomplished via thresholding.
Additionally, stray pixels should be filtered out using, for example,
median or conservative filters.
.IP \[bu] 2
This routine analyzes the picket fences on the plane in which they are
specified within the DICOM file, which often coincides with the image
receptor (`RTImageSID').
Tolerances are evaluated on the isoplane, so the image is projected
before measuring distances, but the image itself is not altered; a
uniform magnification factor of SAD/SID is applied to all distances.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
MLCModel
.IP \[bu] 2
MLCROILabel
.IP \[bu] 2
JunctionROILabel
.IP \[bu] 2
PeakROILabel
.IP \[bu] 2
MinimumJunctionSeparation
.IP \[bu] 2
ThresholdDistance
.IP \[bu] 2
LeafGapsFileName
.IP \[bu] 2
ResultsSummaryFileName
.IP \[bu] 2
UserComment
.IP \[bu] 2
InteractivePlots
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS MLCModel
.SS Description
.PP
The MLC design geometry to use.
`VarianMillenniumMLC80' has 40 leafs in each bank; leaves are 10mm wide
at isocentre; and the maximum static field size is 40cm x 40cm.
`VarianMillenniumMLC120' has 60 leafs in each bank; the 40 central
leaves are 5mm wide at isocentre; the 20 peripheral leaves are 10mm
wide; and the maximum static field size is 40cm x 40cm.
`VarianHD120' has 60 leafs in each bank; the 32 central leaves are 2.5mm
wide at isocentre; the 28 peripheral leaves are 5mm wide; and the
maximum static field size is 40cm x 22cm.
.SS Default
.IP \[bu] 2
\f[C]"VarianMillenniumMLC120"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"VarianMillenniumMLC80"\f[]
.IP \[bu] 2
\f[C]"VarianMillenniumMLC120"\f[]
.IP \[bu] 2
\f[C]"VarianHD120"\f[]
.SS MLCROILabel
.SS Description
.PP
An ROI imitating the MLC axes of leaf pairs is created.
This is the label to apply to it.
Note that the leaves are modeled with thin contour rectangles of
virtually zero area.
Also note that the outline colour is significant and denotes leaf pair
pass/fail.
.SS Default
.IP \[bu] 2
\f[C]"Leaves"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"MLC_leaves"\f[]
.IP \[bu] 2
\f[C]"MLC"\f[]
.IP \[bu] 2
\f[C]"approx_leaf_axes"\f[]
.SS JunctionROILabel
.SS Description
.PP
An ROI imitating the junction is created.
This is the label to apply to it.
Note that the junctions are modeled with thin contour rectangles of
virtually zero area.
.SS Default
.IP \[bu] 2
\f[C]"Junction"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Junction"\f[]
.IP \[bu] 2
\f[C]"Picket_Fence_Junction"\f[]
.SS PeakROILabel
.SS Description
.PP
ROIs encircling the leaf profile peaks are created.
This is the label to apply to it.
Note that the peaks are modeled with small squares.
.SS Default
.IP \[bu] 2
\f[C]"Peak"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Peak"\f[]
.IP \[bu] 2
\f[C]"Picket_Fence_Peak"\f[]
.SS MinimumJunctionSeparation
.SS Description
.PP
The minimum distance between junctions on the SAD isoplane in DICOM
units (mm).
This number is used to de\-duplicate automatically detected junctions.
Analysis results should not be sensitive to the specific value.
.SS Default
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"5.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.IP \[bu] 2
\f[C]"15.0"\f[]
.IP \[bu] 2
\f[C]"25.0"\f[]
.SS ThresholdDistance
.SS Description
.PP
The threshold distance in DICOM units (mm) above which MLC separations
are considered to `fail'.
Each leaf pair is evaluated separately.
Pass/fail status is also indicated by setting the leaf axis contour
colour (blue for pass, red for fail).
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.SS LeafGapsFileName
.SS Description
.PP
This file will contain gap and nominal\-vs\-actual offset distances for
each leaf pair.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
If an existing file is present, rows will be appended without writing a
header.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS ResultsSummaryFileName
.SS Description
.PP
This file will contain a brief summary of the results.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
If an existing file is present, rows will be appended without writing a
header.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.SS InteractivePlots
.SS Description
.PP
Whether to interactively show plots showing detected edges.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS AnalyzeTPlan
.SS Description
.PP
This operation analyzes the selected RT plans, performing a general
analysis suitable for exploring or comparing plans at a high\-level.
Currently, only the total leaf opening (i.e., the sum of all leaf
openings \[en] the distance between a leaf in bank A to the opposing
leaf in bank B) is reported for each plan, beam, and control point.
The output is a CSV file that can be concatenated or appended to other
output files to provide a summary of multiple criteria.
.SS Parameters
.IP \[bu] 2
TPlanSelection
.IP \[bu] 2
SummaryFilename
.IP \[bu] 2
UserComment
.IP \[bu] 2
Description
.SS TPlanSelection
.SS Description
.PP
Select one or more treatment plans.
Note that a single treatment plan may be composed of multiple beams; if
delivered sequentially, they should collectively represent a single
logically cohesive plan.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth treatment
plan (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last treatment plan.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS SummaryFilename
.SS Description
.PP
Analysis results will be appended to this file.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
If an existing file is present, rows will be appended without writing a
header.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
Even if left empty, the column will remain in the output to ensure the
outputs from multiple runs can be safely concatenated.
Preceding alphanumeric variables with a `$' will cause them to be
treated as metadata keys and replaced with the corresponding key's
value, if present.
For example, `The modality is
\f[I]M\f[]\f[I]o\f[]\f[I]d\f[]\f[I]a\f[]\f[I]l\f[]\f[I]i\f[]\f[I]t\f[]\f[I]y\f[]′\f[I]m\f[]\f[I]i\f[]\f[I]g\f[]\f[I]h\f[]\f[I]t\f[]\f[I]b\f[]\f[I]e\f[](\f[I]d\f[]\f[I]e\f[]\f[I]p\f[]\f[I]e\f[]\f[I]n\f[]\f[I]d\f[]\f[I]i\f[]\f[I]n\f[]\f[I]g\f[]\f[I]o\f[]\f[I]n\f[]\f[I]t\f[]\f[I]h\f[]\f[I]e\f[]\f[I]m\f[]\f[I]e\f[]\f[I]t\f[]\f[I]a\f[]\f[I]d\f[]\f[I]a\f[]\f[I]t\f[]\f[I]a\f[])\f[I]e\f[]\f[I]x\f[]\f[I]p\f[]\f[I]a\f[]\f[I]n\f[]\f[I]d\f[]\f[I]e\f[]\f[I]d\f[]\f[I]t\f[]\f[I]o\f[]′\f[I]T\f[]\f[I]h\f[]\f[I]e\f[]\f[I]m\f[]\f[I]o\f[]\f[I]d\f[]\f[I]a\f[]\f[I]l\f[]\f[I]i\f[]\f[I]t\f[]\f[I]y\f[]\f[I]i\f[]\f[I]s\f[]\f[I]R\f[]\f[I]T\f[]\f[I]P\f[]\f[I]L\f[]\f[I]A\f[]\f[I]N\f[]′.\f[I]I\f[]\f[I]f\f[]\f[I]t\f[]\f[I]h\f[]\f[I]e\f[]\f[I]m\f[]\f[I]e\f[]\f[I]t\f[]\f[I]a\f[]\f[I]d\f[]\f[I]a\f[]\f[I]t\f[]\f[I]a\f[]\f[I]k\f[]\f[I]e\f[]\f[I]y\f[]\f[I]i\f[]\f[I]s\f[]\f[I]n\f[]\f[I]o\f[]\f[I]t\f[]\f[I]p\f[]\f[I]r\f[]\f[I]e\f[]\f[I]s\f[]\f[I]e\f[]\f[I]n\f[]\f[I]t\f[], \f[I]t\f[]\f[I]h\f[]\f[I]e\f[]\f[I]e\f[]\f[I]x\f[]\f[I]p\f[]\f[I]r\f[]\f[I]e\f[]\f[I]s\f[]\f[I]s\f[]\f[I]i\f[]\f[I]o\f[]\f[I]n\f[]\f[I]w\f[]\f[I]i\f[]\f[I]l\f[]\f[I]l\f[]\f[I]r\f[]\f[I]e\f[]\f[I]m\f[]\f[I]a\f[]\f[I]i\f[]\f[I]n\f[]\f[I]u\f[]\f[I]n\f[]\f[I]e\f[]\f[I]x\f[]\f[I]p\f[]\f[I]a\f[]\f[I]n\f[]\f[I]d\f[]\f[I]e\f[]\f[I]d\f[](\f[I]i\f[].\f[I]e\f[]., \f[I]w\f[]\f[I]i\f[]\f[I]t\f[]\f[I]h\f[]\f[I]a\f[]\f[I]p\f[]\f[I]r\f[]\f[I]e\f[]\f[I]c\f[]\f[I]e\f[]\f[I]e\f[]\f[I]d\f[]\f[I]i\f[]\f[I]n\f[]\f[I]g\f[]′').
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.IP \[bu] 2
\f[C]"$PatientID"\f[]
.SS Description
.SS Description
.PP
A string that will be inserted into the output file which should be used
to describe the constraint and any caveats that the viewer should be
aware of.
Generally, the UserComment is best for broadly\-defined notes whereas
the Description is tailored for each constraint.
Preceding alphanumeric variables with a `$' will cause them to be
treated as metadata keys and replaced with the corresponding key's
value, if present.
For example, `The modality is
\f[I]M\f[]\f[I]o\f[]\f[I]d\f[]\f[I]a\f[]\f[I]l\f[]\f[I]i\f[]\f[I]t\f[]\f[I]y\f[]′\f[I]m\f[]\f[I]i\f[]\f[I]g\f[]\f[I]h\f[]\f[I]t\f[]\f[I]b\f[]\f[I]e\f[](\f[I]d\f[]\f[I]e\f[]\f[I]p\f[]\f[I]e\f[]\f[I]n\f[]\f[I]d\f[]\f[I]i\f[]\f[I]n\f[]\f[I]g\f[]\f[I]o\f[]\f[I]n\f[]\f[I]t\f[]\f[I]h\f[]\f[I]e\f[]\f[I]m\f[]\f[I]e\f[]\f[I]t\f[]\f[I]a\f[]\f[I]d\f[]\f[I]a\f[]\f[I]t\f[]\f[I]a\f[])\f[I]e\f[]\f[I]x\f[]\f[I]p\f[]\f[I]a\f[]\f[I]n\f[]\f[I]d\f[]\f[I]e\f[]\f[I]d\f[]\f[I]t\f[]\f[I]o\f[]′\f[I]T\f[]\f[I]h\f[]\f[I]e\f[]\f[I]m\f[]\f[I]o\f[]\f[I]d\f[]\f[I]a\f[]\f[I]l\f[]\f[I]i\f[]\f[I]t\f[]\f[I]y\f[]\f[I]i\f[]\f[I]s\f[]\f[I]R\f[]\f[I]T\f[]\f[I]P\f[]\f[I]L\f[]\f[I]A\f[]\f[I]N\f[]′.\f[I]I\f[]\f[I]f\f[]\f[I]t\f[]\f[I]h\f[]\f[I]e\f[]\f[I]m\f[]\f[I]e\f[]\f[I]t\f[]\f[I]a\f[]\f[I]d\f[]\f[I]a\f[]\f[I]t\f[]\f[I]a\f[]\f[I]k\f[]\f[I]e\f[]\f[I]y\f[]\f[I]i\f[]\f[I]s\f[]\f[I]n\f[]\f[I]o\f[]\f[I]t\f[]\f[I]p\f[]\f[I]r\f[]\f[I]e\f[]\f[I]s\f[]\f[I]e\f[]\f[I]n\f[]\f[I]t\f[], \f[I]t\f[]\f[I]h\f[]\f[I]e\f[]\f[I]e\f[]\f[I]x\f[]\f[I]p\f[]\f[I]r\f[]\f[I]e\f[]\f[I]s\f[]\f[I]s\f[]\f[I]i\f[]\f[I]o\f[]\f[I]n\f[]\f[I]w\f[]\f[I]i\f[]\f[I]l\f[]\f[I]l\f[]\f[I]r\f[]\f[I]e\f[]\f[I]m\f[]\f[I]a\f[]\f[I]i\f[]\f[I]n\f[]\f[I]u\f[]\f[I]n\f[]\f[I]e\f[]\f[I]x\f[]\f[I]p\f[]\f[I]a\f[]\f[I]n\f[]\f[I]d\f[]\f[I]e\f[]\f[I]d\f[](\f[I]i\f[].\f[I]e\f[]., \f[I]w\f[]\f[I]i\f[]\f[I]t\f[]\f[I]h\f[]\f[I]a\f[]\f[I]p\f[]\f[I]r\f[]\f[I]e\f[]\f[I]c\f[]\f[I]e\f[]\f[I]e\f[]\f[I]d\f[]\f[I]i\f[]\f[I]n\f[]\f[I]g\f[]′').
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"2\ Arcs"\f[]
.IP \[bu] 2
\f[C]"1\ Arc"\f[]
.IP \[bu] 2
\f[C]"IMRT"\f[]
.SS ApplyCalibrationCurve
.SS Description
.PP
This operation applies a given calibration curve to voxel data inside
the specified ROI(s).
It is designed to apply calibration curves, but is useful for
transforming voxel intensities using any supplied 1D curve.
.SS Notes
.IP \[bu] 2
This routine can handle overlapping or duplicate contours.
.SS Parameters
.IP \[bu] 2
Channel
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
ContourOverlap
.IP \[bu] 2
Inclusivity
.IP \[bu] 2
CalibCurveFileName
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.SS Channel
.SS Description
.PP
The image channel to use.
Zero\-based.
Use `\-1' to operate on all available channels.
.SS Default
.IP \[bu] 2
\f[C]"\-1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ContourOverlap
.SS Description
.PP
Controls overlapping contours are treated.
The default `ignore' treats overlapping contours as a single contour,
regardless of contour orientation.
The option `honour_opposite_orientations' makes overlapping contours
with opposite orientation cancel.
Otherwise, orientation is ignored.
The latter is useful for Boolean structures where contour orientation is
significant for interior contours (holes).
The option `overlapping_contours_cancel' ignores orientation and cancels
all contour overlap.
.SS Default
.IP \[bu] 2
\f[C]"ignore"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"ignore"\f[]
.IP \[bu] 2
\f[C]"honour_opposite_orientations"\f[]
.IP \[bu] 2
\f[C]"overlapping_contours_cancel"\f[]
.IP \[bu] 2
\f[C]"honour_opps"\f[]
.IP \[bu] 2
\f[C]"overlap_cancel"\f[]
.SS Inclusivity
.SS Description
.PP
Controls how voxels are deemed to be `within' the interior of the
selected ROI(s).
The default `center' considers only the central\-most point of each
voxel.
There are two corner options that correspond to a 2D projection of the
voxel onto the image plane.
The first, `planar_corner_inclusive', considers a voxel interior if ANY
corner is interior.
The second, `planar_corner_exclusive', considers a voxel interior if ALL
(four) corners are interior.
.SS Default
.IP \[bu] 2
\f[C]"center"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"center"\f[]
.IP \[bu] 2
\f[C]"centre"\f[]
.IP \[bu] 2
\f[C]"planar_corner_inclusive"\f[]
.IP \[bu] 2
\f[C]"planar_inc"\f[]
.IP \[bu] 2
\f[C]"planar_corner_exclusive"\f[]
.IP \[bu] 2
\f[C]"planar_exc"\f[]
.SS CalibCurveFileName
.SS Description
.PP
The file from which a calibration curve should be read from.
The format should be line\-based with either 2 or 4 numbers per line.
For 2 numbers: (current pixel value) (new pixel value) and for 4
numbers: (current pixel value) (uncertainty) (new pixel value)
(uncertainty).
Uncertainties refer to the prior number and may be uniformly zero if
unknown.
Lines beginning with `#' are treated as comments and ignored.
The curve is linearly interpolated, and must span the full range of
pixel values.
This is done to avoid extrapolation within the operation since the
correct behaviour will differ depending on the specifics of the
calibration.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"/tmp/calib.dat"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS AutoCropImages
.SS Description
.PP
This operation crops image slices using image\-specific metadata
embedded within the image.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
DICOMMargin
.IP \[bu] 2
RTIMAGE
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS DICOMMargin
.SS Description
.PP
The amount of margin (in the DICOM coordinate system) to spare from
cropping.
.SS Default
.IP \[bu] 2
\f[C]"0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"\-0.5"\f[]
.IP \[bu] 2
\f[C]"20.0"\f[]
.SS RTIMAGE
.SS Description
.PP
If true, attempt to crop the image using information embedded in an
RTIMAGE.
This option cannot be used with the other options.
.SS Default
.IP \[bu] 2
\f[C]"true"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS Average
.SS Description
.PP
This operation averages image arrays/volumes.
It can average over spatial or temporal dimensions.
However, rather than relying specifically on time for temporal
averaging, any images that have overlapping voxels can be averaged.
.SS Notes
.IP \[bu] 2
This operation is typically used to create an aggregate view of a large
volume of data.
It may also increase SNR and can be used for contouring purposes.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
AveragingMethod
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS AveragingMethod
.SS Description
.PP
The averaging method to use.
Valid methods are `overlapping\-spatially' and
`overlapping\-temporally'.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"overlapping\-spatially"\f[]
.IP \[bu] 2
\f[C]"overlapping\-temporally"\f[]
.SS BCCAExtractRadiomicFeatures
.SS Description
.PP
This operation extracts radiomic features from an image and one or more
ROIs.
.SS Notes
.IP \[bu] 2
This is a `simplified' version of the full radiomics extract routine
that uses defaults that are expected to be reasonable across a wide
range of scenarios.
.SS Parameters
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
FractionalAreaTolerance
.IP \[bu] 2
SimplificationMethod
.IP \[bu] 2
UserComment
.IP \[bu] 2
FeaturesFileName
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
ScaleFactor
.IP \[bu] 2
ImageFileName
.IP \[bu] 2
ColourMapRegex
.IP \[bu] 2
WindowLow
.IP \[bu] 2
WindowHigh
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS FractionalAreaTolerance
.SS Description
.PP
The fraction of area each contour will tolerate during simplified.
This is a measure of how much the contour area can change due to
simplification.
.SS Default
.IP \[bu] 2
\f[C]"0.05"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.001"\f[]
.IP \[bu] 2
\f[C]"0.01"\f[]
.IP \[bu] 2
\f[C]"0.02"\f[]
.IP \[bu] 2
\f[C]"0.05"\f[]
.IP \[bu] 2
\f[C]"0.10"\f[]
.SS SimplificationMethod
.SS Description
.PP
The specific algorithm used to perform contour simplification.
`Vertex removal' is a simple algorithm that removes vertices
one\-by\-one without replacement.
It iteratively ranks vertices and removes the single vertex that has the
least impact on contour area.
It is best suited to removing redundant vertices or whenever new
vertices should not be added.
`Vertex collapse' combines two adjacent vertices into a single vertex at
their midpoint.
It iteratively ranks vertex pairs and removes the single vertex that has
the least total impact on contour area.
Note that small sharp features that alternate inward and outward will
have a small total area cost, so will be pruned early.
Thus this technique acts as a low\-pass filter and will defer
simplification of high\-curvature regions until necessary.
It is more economical compared to vertex removal in that it will usually
simplify contours more for a given tolerance (or, equivalently, can
retain contour fidelity better than vertex removal for the same number
of vertices).
However, vertex collapse performs an averaging that may result in
numerical imprecision.
.SS Default
.IP \[bu] 2
\f[C]"vert\-rem"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"vertex\-collapse"\f[]
.IP \[bu] 2
\f[C]"vertex\-removal"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.SS FeaturesFileName
.SS Description
.PP
Features will be appended to this file.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
If an existing file is present, rows will be appended without writing a
header.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS ScaleFactor
.SS Description
.PP
This factor is applied to the image width and height to magnify (larger
than 1) or shrink (less than 1) the image.
This factor only affects the output image size.
Note that aspect ratio is retained, but rounding for non\-integer
factors may lead to small (1\-2 pixel) discrepancies.
.SS Default
.IP \[bu] 2
\f[C]"1.5"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"5.23"\f[]
.SS ImageFileName
.SS Description
.PP
The file name to use for the image.
If blank, a filename will be generated sequentially.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/an_image.png"\f[]
.IP \[bu] 2
\f[C]"afile.png"\f[]
.SS ColourMapRegex
.SS Description
.PP
The colour mapping to apply to the image if there is a single channel.
The default will match the first available, and if there is no matching
map found, the first available will be selected.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Viridis"\f[]
.IP \[bu] 2
\f[C]"Magma"\f[]
.IP \[bu] 2
\f[C]"Plasma"\f[]
.IP \[bu] 2
\f[C]"Inferno"\f[]
.IP \[bu] 2
\f[C]"Jet"\f[]
.IP \[bu] 2
\f[C]"MorelandBlueRed"\f[]
.IP \[bu] 2
\f[C]"MorelandBlackBody"\f[]
.IP \[bu] 2
\f[C]"MorelandExtendedBlackBody"\f[]
.IP \[bu] 2
\f[C]"KRC"\f[]
.IP \[bu] 2
\f[C]"ExtendedKRC"\f[]
.IP \[bu] 2
\f[C]"Kovesi_LinKRYW_5\-100_c64"\f[]
.IP \[bu] 2
\f[C]"Kovesi_LinKRYW_0\-100_c71"\f[]
.IP \[bu] 2
\f[C]"Kovesi_Cyclic_cet\-c2"\f[]
.IP \[bu] 2
\f[C]"LANLOliveGreentoBlue"\f[]
.IP \[bu] 2
\f[C]"YgorIncandescent"\f[]
.IP \[bu] 2
\f[C]"LinearRamp"\f[]
.SS WindowLow
.SS Description
.PP
If provided, this parameter will override any existing window and level.
All pixels with the intensity value or lower will be assigned the lowest
possible colour according to the colour map.
Not providing a valid number will disable window overrides.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"\-1.23"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1E4"\f[]
.SS WindowHigh
.SS Description
.PP
If provided, this parameter will override any existing window and level.
All pixels with the intensity value or higher will be assigned the
highest possible colour according to the colour map.
Not providing a valid number will disable window overrides.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"10.3E4"\f[]
.SS BoostSerializeDrover
.SS Description
.PP
This operation exports all loaded state to a serialized format that can
be loaded again later.
Is is especially useful for suspending long\-running operations with
intermittant interactive sub\-operations.
.SS Parameters
.IP \[bu] 2
Filename
.IP \[bu] 2
Components
.SS Filename
.SS Description
.PP
The filename (or full path name) to which the serialized data should be
written.
The file format is gzipped XML, which should be portable across most
CPUs.
.SS Default
.IP \[bu] 2
\f[C]"/tmp/boost_serialized_drover.xml.gz"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"/tmp/out.xml.gz"\f[]
.IP \[bu] 2
\f[C]"./out.xml.gz"\f[]
.IP \[bu] 2
\f[C]"out.xml.gz"\f[]
.SS Components
.SS Description
.PP
Which components to include in the output.
Currently, any combination of (all images), (all contours), (all point
clouds), (all surface meshes), and (all treatment plans) can be
selected.
Note that RTDOSEs are treated as images.
.SS Default
.IP \[bu] 2
\f[C]"images+contours+pointclouds+surfacemeshes+tplans"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"images"\f[]
.IP \[bu] 2
\f[C]"images+pointclouds"\f[]
.IP \[bu] 2
\f[C]"images+pointclouds+surfacemeshes"\f[]
.IP \[bu] 2
\f[C]"pointclouds+surfacemeshes"\f[]
.IP \[bu] 2
\f[C]"tplans+images+contours"\f[]
.IP \[bu] 2
\f[C]"contours+images+pointclouds"\f[]
.SS BuildLexiconInteractively
.SS Description
.PP
This operation interactively builds a lexicon using the currently loaded
contour labels.
It is useful for constructing a domain\-specific lexicon from a set of
representative data.
.SS Parameters
.IP \[bu] 2
CleanLabels
.IP \[bu] 2
JunkLabel
.IP \[bu] 2
OmitROILabelRegex
.IP \[bu] 2
LexiconSeedFile
.SS CleanLabels
.SS Description
.PP
A listing of the labels of interest.
These will be (some of) the `clean' entries in the finished lexicon.
You should only name ROIs you specifically care about and which have a
single, unambiguous occurence in the data set (e.g., `Left_Parotid' is
good, but `JUNK' and `Parotids' are bad \[en] you won't be able to
select the single `JUNK' label if all you care about are parotids.
.SS Default
.IP \[bu] 2
\f[C]"Body,Brainstem,Chiasm,Cord,Larynx\ Pharynx,Left\ Eye,Left\ Optic\ Nerve,Left\ Parotid,Left\ Submand,Left\ Temp\ Lobe,Oral\ Cavity,Right\ Eye,Right\ Optic\ Nerve,Right\ Parotid,Right\ Submand,Right\ Temp\ Lobe"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Left\ Parotid,Right\ Parotid,Left\ Submand,Right\ Submand"\f[]
.IP \[bu] 2
\f[C]"Left\ Submand,Right\ Submand"\f[]
.SS JunkLabel
.SS Description
.PP
A label to apply to the un\-matched labels.
This helps prevent false positives by excluding names which are close to
a desired clean label.
For example, if you are looking for `Left_Parotid' you will want to mark
`left\-parotid_opti' and `OLDLeftParotid' as junk.
Passing an empty string disables junk labeling.
.SS Default
.IP \[bu] 2
\f[C]"JUNK"\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"Junk"\f[]
.IP \[bu] 2
\f[C]"Irrelevant"\f[]
.IP \[bu] 2
\f[C]"NA_Organ"\f[]
.SS OmitROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to prune.
Only matching ROIs will be pruned.
The default will match no ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
(Note: an exclusive approach is taken rather than an inclusive approach
because regex negations are not easily supported in the POSIX syntax.)
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*left.*|.*right.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]".*PTV.*|.*CTV.*|.*GTV.*"\f[]
.SS LexiconSeedFile
.SS Description
.PP
A file containing a `seed' lexicon to use and add to.
This is the lexicon that is being built.
It will be modified.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"./some_lexicon"\f[]
.IP \[bu] 2
\f[C]"/tmp/temp_lexicon"\f[]
.SS CT_Liver_Perfusion
.SS Description
.PP
This operation performed dynamic contrast\-enhanced CT perfusion image
modeling on a time series image volume.
.SS Notes
.IP \[bu] 2
This routine is used for research purposes only.
.SS Parameters
.PP
No registered options.
.SS CT_Liver_Perfusion_First_Run
.SS Description
.PP
This operation performed dynamic contrast\-enhanced CT perfusion image
modeling on a time series image volume.
.SS Notes
.IP \[bu] 2
Use this mode when peeking at the data for the first time.
It avoids computing much, just lets you \f[I]look\f[] at the data, find
t_0, etc..
.SS Parameters
.PP
No registered options.
.SS CT_Liver_Perfusion_Ortho_Views
.SS Description
.PP
This operation performed dynamic contrast\-enhanced CT perfusion image
modeling on a time series image volume.
.SS Notes
.IP \[bu] 2
Use this mode when you are only interested in oblique/orthogonal views.
The point of this operation is to keep memory low so image sets can be
compared.
.SS Parameters
.PP
No registered options.
.SS CT_Liver_Perfusion_Pharmaco_1C2I_5Param
.SS Description
.PP
This operation performed dynamic contrast\-enhanced CT perfusion image
modeling on a time series image volume.
.SS Parameters
.IP \[bu] 2
AIFROINameRegex
.IP \[bu] 2
ExponentialKernelCoeffTruncation
.IP \[bu] 2
FastChebyshevMultiplication
.IP \[bu] 2
PlotAIFVIF
.IP \[bu] 2
PlotPixelModel
.IP \[bu] 2
PreDecimateOutSizeR
.IP \[bu] 2
PreDecimateOutSizeC
.IP \[bu] 2
TargetROINameRegex
.IP \[bu] 2
UseBasisSplineInterpolation
.IP \[bu] 2
BasisSplineCoefficients
.IP \[bu] 2
BasisSplineOrder
.IP \[bu] 2
UseChebyshevPolyMethod
.IP \[bu] 2
ChebyshevPolyCoefficients
.IP \[bu] 2
VIFROINameRegex
.SS AIFROINameRegex
.SS Description
.PP
Regex for the name of the ROI to use as the AIF.
It should generally be a major artery near the trunk or near the tissue
of interest.
.SS Default
.IP \[bu] 2
\f[C]"Abdominal_Aorta"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Abdominal_Aorta"\f[]
.IP \[bu] 2
\f[C]".*Aorta.*"\f[]
.IP \[bu] 2
\f[C]"Major_Artery"\f[]
.SS ExponentialKernelCoeffTruncation
.SS Description
.PP
Control the number of Chebyshev coefficients used to approximate the
exponential kernel.
Usually ~10 will suffice.
~20 is probably overkill, and ~5 is probably too few.
It is probably better to err on the side of caution and enlarge this
number if you're worried about loss of precision \[en] this will slow
the computation somewhat.
(You might be able to offset by retaining fewer coefficients in
Chebyshev multiplication; see `FastChebyshevMultiplication' parameter.)
.SS Default
.IP \[bu] 2
\f[C]"10"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"20"\f[]
.IP \[bu] 2
\f[C]"15"\f[]
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"5"\f[]
.SS FastChebyshevMultiplication
.SS Description
.PP
Control coefficient truncation/pruning to speed up Chebyshev polynomial
multiplication.
(This setting does nothing if the Chebyshev method is not being used.)
The choice of this number depends on how much precision you are willing
to forgo.
It also strongly depends on the number of datum in the AIF, VIF, and the
number of coefficients used to approximate the exponential kernel
(usually ~10 suffices).
Numbers are specified relative to max(N,M), where N and M are the number
of coefficients in the two Chebyshev expansions taking part in the
multiplication.
If too many coefficients are requested (i.e., more than (N+M\-2)) then
the full non\-approximate multiplication is carried out.
.SS Default
.IP \[bu] 2
\f[C]"*10000000.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"*2.0"\f[]
.IP \[bu] 2
\f[C]"*1.5"\f[]
.IP \[bu] 2
\f[C]"*1.0"\f[]
.IP \[bu] 2
\f[C]"*0.5"\f[]
.IP \[bu] 2
\f[C]"*0.3"\f[]
.SS PlotAIFVIF
.SS Description
.PP
Control whether the AIF and VIF should be shown prior to modeling.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS PlotPixelModel
.SS Description
.PP
Show a plot of the fitted model for a specified pixel.
Plotting happens immediately after the pixel is processed.
You can supply arbitrary metadata, but must also supply Row and Column
numbers.
Note that numerical comparisons are performed lexically, so you have to
be exact.
Also note the sub\-separation token is a semi\-colon, not a colon.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Row\@12;Column\@4;Description\@.*k1A.*"\f[]
.IP \[bu] 2
\f[C]"Row\@256;Column\@500;SliceLocation\@23;SliceThickness\@0.5"\f[]
.IP \[bu] 2
\f[C]"Row\@256;Column\@500;Some\@thing#Row\@256;Column\@501;Another\@thing"\f[]
.IP \[bu] 2
\f[C]"Row\@0;Column\@5#Row\@4;Column\@5#Row\@8;Column\@5#Row\@12;Column\@5"\f[]
.SS PreDecimateOutSizeR
.SS Description
.PP
The number of pixels along the row unit vector to group into an outgoing
pixel.
This optional step can reduce computation effort by downsampling
(decimating) images before computing fitted parameter maps (but
\f[I]after\f[] computing AIF and VIF time courses).
Must be a multiplicative factor of the incoming image's row count.
No decimation occurs if either this or `PreDecimateOutSizeC' is zero or
negative.
.SS Default
.IP \[bu] 2
\f[C]"8"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"4"\f[]
.IP \[bu] 2
\f[C]"8"\f[]
.IP \[bu] 2
\f[C]"16"\f[]
.IP \[bu] 2
\f[C]"32"\f[]
.IP \[bu] 2
\f[C]"64"\f[]
.IP \[bu] 2
\f[C]"128"\f[]
.IP \[bu] 2
\f[C]"256"\f[]
.IP \[bu] 2
\f[C]"512"\f[]
.SS PreDecimateOutSizeC
.SS Description
.PP
The number of pixels along the column unit vector to group into an
outgoing pixel.
This optional step can reduce computation effort by downsampling
(decimating) images before computing fitted parameter maps (but
\f[I]after\f[] computing AIF and VIF time courses).
Must be a multiplicative factor of the incoming image's column count.
No decimation occurs if either this or `PreDecimateOutSizeR' is zero or
negative.
.SS Default
.IP \[bu] 2
\f[C]"8"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"4"\f[]
.IP \[bu] 2
\f[C]"8"\f[]
.IP \[bu] 2
\f[C]"16"\f[]
.IP \[bu] 2
\f[C]"32"\f[]
.IP \[bu] 2
\f[C]"64"\f[]
.IP \[bu] 2
\f[C]"128"\f[]
.IP \[bu] 2
\f[C]"256"\f[]
.IP \[bu] 2
\f[C]"512"\f[]
.SS TargetROINameRegex
.SS Description
.PP
Regex for the name of the ROI to perform modeling within.
The largest contour is usually what you want, but you can also be more
focused.
.SS Default
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Liver_Patches_For_Testing_Smaller"\f[]
.IP \[bu] 2
\f[C]"Liver_Patches_For_Testing"\f[]
.IP \[bu] 2
\f[C]"Suspected_Liver_Rough"\f[]
.IP \[bu] 2
\f[C]"Rough_Body"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]".*something.*\\|.*another.*thing.*"\f[]
.SS UseBasisSplineInterpolation
.SS Description
.PP
Control whether the AIF and VIF should use basis spline interpolation in
conjunction with the Chebyshev polynomial method.
If this option is not set, linear interpolation is used instead.
Linear interpolation may result in a less\-smooth AIF and VIF (and
therefore possibly slower optimizer convergence), but is safer if you
cannot verify the AIF and VIF plots are reasonable.
This option currently produces an effect only if the Chebyshev
polynomial method is being used.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS BasisSplineCoefficients
.SS Description
.PP
Control the number of basis spline coefficients to use, if applicable.
(This setting does nothing when basis splines are not being used.) Valid
options for this setting depend on the amount of data and b\-spline
order.
This number controls the number of coefficients that are fitted (via
least\-squares).
You must verify that overfitting is not happening.
If in doubt, use fewer coefficients.
There are two ways to specify the number: relative and absolute.
Relative means relative to the number of datum.
For example, if the AIF and VIF have ~40 datum then generally `\f[I]0.5'
is safe. ('\f[]0.5' means there are half the number of coefficients as
datum.) Inspect for overfitting and poor fit.
Because this routine happens once and is fast, do not tweak to optimize
for speed; the aim of this method is to produce a smooth and accurate
AIF and VIF.
Because an integer number of coefficients are needed, so rounding is
used.
You can also specify the absolute number of coefficients to use like
`20'.
It often makes more sense to use relative specification.
Be aware that not all inputs can be honoured due to limits on b\-spline
knots and breaks, and may cause unpredictable behaviour or internal
failure.
.SS Default
.IP \[bu] 2
\f[C]"*0.5"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"*0.8"\f[]
.IP \[bu] 2
\f[C]"*0.5"\f[]
.IP \[bu] 2
\f[C]"*0.3"\f[]
.IP \[bu] 2
\f[C]"20.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS BasisSplineOrder
.SS Description
.PP
Control the polynomial order of basis spline interpolation to use, if
applicable.
(This setting does nothing when basis splines are not being used.) This
parameter controls the order of polynomial used for b\-spline
interpolation, and therefore has ramifications for the computability and
numerical stability of AIF and VIF derivatives.
Stick with `4' or `5' if you're unsure.
.SS Default
.IP \[bu] 2
\f[C]"4"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.IP \[bu] 2
\f[C]"4"\f[]
.IP \[bu] 2
\f[C]"5"\f[]
.IP \[bu] 2
\f[C]"6"\f[]
.IP \[bu] 2
\f[C]"7"\f[]
.IP \[bu] 2
\f[C]"8"\f[]
.IP \[bu] 2
\f[C]"9"\f[]
.IP \[bu] 2
\f[C]"10"\f[]
.SS UseChebyshevPolyMethod
.SS Description
.PP
Control whether the AIF and VIF should be approximated by Chebyshev
polynomials.
If this option is not set, a inear interpolation approach is used
instead.
.SS Default
.IP \[bu] 2
\f[C]"true"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS ChebyshevPolyCoefficients
.SS Description
.PP
Control the number of Chebyshev polynomial coefficients to use, if
applicable.
(This setting does nothing when the Chebyshev polynomial method is not
being used.) This number controls the number of coefficients that are
computed.
There are two ways to specify the number: relative and absolute.
Relative means relative to the number of datum.
For example, if the AIF and VIF have ~40 datum then generally `\f[I]2'
is safe. ('\f[]2' means there are 2x the number of coefficients as
datum; usually overkill.) A good middle\-ground is '*1' which is faster
but should produce similar results.
For speed `/2' is even faster, but can produce bad results in some
cases.
Because an integer number of coefficients are needed, rounding is used.
You can also specify the absolute number of coefficients to use like
`20'.
It often makes more sense to use relative specification.
Be aware that not all inputs can be honoured (i.e., too large, too
small, or negative), and may cause unpredictable behaviour or internal
failure.
.SS Default
.IP \[bu] 2
\f[C]"*2.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"*10.0"\f[]
.IP \[bu] 2
\f[C]"*5.0"\f[]
.IP \[bu] 2
\f[C]"*2.0"\f[]
.IP \[bu] 2
\f[C]"*1.23"\f[]
.IP \[bu] 2
\f[C]"*1.0"\f[]
.IP \[bu] 2
\f[C]"/1.0"\f[]
.IP \[bu] 2
\f[C]"/2.0"\f[]
.IP \[bu] 2
\f[C]"/3.0"\f[]
.IP \[bu] 2
\f[C]"/5.0"\f[]
.IP \[bu] 2
\f[C]"100.0"\f[]
.IP \[bu] 2
\f[C]"50.0"\f[]
.IP \[bu] 2
\f[C]"20"\f[]
.IP \[bu] 2
\f[C]"10.01"\f[]
.SS VIFROINameRegex
.SS Description
.PP
Regex for the name of the ROI to use as the VIF.
It should generally be a major vein near the trunk or near the tissue of
interest.
.SS Default
.IP \[bu] 2
\f[C]"Hepatic_Portal_Vein"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Hepatic_Portal_Vein"\f[]
.IP \[bu] 2
\f[C]".*Portal.*Vein.*"\f[]
.IP \[bu] 2
\f[C]"Major_Vein"\f[]
.SS CT_Liver_Perfusion_Pharmaco_1C2I_Reduced3Param
.SS Description
.PP
This operation performed dynamic contrast\-enhanced CT perfusion image
modeling on a time series image volume.
.SS Parameters
.IP \[bu] 2
AIFROINameRegex
.IP \[bu] 2
ExponentialKernelCoeffTruncation
.IP \[bu] 2
FastChebyshevMultiplication
.IP \[bu] 2
PlotAIFVIF
.IP \[bu] 2
PlotPixelModel
.IP \[bu] 2
PreDecimateOutSizeR
.IP \[bu] 2
PreDecimateOutSizeC
.IP \[bu] 2
TargetROINameRegex
.IP \[bu] 2
UseBasisSplineInterpolation
.IP \[bu] 2
BasisSplineCoefficients
.IP \[bu] 2
BasisSplineOrder
.IP \[bu] 2
ChebyshevPolyCoefficients
.IP \[bu] 2
VIFROINameRegex
.SS AIFROINameRegex
.SS Description
.PP
Regex for the name of the ROI to use as the AIF.
It should generally be a major artery near the trunk or near the tissue
of interest.
.SS Default
.IP \[bu] 2
\f[C]"Abdominal_Aorta"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Abdominal_Aorta"\f[]
.IP \[bu] 2
\f[C]".*Aorta.*"\f[]
.IP \[bu] 2
\f[C]"Major_Artery"\f[]
.SS ExponentialKernelCoeffTruncation
.SS Description
.PP
Control the number of Chebyshev coefficients used to approximate the
exponential kernel.
Usually ~10 will suffice.
~20 is probably overkill, and ~5 is probably too few.
It is probably better to err on the side of caution and enlarge this
number if you're worried about loss of precision \[en] this will slow
the computation somewhat.
(You might be able to offset by retaining fewer coefficients in
Chebyshev multiplication; see `FastChebyshevMultiplication' parameter.)
.SS Default
.IP \[bu] 2
\f[C]"10"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"20"\f[]
.IP \[bu] 2
\f[C]"15"\f[]
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"5"\f[]
.SS FastChebyshevMultiplication
.SS Description
.PP
Control coefficient truncation/pruning to speed up Chebyshev polynomial
multiplication.
(This setting does nothing if the Chebyshev method is not being used.)
The choice of this number depends on how much precision you are willing
to forgo.
It also strongly depends on the number of datum in the AIF, VIF, and the
number of coefficients used to approximate the exponential kernel
(usually ~10 suffices).
Numbers are specified relative to max(N,M), where N and M are the number
of coefficients in the two Chebyshev expansions taking part in the
multiplication.
If too many coefficients are requested (i.e., more than (N+M\-2)) then
the full non\-approximate multiplication is carried out.
.SS Default
.IP \[bu] 2
\f[C]"*10000000.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"*2.0"\f[]
.IP \[bu] 2
\f[C]"*1.5"\f[]
.IP \[bu] 2
\f[C]"*1.0"\f[]
.IP \[bu] 2
\f[C]"*0.5"\f[]
.IP \[bu] 2
\f[C]"*0.3"\f[]
.SS PlotAIFVIF
.SS Description
.PP
Control whether the AIF and VIF should be shown prior to modeling.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS PlotPixelModel
.SS Description
.PP
Show a plot of the fitted model for a specified pixel.
Plotting happens immediately after the pixel is processed.
You can supply arbitrary metadata, but must also supply Row and Column
numbers.
Note that numerical comparisons are performed lexically, so you have to
be exact.
Also note the sub\-separation token is a semi\-colon, not a colon.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Row\@12;Column\@4;Description\@.*k1A.*"\f[]
.IP \[bu] 2
\f[C]"Row\@256;Column\@500;SliceLocation\@23;SliceThickness\@0.5"\f[]
.IP \[bu] 2
\f[C]"Row\@256;Column\@500;Some\@thing#Row\@256;Column\@501;Another\@thing"\f[]
.IP \[bu] 2
\f[C]"Row\@0;Column\@5#Row\@4;Column\@5#Row\@8;Column\@5#Row\@12;Column\@5"\f[]
.SS PreDecimateOutSizeR
.SS Description
.PP
The number of pixels along the row unit vector to group into an outgoing
pixel.
This optional step can reduce computation effort by downsampling
(decimating) images before computing fitted parameter maps (but
\f[I]after\f[] computing AIF and VIF time courses).
Must be a multiplicative factor of the incoming image's row count.
No decimation occurs if either this or `PreDecimateOutSizeC' is zero or
negative.
.SS Default
.IP \[bu] 2
\f[C]"8"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"4"\f[]
.IP \[bu] 2
\f[C]"8"\f[]
.IP \[bu] 2
\f[C]"16"\f[]
.IP \[bu] 2
\f[C]"32"\f[]
.IP \[bu] 2
\f[C]"64"\f[]
.IP \[bu] 2
\f[C]"128"\f[]
.IP \[bu] 2
\f[C]"256"\f[]
.IP \[bu] 2
\f[C]"512"\f[]
.SS PreDecimateOutSizeC
.SS Description
.PP
The number of pixels along the column unit vector to group into an
outgoing pixel.
This optional step can reduce computation effort by downsampling
(decimating) images before computing fitted parameter maps (but
\f[I]after\f[] computing AIF and VIF time courses).
Must be a multiplicative factor of the incoming image's column count.
No decimation occurs if either this or `PreDecimateOutSizeR' is zero or
negative.
.SS Default
.IP \[bu] 2
\f[C]"8"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"4"\f[]
.IP \[bu] 2
\f[C]"8"\f[]
.IP \[bu] 2
\f[C]"16"\f[]
.IP \[bu] 2
\f[C]"32"\f[]
.IP \[bu] 2
\f[C]"64"\f[]
.IP \[bu] 2
\f[C]"128"\f[]
.IP \[bu] 2
\f[C]"256"\f[]
.IP \[bu] 2
\f[C]"512"\f[]
.SS TargetROINameRegex
.SS Description
.PP
Regex for the name of the ROI to perform modeling within.
The largest contour is usually what you want, but you can also be more
focused.
.SS Default
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Liver_Patches_For_Testing_Smaller"\f[]
.IP \[bu] 2
\f[C]"Liver_Patches_For_Testing"\f[]
.IP \[bu] 2
\f[C]"Suspected_Liver_Rough"\f[]
.IP \[bu] 2
\f[C]"Rough_Body"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]".*something.*\\|.*another.*thing.*"\f[]
.SS UseBasisSplineInterpolation
.SS Description
.PP
Control whether the AIF and VIF should use basis spline interpolation in
conjunction with the Chebyshev polynomial method.
If this option is not set, linear interpolation is used instead.
Linear interpolation may result in a less\-smooth AIF and VIF (and
therefore possibly slower optimizer convergence), but is safer if you
cannot verify the AIF and VIF plots are reasonable.
This option currently produces an effect only if the Chebyshev
polynomial method is being used.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS BasisSplineCoefficients
.SS Description
.PP
Control the number of basis spline coefficients to use, if applicable.
(This setting does nothing when basis splines are not being used.) Valid
options for this setting depend on the amount of data and b\-spline
order.
This number controls the number of coefficients that are fitted (via
least\-squares).
You must verify that overfitting is not happening.
If in doubt, use fewer coefficients.
There are two ways to specify the number: relative and absolute.
Relative means relative to the number of datum.
For example, if the AIF and VIF have ~40 datum then generally `\f[I]0.5'
is safe. ('\f[]0.5' means there are half the number of coefficients as
datum.) Inspect for overfitting and poor fit.
Because this routine happens once and is fast, do not tweak to optimize
for speed; the aim of this method is to produce a smooth and accurate
AIF and VIF.
Because an integer number of coefficients are needed, so rounding is
used.
You can also specify the absolute number of coefficients to use like
`20'.
It often makes more sense to use relative specification.
Be aware that not all inputs can be honoured due to limits on b\-spline
knots and breaks, and may cause unpredictable behaviour or internal
failure.
.SS Default
.IP \[bu] 2
\f[C]"*0.5"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"*0.8"\f[]
.IP \[bu] 2
\f[C]"*0.5"\f[]
.IP \[bu] 2
\f[C]"*0.3"\f[]
.IP \[bu] 2
\f[C]"20.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS BasisSplineOrder
.SS Description
.PP
Control the polynomial order of basis spline interpolation to use, if
applicable.
(This setting does nothing when basis splines are not being used.) This
parameter controls the order of polynomial used for b\-spline
interpolation, and therefore has ramifications for the computability and
numerical stability of AIF and VIF derivatives.
Stick with `4' or `5' if you're unsure.
.SS Default
.IP \[bu] 2
\f[C]"4"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.IP \[bu] 2
\f[C]"4"\f[]
.IP \[bu] 2
\f[C]"5"\f[]
.IP \[bu] 2
\f[C]"6"\f[]
.IP \[bu] 2
\f[C]"7"\f[]
.IP \[bu] 2
\f[C]"8"\f[]
.IP \[bu] 2
\f[C]"9"\f[]
.IP \[bu] 2
\f[C]"10"\f[]
.SS ChebyshevPolyCoefficients
.SS Description
.PP
Control the number of Chebyshev polynomial coefficients to use, if
applicable.
(This setting does nothing when the Chebyshev polynomial method is not
being used.) This number controls the number of coefficients that are
computed.
There are two ways to specify the number: relative and absolute.
Relative means relative to the number of datum.
For example, if the AIF and VIF have ~40 datum then generally `\f[I]2'
is safe. ('\f[]2' means there are 2x the number of coefficients as
datum; usually overkill.) A good middle\-ground is '*1' which is faster
but should produce similar results.
For speed `/2' is even faster, but can produce bad results in some
cases.
Because an integer number of coefficients are needed, rounding is used.
You can also specify the absolute number of coefficients to use like
`20'.
It often makes more sense to use relative specification.
Be aware that not all inputs can be honoured (i.e., too large, too
small, or negative), and may cause unpredictable behaviour or internal
failure.
.SS Default
.IP \[bu] 2
\f[C]"*2.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"*10.0"\f[]
.IP \[bu] 2
\f[C]"*5.0"\f[]
.IP \[bu] 2
\f[C]"*2.0"\f[]
.IP \[bu] 2
\f[C]"*1.23"\f[]
.IP \[bu] 2
\f[C]"*1.0"\f[]
.IP \[bu] 2
\f[C]"/1.0"\f[]
.IP \[bu] 2
\f[C]"/2.0"\f[]
.IP \[bu] 2
\f[C]"/3.0"\f[]
.IP \[bu] 2
\f[C]"/5.0"\f[]
.IP \[bu] 2
\f[C]"100.0"\f[]
.IP \[bu] 2
\f[C]"50.0"\f[]
.IP \[bu] 2
\f[C]"20"\f[]
.IP \[bu] 2
\f[C]"10.01"\f[]
.SS VIFROINameRegex
.SS Description
.PP
Regex for the name of the ROI to use as the VIF.
It should generally be a major vein near the trunk or near the tissue of
interest.
.SS Default
.IP \[bu] 2
\f[C]"Hepatic_Portal_Vein"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Hepatic_Portal_Vein"\f[]
.IP \[bu] 2
\f[C]".*Portal.*Vein.*"\f[]
.IP \[bu] 2
\f[C]"Major_Vein"\f[]
.SS ClusterDBSCAN
.SS Description
.PP
This routine performs DBSCAN clustering on an image volume.
The clustering is limited within ROI(s) and also within a range of voxel
intensities.
Voxels values are overwritten with the cluster ID (if applicable) or a
generic configurable background value.
.SS Notes
.IP \[bu] 2
This operation will work with single images and image volumes.
Images need not be rectilinear.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
ContourOverlap
.IP \[bu] 2
Inclusivity
.IP \[bu] 2
Channel
.IP \[bu] 2
Lower
.IP \[bu] 2
Upper
.IP \[bu] 2
MinPoints
.IP \[bu] 2
MaxPoints
.IP \[bu] 2
Eps
.IP \[bu] 2
BackgroundValue
.IP \[bu] 2
Reduction
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS ContourOverlap
.SS Description
.PP
Controls overlapping contours are treated.
The default `ignore' treats overlapping contours as a single contour,
regardless of contour orientation.
The option `honour_opposite_orientations' makes overlapping contours
with opposite orientation cancel.
Otherwise, orientation is ignored.
The latter is useful for Boolean structures where contour orientation is
significant for interior contours (holes).
The option `overlapping_contours_cancel' ignores orientation and cancels
all contour overlap.
.SS Default
.IP \[bu] 2
\f[C]"ignore"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"ignore"\f[]
.IP \[bu] 2
\f[C]"honour_opposite_orientations"\f[]
.IP \[bu] 2
\f[C]"overlapping_contours_cancel"\f[]
.IP \[bu] 2
\f[C]"honour_opps"\f[]
.IP \[bu] 2
\f[C]"overlap_cancel"\f[]
.SS Inclusivity
.SS Description
.PP
Controls how voxels are deemed to be `within' the interior of the
selected ROI(s).
The default `center' considers only the central\-most point of each
voxel.
There are two corner options that correspond to a 2D projection of the
voxel onto the image plane.
The first, `planar_corner_inclusive', considers a voxel interior if ANY
corner is interior.
The second, `planar_corner_exclusive', considers a voxel interior if ALL
(four) corners are interior.
.SS Default
.IP \[bu] 2
\f[C]"center"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"center"\f[]
.IP \[bu] 2
\f[C]"centre"\f[]
.IP \[bu] 2
\f[C]"planar_corner_inclusive"\f[]
.IP \[bu] 2
\f[C]"planar_inc"\f[]
.IP \[bu] 2
\f[C]"planar_corner_exclusive"\f[]
.IP \[bu] 2
\f[C]"planar_exc"\f[]
.SS Channel
.SS Description
.PP
The channel to operated on (zero\-based).
Negative values will cause all channels to be operated on.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.SS Lower
.SS Description
.PP
Lower threshold (inclusive) below which voxels will be ignored by this
routine.
.SS Default
.IP \[bu] 2
\f[C]"\-inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-inf"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"1024"\f[]
.SS Upper
.SS Description
.PP
Upper threshold (inclusive) above which voxels will be ignored by this
routine.
.SS Default
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"inf"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"2048"\f[]
.SS MinPoints
.SS Description
.PP
DBSCAN algorithm parameter representing the minimum number of points
that must appear in the vicinity for a cluster to be recognized.
Sanders, et al.
(1998) recommend a default of twice the dimensionality, but what is
considered to be a reasonable value depends on the sparsity of the
inputs and geometry.
For regular grids, a slightly smaller value might be more appropriate.
.SS Default
.IP \[bu] 2
\f[C]"5"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"4"\f[]
.IP \[bu] 2
\f[C]"6"\f[]
.IP \[bu] 2
\f[C]"15"\f[]
.SS MaxPoints
.SS Description
.PP
Reject clusters if they would contain more than this many members.
This parameter can be used to reject irrelevant background clusters or
to help search for disconnected clusters.
Setting this parameter appropriately will improve both memory usage and
runtime considerably.
.SS Default
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"1000"\f[]
.IP \[bu] 2
\f[C]"1E6"\f[]
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Eps
.SS Description
.PP
DBSCAN algorithm parameter representing the threshold separation
distance (in DICOM units; mm) between members of a cluster.
All members in a cluster must be separated from at least MinPoints
points within a distance of Eps.
There is a standard way to determine an optimal value from the data
itself, but requires generating a k\-nearest\-neighbours clustering
first, and then visually identifying an appropriate `kink' in the
k\-distances plot.
This approach is not implemented here.
Alternatively, the sparsity of the data and the specific problem domain
must be used to estimate a desirable separation Eps.
.SS Default
.IP \[bu] 2
\f[C]"4.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.5"\f[]
.IP \[bu] 2
\f[C]"2.5"\f[]
.IP \[bu] 2
\f[C]"4.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS BackgroundValue
.SS Description
.PP
The voxel intensity that will be assigned to all voxels that are not
members of a cluster.
Note that this value can be anything, but cluster numbers are
zero\-based, so a negative background is probably desired.
.SS Default
.IP \[bu] 2
\f[C]"\-1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1.0"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"100.23"\f[]
.IP \[bu] 2
\f[C]"nan"\f[]
.IP \[bu] 2
\f[C]"\-inf"\f[]
.SS Reduction
.SS Description
.PP
Voxels within a cluster can be marked as\-is, or reduced in a variety of
ways.
If reduction is not used, voxels in a valid cluster will have their
values replaced with the cluster ID number.
If `median' reduction is specified, the component\-wise median is
reported for each cluster; the x\-, y\-, and z\-coordinates of all
voxels in each individual cluster will be reduced to the median
coordinate.
.SS Default
.IP \[bu] 2
\f[C]"none"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"median"\f[]
.SS ComparePixels
.SS Description
.PP
This operation compares images (`test' images and `reference' images) on
a per\-voxel/per\-pixel basis.
Any combination of 2D and 3D images is supported, including images which
do not fully overlap, but the reference image array must be rectilinear
(this property is verified).
.SS Notes
.IP \[bu] 2
Images are overwritten, but ReferenceImages are not.
Multiple Images may be specified, but only one ReferenceImages may be
specified.
.IP \[bu] 2
The reference image array must be rectilinear.
(This is a requirement specific to this implementation, a less
restrictive implementation could overcome the issue.)
.IP \[bu] 2
For the fastest and most accurate results, test and reference image
arrays should spatially align.
However, alignment is \f[B]not\f[] necessary.
If test and reference image arrays are aligned, image adjacency can be
precomputed and the analysis will be faster.
If not, image adjacency must be evaluated for every voxel.
.IP \[bu] 2
The distance\-to\-agreement comparison will tend to overestimate the
distance, especially when the DTA value is low, because voxel size
effects will dominate the estimation.
Reference images should be supersampled as necessary.
.IP \[bu] 2
This operation optionally makes use of interpolation for sub\-voxel
distance estimation.
However, interpolation is currently limited to be along the edges
connecting nearest\- and next\-nearest voxel centres.
In other words, true volumetric interpolation is \f[B]not\f[] available.
Implicit interpolation is also used (via the intermediate value theorem)
for the distance\-to\-agreement comparison, which results in distance
estimation that may vary up to the largest caliper distance of a voxel.
For this reason, the accuracy of all comparisons should be expected to
be limited by image spatial resolution (i.e., voxel dimensions).
Reference images should be supersampled as necessary.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
ReferenceImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Method
.IP \[bu] 2
Channel
.IP \[bu] 2
TestImgLowerThreshold
.IP \[bu] 2
TestImgUpperThreshold
.IP \[bu] 2
RefImgLowerThreshold
.IP \[bu] 2
RefImgUpperThreshold
.IP \[bu] 2
DiscType
.IP \[bu] 2
DTAVoxValEqAbs
.IP \[bu] 2
DTAVoxValEqRelDiff
.IP \[bu] 2
DTAMax
.IP \[bu] 2
DTAInterpolationMethod
.IP \[bu] 2
GammaDTAThreshold
.IP \[bu] 2
GammaDiscThreshold
.IP \[bu] 2
GammaTerminateAboveOne
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ReferenceImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Method
.SS Description
.PP
The comparison method to compute.
Three options are currently available: distance\-to\-agreement (DTA),
discrepancy, and gamma\-index.
All three are fully 3D, but can also work for 2D or mixed 2D\-3D
comparisons.
DTA is a measure of how far away the nearest voxel (in the reference
images) is with a voxel intensity sufficiently close to each voxel in
the test images.
This comparison ignores pixel intensities except to test if the values
match within the specified tolerance.
The voxel neighbourhood is exhaustively explored until a suitable voxel
is found.
Implicit interpolation is used to detect when the value could be found
via interpolation, but explicit interpolation is not used.
Thus distance might be overestimated.
A discrepancy comparison measures the point intensity discrepancy
without accounting for spatial shifts.
A gamma analysis combines distance\-to\-agreement and point differences
into a single index which is best used to test if both DTA and
discrepancy criteria are satisfied (gamma <= 1 iff both pass).
It was proposed by Low et al.\ in 1998 ((doi:10.1118/1.598248).
Gamma analyses permits trade\-offs between spatial and dosimetric
discrepancies which can arise when the image arrays slightly differ in
alignment or pixel values.
.SS Default
.IP \[bu] 2
\f[C]"gamma\-index"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"gamma\-index"\f[]
.IP \[bu] 2
\f[C]"DTA"\f[]
.IP \[bu] 2
\f[C]"discrepancy"\f[]
.SS Channel
.SS Description
.PP
The channel to compare (zero\-based).
Note that both test images and reference images will share this
specifier.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS TestImgLowerThreshold
.SS Description
.PP
Pixel lower threshold for the test images.
Only voxels with values above this threshold (inclusive) will be
altered.
.SS Default
.IP \[bu] 2
\f[C]"\-inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-inf"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"200"\f[]
.SS TestImgUpperThreshold
.SS Description
.PP
Pixel upper threshold for the test images.
Only voxels with values below this threshold (inclusive) will be
altered.
.SS Default
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"inf"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"1000"\f[]
.SS RefImgLowerThreshold
.SS Description
.PP
Pixel lower threshold for the reference images.
Only voxels with values above this threshold (inclusive) will be
altered.
.SS Default
.IP \[bu] 2
\f[C]"\-inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-inf"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"200"\f[]
.SS RefImgUpperThreshold
.SS Description
.PP
Pixel upper threshold for the reference images.
Only voxels with values below this threshold (inclusive) will be
altered.
.SS Default
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"inf"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"1000"\f[]
.SS DiscType
.SS Description
.PP
Parameter for all comparisons estimating the direct, voxel\-to\-voxel
discrepancy.
There are currently three types available.
`Relative' is the absolute value of the difference of two voxel values
divided by the largest of the two values.
`Difference' is the difference of two voxel values.
`PinnedToMax' is the absolute value of the difference of two voxel
values divided by the largest voxel value in the selected images.
.SS Default
.IP \[bu] 2
\f[C]"relative"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"relative"\f[]
.IP \[bu] 2
\f[C]"difference"\f[]
.IP \[bu] 2
\f[C]"pinned\-to\-max"\f[]
.SS DTAVoxValEqAbs
.SS Description
.PP
Parameter for all comparisons involving a distance\-to\-agreement (DTA)
search.
The difference in voxel values considered to be sufficiently equal
(absolute; in voxel intensity units).
Note: This value CAN be zero.
It is meant to help overcome noise.
Note that this value is ignored by all interpolation methods.
.SS Default
.IP \[bu] 2
\f[C]"1.0E\-3"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.0E\-3"\f[]
.IP \[bu] 2
\f[C]"1.0E\-5"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"0.5"\f[]
.SS DTAVoxValEqRelDiff
.SS Description
.PP
Parameter for all comparisons involving a distance\-to\-agreement (DTA)
search.
The difference in voxel values considered to be sufficiently equal
(~relative difference; in %).
Note: This value CAN be zero.
It is meant to help overcome noise.
Note that this value is ignored by all interpolation methods.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS DTAMax
.SS Description
.PP
Parameter for all comparisons involving a distance\-to\-agreement (DTA)
search.
Maximally acceptable distance\-to\-agreement (in DICOM units: mm) above
which to stop searching.
All voxels within this distance will be searched unless a matching voxel
is found.
Note that a gamma\-index comparison may terminate this search early if
the gamma\-index is known to be greater than one.
It is recommended to make this value approximately 1 voxel width larger
than necessary in case a matching voxel can be located near the
boundary.
Also note that some voxels beyond the DTA_max distance may be evaluated.
.SS Default
.IP \[bu] 2
\f[C]"30.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"3.0"\f[]
.IP \[bu] 2
\f[C]"5.0"\f[]
.IP \[bu] 2
\f[C]"50.0"\f[]
.SS DTAInterpolationMethod
.SS Description
.PP
Parameter for all comparisons involving a distance\-to\-agreement (DTA)
search.
Controls how precisely and how often the space between voxel centres are
interpolated to identify the exact position of agreement.
There are currently three options: no interpolation (`None'),
nearest\-neighbour (`NN'), and next\-nearest\-neighbour (`NNN').
(1) If no interpolation is selected, the agreement position will only be
established to within approximately the reference image voxels
dimensions.
To avoid interpolation, voxels that straddle the target value are taken
as the agreement distance.
Conceptually, if you view a voxel as having a finite spatial extent then
this method may be sufficient for distance assessment.
Though it is not precise, it is fast.
This method will tend to over\-estimate the actual distance, though it
is possible that it slightly under\-estimates it.
This method works best when the reference image grid size is small in
comparison to the desired spatial accuracy (e.g., if computing gamma,
the tolerance should be much larger than the largest voxel dimension) so
supersampling is recommended.
(2) Nearest\-neighbour interpolation considers the line connecting
directly adjacent voxels.
Using linear interpolation along this line when adjacent voxels straddle
the target value, the 3D point where the target value appears can be
predicted.
This method can significantly improve distance estimation accuracy,
though will typically be much slower than no interpolation.
On the other hand, this method lower amounts of supersampling, though it
is most reliable when the reference image grid size is small in
comparison to the desired spatial accuracy.
Note that nearest\-neighbour interpolation also makes use of the `no
interpolation' methods.
If you have a fine reference image, prefer either no interpolation or
nearest\-neighbour interpolation.
(3) Finally, next\-nearest\-neighbour considers the diagonally\-adjacent
neighbours separated by taxi\-cab distance of 2 (so in\-plane diagonals
are considered, but 3D diagonals are not).
Quadratic (i.e., bi\-linear) interpolation is analytically solved to
determine where along the straddling diagonal the target value appears.
This method is more expensive than linear interpolation but will
generally result in more accurate distance estimates.
This method may require lower amounts of supersampling than linear
interpolation, but is most reliable when the reference image grid size
is small in comparison to the desired spatial accuracy.
Use of this method may not be appropriate in all cases considering that
supersampling may be needed and a quadratic equation is solved for every
voxel diagonal.
Note that next\-nearest\-neighbour interpolation also makes use of the
nearest\-neighbour and `no interpolation' methods.
.SS Default
.IP \[bu] 2
\f[C]"NN"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"None"\f[]
.IP \[bu] 2
\f[C]"NN"\f[]
.IP \[bu] 2
\f[C]"NNN"\f[]
.SS GammaDTAThreshold
.SS Description
.PP
Parameter for gamma\-index comparisons.
Maximally acceptable distance\-to\-agreement (in DICOM units: mm).
When the measured DTA is above this value, the gamma index will
necessarily be greater than one.
Note this parameter can differ from the DTA_max search cut\-off, but
should be <= to it.
.SS Default
.IP \[bu] 2
\f[C]"5.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"3.0"\f[]
.IP \[bu] 2
\f[C]"5.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS GammaDiscThreshold
.SS Description
.PP
Parameter for gamma\-index comparisons.
Voxel value discrepancies lower than this value are considered
acceptable, but values above will result in gamma values >1.
The specific interpretation of this parameter (and the units) depend on
the specific type of discrepancy used.
For percentage\-based discrepancies, this parameter is interpretted as a
percentage (i.e., `5.0' = `5%').
For voxel intensity measures such as the absolute difference, this value
is interpretted as an absolute threshold with the same intensity units
(i.e., `5.0' = `5 HU' or similar).
.SS Default
.IP \[bu] 2
\f[C]"5.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"3.0"\f[]
.IP \[bu] 2
\f[C]"5.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS GammaTerminateAboveOne
.SS Description
.PP
Parameter for gamma\-index comparisons.
Halt spatial searching if the gamma index will necessarily indicate
failure (i.e., gamma >1).
Note this can parameter can drastically reduce the computational effort
required to compute the gamma index, but the reported gamma values will
be invalid whenever they are >1.
This is often tolerable since the magnitude only matters when it is <1.
In lieu of the true gamma\-index, a value slightly >1 will be assumed.
.SS Default
.IP \[bu] 2
\f[C]"true"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS ContourBasedRayCastDoseAccumulate
.SS Description
.PP
This operation performs ray\-casting to estimate the dose of a surface.
The surface is represented as a set of contours (i.e., an ROI).
.SS Parameters
.IP \[bu] 2
DoseLengthMapFileName
.IP \[bu] 2
LengthMapFileName
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
CylinderRadius
.IP \[bu] 2
RaydL
.IP \[bu] 2
Rows
.IP \[bu] 2
Columns
.SS DoseLengthMapFileName
.SS Description
.PP
A filename (or full path) for the (dose)*(length traveled through the
ROI peel) image map.
The format is TBD.
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.img"\f[]
.IP \[bu] 2
\f[C]"derivative_data.img"\f[]
.SS LengthMapFileName
.SS Description
.PP
A filename (or full path) for the (length traveled through the ROI peel)
image map.
The format is TBD.
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.img"\f[]
.IP \[bu] 2
\f[C]"derivative_data.img"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS CylinderRadius
.SS Description
.PP
The radius of the cylinder surrounding contour line segments that
defines the `surface'.
Quantity is in the DICOM coordinate system.
.SS Default
.IP \[bu] 2
\f[C]"3.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"5.0"\f[]
.SS RaydL
.SS Description
.PP
The distance to move a ray each iteration.
Should be << img_thickness and << cylinder_radius.
Making too large will invalidate results, causing rays to pass through
the surface without registering any dose accumulation.
Making too small will cause the run\-time to grow and may eventually
lead to truncation or round\-off errors.
Quantity is in the DICOM coordinate system.
.SS Default
.IP \[bu] 2
\f[C]"0.1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"0.05"\f[]
.IP \[bu] 2
\f[C]"0.01"\f[]
.IP \[bu] 2
\f[C]"0.005"\f[]
.SS Rows
.SS Description
.PP
The number of rows in the resulting images.
.SS Default
.IP \[bu] 2
\f[C]"256"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"50"\f[]
.IP \[bu] 2
\f[C]"128"\f[]
.IP \[bu] 2
\f[C]"1024"\f[]
.SS Columns
.SS Description
.PP
The number of columns in the resulting images.
.SS Default
.IP \[bu] 2
\f[C]"256"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"50"\f[]
.IP \[bu] 2
\f[C]"128"\f[]
.IP \[bu] 2
\f[C]"1024"\f[]
.SS ContourBooleanOperations
.SS Description
.PP
This routine performs 2D Boolean operations on user\-provided sets of
ROIs.
The ROIs themselves are planar contours embedded in R^3, but the Boolean
operation is performed once for each 2D plane where the selected ROIs
reside.
This routine can only perform Boolean operations on co\-planar contours.
This routine can operate on single contours (rather than ROIs composed
of several contours) by simply presenting this routine with a single
contour to select.
.SS Notes
.IP \[bu] 2
This routine DOES support disconnected ROIs, such as left\- and
right\-parotid contours that have been joined into a single `parotids'
ROI.
.IP \[bu] 2
Many Boolean operations can produce contours with holes.
This operation currently connects the interior and exterior with a seam
so that holes can be represented by a single polygon (rather than a
separate hole polygon).
It \f[I]is\f[] possible to export holes as contours with a negative
orientation, but this was not needed when writing.
.IP \[bu] 2
Only the common metadata between contours is propagated to the product
contours.
.SS Parameters
.IP \[bu] 2
ROILabelRegexA
.IP \[bu] 2
ROILabelRegexB
.IP \[bu] 2
NormalizedROILabelRegexA
.IP \[bu] 2
NormalizedROILabelRegexB
.IP \[bu] 2
Operation
.IP \[bu] 2
OutputROILabel
.SS ROILabelRegexA
.SS Description
.PP
A regex matching ROI labels/names that comprise the set of contour
polygons `A' as in f(A,B) where f is some Boolean operation.
The default with match all available ROIs, which is probably not what
you want.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*[pP]rostate.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS ROILabelRegexB
.SS Description
.PP
A regex matching ROI labels/names that comprise the set of contour
polygons `B' as in f(A,B) where f is some Boolean operation.
The default with match all available ROIs, which is probably not what
you want.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS NormalizedROILabelRegexA
.SS Description
.PP
A regex matching ROI labels/names that comprise the set of contour
polygons `A' as in f(A,B) where f is some Boolean operation.
The regex is applied to normalized ROI labels/names, which are
translated using a user\-provided lexicon (i.e., a dictionary that
supports fuzzy matching).
The default with match all available ROIs, which is probably not what
you want.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS NormalizedROILabelRegexB
.SS Description
.PP
A regex matching ROI labels/names that comprise the set of contour
polygons `B' as in f(A,B) where f is some Boolean operation.
The regex is applied to normalized ROI labels/names, which are
translated using a user\-provided lexicon (i.e., a dictionary that
supports fuzzy matching).
The default with match all available ROIs, which is probably not what
you want.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS Operation
.SS Description
.PP
The Boolean operation (e.g., the function `f') to perform on the sets of
contour polygons `A' and `B'.
`Symmetric difference' is also known as `XOR'.
.SS Default
.IP \[bu] 2
\f[C]"join"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"intersection"\f[]
.IP \[bu] 2
\f[C]"join"\f[]
.IP \[bu] 2
\f[C]"difference"\f[]
.IP \[bu] 2
\f[C]"symmetric_difference"\f[]
.SS OutputROILabel
.SS Description
.PP
The label to attach to the ROI contour product of f(A,B).
.SS Default
.IP \[bu] 2
\f[C]"Boolean_result"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"A+B"\f[]
.IP \[bu] 2
\f[C]"A\-B"\f[]
.IP \[bu] 2
\f[C]"AuB"\f[]
.IP \[bu] 2
\f[C]"AnB"\f[]
.IP \[bu] 2
\f[C]"AxB"\f[]
.IP \[bu] 2
\f[C]"A^B"\f[]
.IP \[bu] 2
\f[C]"union"\f[]
.IP \[bu] 2
\f[C]"xor"\f[]
.IP \[bu] 2
\f[C]"combined"\f[]
.IP \[bu] 2
\f[C]"body_without_spinal_cord"\f[]
.SS ContourSimilarity
.SS Description
.PP
This operation estimates the similarity or overlap between two sets of
contours.
The comparison is based on point samples.
It is useful for comparing contouring styles.
.SS Notes
.IP \[bu] 2
This routine requires an image grid, which is used to control where the
contours are sampled.
Images are not modified.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
NormalizedROILabelRegexA
.IP \[bu] 2
ROILabelRegexA
.IP \[bu] 2
NormalizedROILabelRegexB
.IP \[bu] 2
ROILabelRegexB
.IP \[bu] 2
FileName
.IP \[bu] 2
UserComment
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegexA
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegexA
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS NormalizedROILabelRegexB
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegexB
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS FileName
.SS Description
.PP
A filename (or full path) in which to append similarity data generated
by this routine.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.SS ContourViaGeometry
.SS Description
.PP
This operation constructs ROI contours using geometrical primitives.
.SS Notes
.IP \[bu] 2
This routine requires an image array onto which the contours will be
written.
.IP \[bu] 2
This routine expects images to be non\-overlapping.
In other words, if images overlap then the contours generated may also
overlap.
This is probably not what you want (but there is nothing intrinsically
wrong with presenting this routine with multiple images if you
intentionally want overlapping contours).
.IP \[bu] 2
Existing contours are ignored and unaltered.
.IP \[bu] 2
Small and degenerate contours produced by this routine are suppressed.
If a specific number of contours must be generated, provide a slightly
larger radius to compensate for the degenerate cases at the extrema.
.SS Parameters
.IP \[bu] 2
ROILabel
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
Shapes
.SS ROILabel
.SS Description
.PP
A label to attach to the ROI contours.
.SS Default
.IP \[bu] 2
\f[C]"unspecified"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"unspecified"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"air"\f[]
.IP \[bu] 2
\f[C]"bone"\f[]
.IP \[bu] 2
\f[C]"invalid"\f[]
.IP \[bu] 2
\f[C]"above_zero"\f[]
.IP \[bu] 2
\f[C]"below_5.3"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Shapes
.SS Description
.PP
This parameter is used to specify the shapes to consider.
There is currently a single supported shape: sphere.
However, it is likely that more shapes will be accepted in the future.
Spheres have two configurable parameters: centre and radius.
A sphere with centre (1.0,2.0,3.0) and radius 12.3 can be specified as
`sphere(1.0, 2.0, 3.0, 12.3)'.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"sphere(\-1.0,\ 2.0,\ 3.0,\ \ 12.3)"\f[]
.SS ContourViaThreshold
.SS Description
.PP
This operation constructs ROI contours using images and pixel/voxel
value thresholds.
There are two methods of contour generation available: a simple binary
method in which voxels are either fully in or fully out of the contour,
and a method based on marching cubes that will provide smoother
contours.
The marching cubes method does \f[B]not\f[] construct a full surface
mesh; rather each individual image slice has their own mesh constructed
in parallel.
.SS Notes
.IP \[bu] 2
This routine expects images to be non\-overlapping.
In other words, if images overlap then the contours generated may also
overlap.
This is probably not what you want (but there is nothing intrinsically
wrong with presenting this routine with multiple images if you
intentionally want overlapping contours).
.IP \[bu] 2
Existing contours are ignored and unaltered.
.IP \[bu] 2
Contour orientation is (likely) not properly handled in this routine, so
`pinches' and holes will produce contours with inconsistent or invalid
topology.
If in doubt, disable merge simplifications and live with the
computational penalty.
The marching cubes approach will properly handle `pinches' and contours
should all be topologically valid.
.SS Parameters
.IP \[bu] 2
ROILabel
.IP \[bu] 2
Lower
.IP \[bu] 2
Upper
.IP \[bu] 2
Channel
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
Method
.IP \[bu] 2
SimplifyMergeAdjacent
.SS ROILabel
.SS Description
.PP
A label to attach to the ROI contours.
.SS Default
.IP \[bu] 2
\f[C]"unspecified"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"unspecified"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"air"\f[]
.IP \[bu] 2
\f[C]"bone"\f[]
.IP \[bu] 2
\f[C]"invalid"\f[]
.IP \[bu] 2
\f[C]"above_zero"\f[]
.IP \[bu] 2
\f[C]"below_5.3"\f[]
.SS Lower
.SS Description
.PP
The lower bound (inclusive).
Pixels with values < this number are excluded from the ROI.
If the number is followed by a `%', the bound will be scaled between the
min and max pixel values [0\-100%].
If the number is followed by `tile', the bound will be replaced with the
corresponding percentile [0\-100tile].
Note that upper and lower bounds can be specified separately (e.g.,
lower bound is a percentage, but upper bound is a percentile).
.SS Default
.IP \[bu] 2
\f[C]"\-inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1E\-99"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"0.2%"\f[]
.IP \[bu] 2
\f[C]"23tile"\f[]
.IP \[bu] 2
\f[C]"23.123\ tile"\f[]
.SS Upper
.SS Description
.PP
The upper bound (inclusive).
Pixels with values > this number are excluded from the ROI.
If the number is followed by a `%', the bound will be scaled between the
min and max pixel values [0\-100%].
If the number is followed by `tile', the bound will be replaced with the
corresponding percentile [0\-100tile].
Note that upper and lower bounds can be specified separately (e.g.,
lower bound is a percentage, but upper bound is a percentile).
.SS Default
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"1E\-99"\f[]
.IP \[bu] 2
\f[C]"2.34"\f[]
.IP \[bu] 2
\f[C]"98.12%"\f[]
.IP \[bu] 2
\f[C]"94tile"\f[]
.IP \[bu] 2
\f[C]"94.123\ tile"\f[]
.SS Channel
.SS Description
.PP
The image channel to use.
Zero\-based.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Method
.SS Description
.PP
There are currently two supported methods for generating contours: (1) a
simple (and fast) binary inclusivity checker, that simply checks if a
voxel is within the ROI by testing the value at the voxel centre, and
(2) a robust (but slow) method based on marching cubes.
The binary method is fast, but produces extremely jagged contours.
It may also have problems with `pinches' and topological consistency.
The marching method is more robust and should reliably produce contours
for even the most complicated topologies, but is considerably slower
than the binary method.
.SS Default
.IP \[bu] 2
\f[C]"binary"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"binary"\f[]
.IP \[bu] 2
\f[C]"marching"\f[]
.SS SimplifyMergeAdjacent
.SS Description
.PP
Simplify contours by merging adjacent contours.
This reduces the number of contours dramatically, but will cause issues
if there are holes (two contours are generated if there is a single
hole, but most DICOMautomaton code disregards orientation \[en] so the
pixels within the hole will be considered part of the ROI, possibly even
doubly so depending on the algorithm).
Disabling merges is always safe (and is therefore the default) but can
be extremely costly for large images.
Furthermore, if you know the ROI does not have holes (or if you don't
care) then it is safe to enable merges.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS ContourVote
.SS Description
.PP
This routine pits contours against one another using various criteria.
A number of `closest' or `best' or `winning' contours are copied into a
new contour collection with the specified ROILabel.
The original ROIs are not altered, even the winning ROIs.
.SS Notes
.IP \[bu] 2
This operation considers individual contours only at the moment.
It could be extended to operate on whole ROIs (i.e.,
contour_collections), or to perform a separate vote within each ROI.
The individual contour approach was taken for relevance in 2D image
(e.g., RTIMAGE) analysis.
.IP \[bu] 2
This operation currently cannot perform voting on multiple criteria.
Several criteria could be specified, but an awkward weighting system
would also be needed.
.SS Parameters
.IP \[bu] 2
WinnerROILabel
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
Area
.IP \[bu] 2
Perimeter
.IP \[bu] 2
CentroidX
.IP \[bu] 2
CentroidY
.IP \[bu] 2
CentroidZ
.IP \[bu] 2
WinnerCount
.SS WinnerROILabel
.SS Description
.PP
The ROI label to attach to the winning contour(s).
All other metadata remains the same.
.SS Default
.IP \[bu] 2
\f[C]"unspecified"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"closest"\f[]
.IP \[bu] 2
\f[C]"best"\f[]
.IP \[bu] 2
\f[C]"winners"\f[]
.IP \[bu] 2
\f[C]"best\-matches"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS Area
.SS Description
.PP
If this option is provided with a valid positive number, the contour(s)
with an area closest to the specified value is/are retained.
Note that the DICOM coordinate space is used.
(Supplying the default, NaN, will disable this option.) Note: if several
criteria are specified, it is not specified in which order they are
considered.
.SS Default
.IP \[bu] 2
\f[C]"nan"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"nan"\f[]
.IP \[bu] 2
\f[C]"100.0"\f[]
.IP \[bu] 2
\f[C]"1000"\f[]
.IP \[bu] 2
\f[C]"10.23E8"\f[]
.SS Perimeter
.SS Description
.PP
If this option is provided with a valid positive number, the contour(s)
with a perimeter closest to the specified value is/are retained.
Note that the DICOM coordinate space is used.
(Supplying the default, NaN, will disable this option.) Note: if several
criteria are specified, it is not specified in which order they are
considered.
.SS Default
.IP \[bu] 2
\f[C]"nan"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"nan"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"123.456"\f[]
.IP \[bu] 2
\f[C]"1E6"\f[]
.SS CentroidX
.SS Description
.PP
If this option is provided with a valid positive number, the contour(s)
with a centroid closest to the specified value is/are retained.
Note that the DICOM coordinate space is used.
(Supplying the default, NaN, will disable this option.) Note: if several
criteria are specified, it is not specified in which order they are
considered.
.SS Default
.IP \[bu] 2
\f[C]"nan"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"nan"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"123.456"\f[]
.IP \[bu] 2
\f[C]"\-1E6"\f[]
.SS CentroidY
.SS Description
.PP
If this option is provided with a valid positive number, the contour(s)
with a centroid closest to the specified value is/are retained.
Note that the DICOM coordinate space is used.
(Supplying the default, NaN, will disable this option.) Note: if several
criteria are specified, it is not specified in which order they are
considered.
.SS Default
.IP \[bu] 2
\f[C]"nan"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"nan"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"123.456"\f[]
.IP \[bu] 2
\f[C]"\-1E6"\f[]
.SS CentroidZ
.SS Description
.PP
If this option is provided with a valid positive number, the contour(s)
with a centroid closest to the specified value is/are retained.
Note that the DICOM coordinate space is used.
(Supplying the default, NaN, will disable this option.) Note: if several
criteria are specified, it is not specified in which order they are
considered.
.SS Default
.IP \[bu] 2
\f[C]"nan"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"nan"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"123.456"\f[]
.IP \[bu] 2
\f[C]"\-1E6"\f[]
.SS WinnerCount
.SS Description
.PP
Retain this number of `best' or `winning' contours.
.SS Default
.IP \[bu] 2
\f[C]"1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.IP \[bu] 2
\f[C]"10000"\f[]
.SS ContourWholeImages
.SS Description
.PP
This operation constructs contours for an ROI that encompasses the whole
of all specified images.
It is useful for operations that operate on ROIs whenever you want to
compute something over the whole image.
This routine avoids having to manually contour anything.
The output is `ephemeral' and is not commited to any database.
.SS Notes
.IP \[bu] 2
This routine will attempt to avoid repeat contours.
Generated contours are tested for intersection with an image before the
image is processed.
.IP \[bu] 2
Existing contours are ignored and unaltered.
.IP \[bu] 2
Contours are set slightly inside the outer boundary so they can be
easily visualized by overlaying on the image.
All voxel centres will be within the bounds.
.SS Parameters
.IP \[bu] 2
ROILabel
.IP \[bu] 2
ImageSelection
.SS ROILabel
.SS Description
.PP
A label to attach to the ROI contours.
.SS Default
.IP \[bu] 2
\f[C]"everything"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"everything"\f[]
.IP \[bu] 2
\f[C]"whole_images"\f[]
.IP \[bu] 2
\f[C]"unspecified"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ContouringAides
.SS Description
.PP
This operation attempts to prepare an image for easier contouring.
.SS Notes
.IP \[bu] 2
At the moment, only logarithmic scaling is applied.
.SS Parameters
.PP
No registered options.
.SS ConvertContoursToMeshes
.SS Description
.PP
This routine creates a mesh directly from contours, finding a
correspondence between adjacent contours and `zippering' them together.
Please note that this operation is not robust and should only be
expected to work for simple, sphere\-like contours (i.e., convex
polyhedra and mostly\-convex polyhedra with only small concavities; see
notes for additional information).
This operation, when it can be used appropriately, should be
significantly faster than meshing via voxelization (e.g., marching
cubes).
It will also insert no additional vertices on the original contour
planes.
.SS Notes
.IP \[bu] 2
This routine is experimental and currently relies on simple heuristics
to find an adjacent contour correspondence.
.IP \[bu] 2
Meshes sliced on the same planes as the original contours
\f[I]should\f[] reproduce the original contours (barring numerical
instabilities).
In between the original slices, the mesh may exhibit distortions or
obviously invalid correspondence with adjacent contours.
.IP \[bu] 2
Mesh `pairing' on adjacent slices is evaluated using a mutual overlap
heuristic.
The following adjacent slice pairing scenarios are supported: 1\-0,
1\-1, N\-0, N\-1, and N\-M (for any N and M greater than 1).
Adjacent contours with inconsistent orientations will either be
reordered or wholly disregarded.
For N\-0, N\-1, and N\-M pairings all contours in N (and M) are fused
using with a simple distance heuristic; the fusion bridges are extended
off the original contour plane so that mesh slicing will recover the
original contours.
For 1\-0 and N\-0 pairings the `hole' is filled by placing a single
vertex offset from the occupied contour plane from the centroid and
connecting all vertices; mesh slicing should also recover the original
contours in this case.
.IP \[bu] 2
Overlapping contours \f[B]on the same plane\f[] are \f[B]not\f[]
currently supported.
Only the contour with the largest area will be retained.
.IP \[bu] 2
This routine should only be expected to work for simple, sphere\-like
geometries (i.e., convex polyhedra).
Some concavities can be tolerated, but not all.
For example, tori can only be meshed if the `hole' is oriented away from
the contour normal.
(Otherwise the `hole' produces concentric contours \[en] which are not
supported.) Contours representing convex polyhedra \f[B]should\f[]
result in manifold meshes, though they may not be watertight and if
contour vertices are degenerate (or too close together numerically)
meshes will fail to remain manifold.
.SS Parameters
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
MeshLabel
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS MeshLabel
.SS Description
.PP
A label to attach to the surface mesh.
.SS Default
.IP \[bu] 2
\f[C]"unspecified"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"unspecified"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"air"\f[]
.IP \[bu] 2
\f[C]"bone"\f[]
.IP \[bu] 2
\f[C]"invalid"\f[]
.IP \[bu] 2
\f[C]"above_zero"\f[]
.IP \[bu] 2
\f[C]"below_5.3"\f[]
.SS ConvertContoursToPoints
.SS Description
.PP
This operation extracts vertices from the selected contours and converts
them into a point cloud.
Contours are not modified.
.SS Notes
.IP \[bu] 2
Existing point clouds are ignored and unaltered.
.SS Parameters
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Label
.IP \[bu] 2
Method
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Label
.SS Description
.PP
A label to attach to the point cloud.
.SS Default
.IP \[bu] 2
\f[C]"unspecified"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"unspecified"\f[]
.IP \[bu] 2
\f[C]"POIs"\f[]
.IP \[bu] 2
\f[C]"peaks"\f[]
.IP \[bu] 2
\f[C]"above_zero"\f[]
.IP \[bu] 2
\f[C]"below_5.3"\f[]
.SS Method
.SS Description
.PP
The conversion method to use.
Two options are available: `vertices' and `centroid'.
The `vertices' option extracts all vertices from all selected contours
and directly inserts them into the new point cloud.
Point clouds created this way will contain as many points as there are
contour vertices.
The `centroid' option finds the centroid of all vertices from all
selected contours.
Note that the centroid gives every point an equal weighting, so
heterogeneous contour vertex density will shift the position of the
centroid (unless the distribution is symmetric about the centroid, which
should roughly be the case for spherical contour collections).
Point clouds created this way will contain a single point.
.SS Default
.IP \[bu] 2
\f[C]"vertices"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"vertices"\f[]
.IP \[bu] 2
\f[C]"centroid"\f[]
.SS ConvertDoseToImage
.SS Description
.PP
This operation converts all loaded images from RTDOSE modality to CT
modality.
Image contents will not change, but the intent to treat as an image or
dose matrix will of course change.
.SS Parameters
.IP \[bu] 2
Modality
.SS Modality
.SS Description
.PP
The modality that will replace `RTDOSE'.
.SS Default
.IP \[bu] 2
\f[C]"CT"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"CT"\f[]
.IP \[bu] 2
\f[C]"MR"\f[]
.IP \[bu] 2
\f[C]"UNKNOWN"\f[]
.SS ConvertImageToDose
.SS Description
.PP
This operation converts all loaded image modalities into RTDOSE.
Image contents will not change, but the intent to treat as an image or
dose matrix will of course change.
.SS Parameters
.PP
No registered options.
.SS ConvertImageToMeshes
.SS Description
.PP
This operation extracts surface meshes from images and pixel/voxel value
thresholds.
Meshes are appended to the back of the Surface_Mesh stack.
There are two methods of contour generation available: a simple binary
method in which voxels are either fully in or fully out of the contour,
and a method based on marching cubes that will provide smoother
contours.
Both methods make use of marching cubes \[en] the binary method involves
pre\-processing.
.SS Notes
.IP \[bu] 2
This routine requires images to be regular (i.e., exactly abut nearest
adjacent images without any overlap).
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
Lower
.IP \[bu] 2
Upper
.IP \[bu] 2
Channel
.IP \[bu] 2
Method
.IP \[bu] 2
MeshLabel
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Lower
.SS Description
.PP
The lower bound (inclusive).
Pixels with values < this number are excluded from the ROI.
If the number is followed by a `%', the bound will be scaled between the
min and max pixel values [0\-100%].
If the number is followed by `tile', the bound will be replaced with the
corresponding percentile [0\-100tile].
Note that upper and lower bounds can be specified separately (e.g.,
lower bound is a percentage, but upper bound is a percentile).
Note that computed bounds (i.e., percentages and percentiles) consider
the entire image volume.
.SS Default
.IP \[bu] 2
\f[C]"\-inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1E\-99"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"0.2%"\f[]
.IP \[bu] 2
\f[C]"23tile"\f[]
.IP \[bu] 2
\f[C]"23.123\ tile"\f[]
.SS Upper
.SS Description
.PP
The upper bound (inclusive).
Pixels with values > this number are excluded from the ROI.
If the number is followed by a `%', the bound will be scaled between the
min and max pixel values [0\-100%].
If the number is followed by `tile', the bound will be replaced with the
corresponding percentile [0\-100tile].
Note that upper and lower bounds can be specified separately (e.g.,
lower bound is a percentage, but upper bound is a percentile).
Note that computed bounds (i.e., percentages and percentiles) consider
the entire image volume.
.SS Default
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"1E\-99"\f[]
.IP \[bu] 2
\f[C]"2.34"\f[]
.IP \[bu] 2
\f[C]"98.12%"\f[]
.IP \[bu] 2
\f[C]"94tile"\f[]
.IP \[bu] 2
\f[C]"94.123\ tile"\f[]
.SS Channel
.SS Description
.PP
The image channel to use.
Zero\-based.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS Method
.SS Description
.PP
There are currently two supported methods for generating contours: (1) a
simple (and fast) binary inclusivity checker, that simply checks if a
voxel is within the ROI by testing the value at the voxel centre, and
(2) a robust (but slow) method based on marching cubes.
The binary method is fast, but produces extremely jagged contours.
It may also have problems with `pinches' and topological consistency.
The marching method is more robust and should reliably produce contours
for even the most complicated topologies, but is considerably slower
than the binary method.
.SS Default
.IP \[bu] 2
\f[C]"marching"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"binary"\f[]
.IP \[bu] 2
\f[C]"marching"\f[]
.SS MeshLabel
.SS Description
.PP
A label to attach to the surface mesh.
.SS Default
.IP \[bu] 2
\f[C]"unspecified"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"unspecified"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"air"\f[]
.IP \[bu] 2
\f[C]"bone"\f[]
.IP \[bu] 2
\f[C]"invalid"\f[]
.IP \[bu] 2
\f[C]"above_zero"\f[]
.IP \[bu] 2
\f[C]"below_5.3"\f[]
.SS ConvertMeshesToContours
.SS Description
.PP
This operation constructs ROI contours by slicing the given meshes on a
set of image planes.
.SS Notes
.IP \[bu] 2
Surface meshes should represent polyhedra.
.IP \[bu] 2
This routine does \f[B]not\f[] require images to be regular,
rectilinear, or even contiguous.
.IP \[bu] 2
Images and meshes are unaltered.
Existing contours are ignored and unaltered.
.IP \[bu] 2
Contour orientation is (likely) not guaranteed to be consistent in this
routine.
.SS Parameters
.IP \[bu] 2
ROILabel
.IP \[bu] 2
MeshSelection
.IP \[bu] 2
ImageSelection
.SS ROILabel
.SS Description
.PP
A label to attach to the ROI contours.
.SS Default
.IP \[bu] 2
\f[C]"unspecified"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"unspecified"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"air"\f[]
.IP \[bu] 2
\f[C]"bone"\f[]
.IP \[bu] 2
\f[C]"invalid"\f[]
.IP \[bu] 2
\f[C]"above_zero"\f[]
.IP \[bu] 2
\f[C]"below_5.3"\f[]
.SS MeshSelection
.SS Description
.PP
Select one or more surface meshes.
Note that a single surface mesh may hold many disconnected mesh
components; they should collectively represent a single logically
cohesive object.
Be aware that it is possible to mix logically unrelated sub\-meshes
together in a single mesh.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth surface
mesh (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last surface mesh.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ConvertNaNsToAir
.SS Description
.PP
This operation runs the data through a per\-pixel filter, converting
NaN's to air in Hounsfield units (\-1024).
.SS Parameters
.PP
No registered options.
.SS ConvertNaNsToZeros
.SS Description
.PP
This operation runs the data through a per\-pixel filter, converting
NaN's to zeros.
.SS Parameters
.PP
No registered options.
.SS ConvertPixelsToPoints
.SS Description
.PP
This operation extracts pixels from the selected images and converts
them into a point cloud.
Images are not modified.
.SS Notes
.IP \[bu] 2
Existing point clouds are ignored and unaltered.
.SS Parameters
.IP \[bu] 2
Label
.IP \[bu] 2
Lower
.IP \[bu] 2
Upper
.IP \[bu] 2
Channel
.IP \[bu] 2
ImageSelection
.SS Label
.SS Description
.PP
A label to attach to the point cloud.
.SS Default
.IP \[bu] 2
\f[C]"unspecified"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"unspecified"\f[]
.IP \[bu] 2
\f[C]"POIs"\f[]
.IP \[bu] 2
\f[C]"peaks"\f[]
.IP \[bu] 2
\f[C]"above_zero"\f[]
.IP \[bu] 2
\f[C]"below_5.3"\f[]
.SS Lower
.SS Description
.PP
The lower bound (inclusive).
Pixels with values < this number are excluded from the ROI.
If the number is followed by a `%', the bound will be scaled between the
min and max pixel values [0\-100%].
If the number is followed by `tile', the bound will be replaced with the
corresponding percentile [0\-100tile].
Note that upper and lower bounds can be specified separately (e.g.,
lower bound is a percentage, but upper bound is a percentile).
.SS Default
.IP \[bu] 2
\f[C]"\-inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1E\-99"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"0.2%"\f[]
.IP \[bu] 2
\f[C]"23tile"\f[]
.IP \[bu] 2
\f[C]"23.123\ tile"\f[]
.SS Upper
.SS Description
.PP
The upper bound (inclusive).
Pixels with values > this number are excluded from the ROI.
If the number is followed by a `%', the bound will be scaled between the
min and max pixel values [0\-100%].
If the number is followed by `tile', the bound will be replaced with the
corresponding percentile [0\-100tile].
Note that upper and lower bounds can be specified separately (e.g.,
lower bound is a percentage, but upper bound is a percentile).
.SS Default
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"1E\-99"\f[]
.IP \[bu] 2
\f[C]"2.34"\f[]
.IP \[bu] 2
\f[C]"98.12%"\f[]
.IP \[bu] 2
\f[C]"94tile"\f[]
.IP \[bu] 2
\f[C]"94.123\ tile"\f[]
.SS Channel
.SS Description
.PP
The image channel to use.
Zero\-based.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ConvolveImages
.SS Description
.PP
This routine convolves, correlates, or pattern\-matches one rectilinear
image array with another in voxel number space (i.e., the DICOM
coordinate system of the convolution kernel image is entirely
disregarded).
.SS Notes
.IP \[bu] 2
Both provided image arrays must be rectilinear.
In many instances they should both be regular, not just rectilinear, but
rectilinearity is sufficient for constructing voxel\-by\-voxel adjacency
relatively quickly, and some applications may require rectilinear
kernels to be supported, so rectilinear inputs are permitted.
.IP \[bu] 2
This operation can be used to apply arbitrary convolution kernels to an
image array.
It can also be used to search for instances of one image array in
another.
.IP \[bu] 2
If the magnitude of the outgoing voxels will be interpretted in absolute
(i.e., thresholding based on an absolute magnitude) then the kernel
should be weighted so that the sum of all kernel voxel intensities is
zero.
This will maintain the average voxel intensity.
However, for pattern matching the kernel need not be normalized (though
it may make interpretting partial matches easier.)
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
ReferenceImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Channel
.IP \[bu] 2
Operation
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ReferenceImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Channel
.SS Description
.PP
The channel to operate on (zero\-based).
Negative values will cause all channels to be operated on.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.SS Operation
.SS Description
.PP
Controls the way the kernel is applied and the reduction is tallied.
Currently, `convolution', `correlation', and `pattern\-match' are
supported.
For convolution, the reference image is spatially inverted along row\-,
column\-, and image\-axes.
The outgoing voxel intensity is the inner (i.e., dot) product of the
paired intensities of the surrounding voxel neighbourhood (i.e., the
voxel at (\-1,3,0) from the centre of the kernel is paired with the
neighbouring voxel at (\-1,3,0) from the current/outgoing voxel).
For pattern\-matching, the difference between the kernel and each
voxel's neighbourhood voxels is compared using a 2\-norm (i.e.,
Euclidean) cost function.
With this cost function, a perfect, pixel\-for\-pixel match (i.e., if
the kernel images appears exactly in the image being transformed) will
result in the outgoing voxel having zero intensity (i.e., zero cost).
For correlation, the kernel is applied as\-is (just like
pattern\-matching), but the inner product of the paired voxel
neighbourhood intensities is reported (just like convolution).
In all cases the kernel is (approximately) centred.
.SS Default
.IP \[bu] 2
\f[C]"convolution"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"convolution"\f[]
.IP \[bu] 2
\f[C]"correlation"\f[]
.IP \[bu] 2
\f[C]"pattern\-match"\f[]
.SS CopyImages
.SS Description
.PP
This operation deep\-copies the selected image arrays.
.SS Parameters
.IP \[bu] 2
ImageSelection
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS CopyMeshes
.SS Description
.PP
This operation deep\-copies the selected surface meshes.
.SS Parameters
.IP \[bu] 2
MeshSelection
.SS MeshSelection
.SS Description
.PP
Select one or more surface meshes.
Note that a single surface mesh may hold many disconnected mesh
components; they should collectively represent a single logically
cohesive object.
Be aware that it is possible to mix logically unrelated sub\-meshes
together in a single mesh.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth surface
mesh (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last surface mesh.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS CopyPoints
.SS Description
.PP
This operation deep\-copies the selected point clouds.
.SS Parameters
.IP \[bu] 2
PointSelection
.SS PointSelection
.SS Description
.PP
Select one or more point clouds.
Note that point clouds can hold a variety of data with varying
attributes, but each point cloud is meant to represent a single
logically cohesive collection of points.
Be aware that it is possible to mix logically unrelated points together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth point
cloud (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last point cloud.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS CountVoxels
.SS Description
.PP
This operation counts the number of voxels confined to one or more ROIs
within a user\-provided range.
.SS Notes
.IP \[bu] 2
This operation is read\-only.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Inclusivity
.IP \[bu] 2
ContourOverlap
.IP \[bu] 2
Lower
.IP \[bu] 2
Upper
.IP \[bu] 2
Channel
.IP \[bu] 2
ResultsSummaryFileName
.IP \[bu] 2
UserComment
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Inclusivity
.SS Description
.PP
Controls how voxels are deemed to be `within' the interior of the
selected ROI(s).
The default `center' considers only the central\-most point of each
voxel.
There are two corner options that correspond to a 2D projection of the
voxel onto the image plane.
The first, `planar_corner_inclusive', considers a voxel interior if ANY
corner is interior.
The second, `planar_corner_exclusive', considers a voxel interior if ALL
(four) corners are interior.
.SS Default
.IP \[bu] 2
\f[C]"center"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"center"\f[]
.IP \[bu] 2
\f[C]"centre"\f[]
.IP \[bu] 2
\f[C]"planar_corner_inclusive"\f[]
.IP \[bu] 2
\f[C]"planar_inc"\f[]
.IP \[bu] 2
\f[C]"planar_corner_exclusive"\f[]
.IP \[bu] 2
\f[C]"planar_exc"\f[]
.SS ContourOverlap
.SS Description
.PP
Controls overlapping contours are treated.
The default `ignore' treats overlapping contours as a single contour,
regardless of contour orientation.
The option `honour_opposite_orientations' makes overlapping contours
with opposite orientation cancel.
Otherwise, orientation is ignored.
The latter is useful for Boolean structures where contour orientation is
significant for interior contours (holes).
The option `overlapping_contours_cancel' ignores orientation and cancels
all contour overlap.
.SS Default
.IP \[bu] 2
\f[C]"ignore"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"ignore"\f[]
.IP \[bu] 2
\f[C]"honour_opposite_orientations"\f[]
.IP \[bu] 2
\f[C]"overlapping_contours_cancel"\f[]
.IP \[bu] 2
\f[C]"honour_opps"\f[]
.IP \[bu] 2
\f[C]"overlap_cancel"\f[]
.SS Lower
.SS Description
.PP
The lower bound (inclusive).
Pixels with values < this number are excluded from the ROI.
If the number is followed by a `%', the bound will be scaled between the
min and max pixel values [0\-100%].
If the number is followed by `tile', the bound will be replaced with the
corresponding percentile [0\-100tile].
Note that upper and lower bounds can be specified separately (e.g.,
lower bound is a percentage, but upper bound is a percentile).
.SS Default
.IP \[bu] 2
\f[C]"\-inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1E\-99"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"0.2%"\f[]
.IP \[bu] 2
\f[C]"23tile"\f[]
.IP \[bu] 2
\f[C]"23.123\ tile"\f[]
.SS Upper
.SS Description
.PP
The upper bound (inclusive).
Pixels with values > this number are excluded from the ROI.
If the number is followed by a `%', the bound will be scaled between the
min and max pixel values [0\-100%].
If the number is followed by `tile', the bound will be replaced with the
corresponding percentile [0\-100tile].
Note that upper and lower bounds can be specified separately (e.g.,
lower bound is a percentage, but upper bound is a percentile).
.SS Default
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"1E\-99"\f[]
.IP \[bu] 2
\f[C]"2.34"\f[]
.IP \[bu] 2
\f[C]"98.12%"\f[]
.IP \[bu] 2
\f[C]"94tile"\f[]
.IP \[bu] 2
\f[C]"94.123\ tile"\f[]
.SS Channel
.SS Description
.PP
The image channel to use.
Zero\-based.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS ResultsSummaryFileName
.SS Description
.PP
This file will contain a brief summary of the results.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
If an existing file is present, rows will be appended without writing a
header.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.SS CropImageDoseToROIs
.SS Description
.PP
This operation crops image slices to the specified ROI(s), with an
additional margin.
.SS Parameters
.IP \[bu] 2
DICOMMargin
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.SS DICOMMargin
.SS Description
.PP
The amount of margin (in the DICOM coordinate system) to surround the
ROI(s).
.SS Default
.IP \[bu] 2
\f[C]"0.5"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"\-0.5"\f[]
.IP \[bu] 2
\f[C]"20.0"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS CropImages
.SS Description
.PP
This operation crops image slices in either pixel or DICOM coordinate
spaces.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
RowsL
.IP \[bu] 2
RowsH
.IP \[bu] 2
ColumnsL
.IP \[bu] 2
ColumnsH
.IP \[bu] 2
DICOMMargin
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS RowsL
.SS Description
.PP
The number of rows to remove, starting with the first row.
Can be absolute (px), percentage (%), or distance in terms of the DICOM
coordinate system.
Note the DICOM coordinate system can be flipped, so the first row can be
either on the top or bottom of the image.
.SS Default
.IP \[bu] 2
\f[C]"0px"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0px"\f[]
.IP \[bu] 2
\f[C]"10px"\f[]
.IP \[bu] 2
\f[C]"100px"\f[]
.IP \[bu] 2
\f[C]"15%"\f[]
.IP \[bu] 2
\f[C]"15.75%"\f[]
.IP \[bu] 2
\f[C]"123.45"\f[]
.SS RowsH
.SS Description
.PP
The number of rows to remove, starting with the last row.
Can be absolute (px), percentage (%), or distance in terms of the DICOM
coordinate system.
Note the DICOM coordinate system can be flipped, so the first row can be
either on the top or bottom of the image.
.SS Default
.IP \[bu] 2
\f[C]"0px"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0px"\f[]
.IP \[bu] 2
\f[C]"10px"\f[]
.IP \[bu] 2
\f[C]"100px"\f[]
.IP \[bu] 2
\f[C]"15%"\f[]
.IP \[bu] 2
\f[C]"15.75%"\f[]
.IP \[bu] 2
\f[C]"123.45"\f[]
.SS ColumnsL
.SS Description
.PP
The number of columns to remove, starting with the first column.
Can be absolute (px), percentage (%), or distance in terms of the DICOM
coordinate system.
Note the DICOM coordinate system can be flipped, so the first column can
be either on the top or bottom of the image.
.SS Default
.IP \[bu] 2
\f[C]"0px"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0px"\f[]
.IP \[bu] 2
\f[C]"10px"\f[]
.IP \[bu] 2
\f[C]"100px"\f[]
.IP \[bu] 2
\f[C]"15%"\f[]
.IP \[bu] 2
\f[C]"15.75%"\f[]
.IP \[bu] 2
\f[C]"123.45"\f[]
.SS ColumnsH
.SS Description
.PP
The number of columns to remove, starting with the last column.
Can be absolute (px), percentage (%), or distance in terms of the DICOM
coordinate system.
Note the DICOM coordinate system can be flipped, so the first column can
be either on the top or bottom of the image.
.SS Default
.IP \[bu] 2
\f[C]"0px"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0px"\f[]
.IP \[bu] 2
\f[C]"10px"\f[]
.IP \[bu] 2
\f[C]"100px"\f[]
.IP \[bu] 2
\f[C]"15%"\f[]
.IP \[bu] 2
\f[C]"15.75%"\f[]
.IP \[bu] 2
\f[C]"123.45"\f[]
.SS DICOMMargin
.SS Description
.PP
The amount of margin (in the DICOM coordinate system) to spare from
cropping.
.SS Default
.IP \[bu] 2
\f[C]"0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"\-0.5"\f[]
.IP \[bu] 2
\f[C]"20.0"\f[]
.SS CropROIDose
.SS Description
.PP
This operation provides a simplified interface for overriding voxel
values outside a ROI.
For example, this operation can be used to modify a base plan by
eliminating dose outside an OAR.
.SS Notes
.IP \[bu] 2
This operation performs the opposite of the `Trim' operation, which
trims voxel values \f[B]inside\f[] a ROI.
.IP \[bu] 2
The inclusivity of a voxel that straddles the ROI boundary can be
specified in various ways.
Refer to the Inclusivity parameter documentation.
.SS Parameters
.IP \[bu] 2
Channel
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
ContourOverlap
.IP \[bu] 2
Inclusivity
.IP \[bu] 2
ExteriorVal
.IP \[bu] 2
InteriorVal
.IP \[bu] 2
ExteriorOverwrite
.IP \[bu] 2
InteriorOverwrite
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
Filename
.IP \[bu] 2
ParanoiaLevel
.SS Channel
.SS Description
.PP
The image channel to use.
Zero\-based.
Use `\-1' to operate on all available channels.
.SS Default
.IP \[bu] 2
\f[C]"\-1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ContourOverlap
.SS Description
.PP
Controls overlapping contours are treated.
The default `ignore' treats overlapping contours as a single contour,
regardless of contour orientation.
The option `honour_opposite_orientations' makes overlapping contours
with opposite orientation cancel.
Otherwise, orientation is ignored.
The latter is useful for Boolean structures where contour orientation is
significant for interior contours (holes).
The option `overlapping_contours_cancel' ignores orientation and cancels
all contour overlap.
.SS Default
.IP \[bu] 2
\f[C]"ignore"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"ignore"\f[]
.IP \[bu] 2
\f[C]"honour_opposite_orientations"\f[]
.IP \[bu] 2
\f[C]"overlapping_contours_cancel"\f[]
.IP \[bu] 2
\f[C]"honour_opps"\f[]
.IP \[bu] 2
\f[C]"overlap_cancel"\f[]
.SS Inclusivity
.SS Description
.PP
Controls how voxels are deemed to be `within' the interior of the
selected ROI(s).
The default `center' considers only the central\-most point of each
voxel.
There are two corner options that correspond to a 2D projection of the
voxel onto the image plane.
The first, `planar_corner_inclusive', considers a voxel interior if ANY
corner is interior.
The second, `planar_corner_exclusive', considers a voxel interior if ALL
(four) corners are interior.
.SS Default
.IP \[bu] 2
\f[C]"planar_inc"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"center"\f[]
.IP \[bu] 2
\f[C]"centre"\f[]
.IP \[bu] 2
\f[C]"planar_corner_inclusive"\f[]
.IP \[bu] 2
\f[C]"planar_inc"\f[]
.IP \[bu] 2
\f[C]"planar_corner_exclusive"\f[]
.IP \[bu] 2
\f[C]"planar_exc"\f[]
.SS ExteriorVal
.SS Description
.PP
The value to give to voxels outside the specified ROI(s).
Note that this value will be ignored if exterior overwrites are
disabled.
.SS Default
.IP \[bu] 2
\f[C]"0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1.0"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"2.34E26"\f[]
.SS InteriorVal
.SS Description
.PP
The value to give to voxels within the volume of the specified ROI(s).
Note that this value will be ignored if interior overwrites are
disabled.
.SS Default
.IP \[bu] 2
\f[C]"0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1.0"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"2.34E26"\f[]
.SS ExteriorOverwrite
.SS Description
.PP
Whether to overwrite voxels exterior to the specified ROI(s).
.SS Default
.IP \[bu] 2
\f[C]"true"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS InteriorOverwrite
.SS Description
.PP
Whether to overwrite voxels interior to the specified ROI(s).
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Filename
.SS Description
.PP
The filename (or full path name) to which the DICOM file should be
written.
.SS Default
.IP \[bu] 2
\f[C]"/tmp/RD.dcm"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"/tmp/RD.dcm"\f[]
.IP \[bu] 2
\f[C]"./RD.dcm"\f[]
.IP \[bu] 2
\f[C]"RD.dcm"\f[]
.SS ParanoiaLevel
.SS Description
.PP
At low paranoia setting, only top\-level UIDs are replaced.
At medium paranoia setting, many UIDs, descriptions, and labels are
replaced, but the PatientID and FrameOfReferenceUID are retained.
The high paranoia setting is the same as the medium setting, but the
PatientID and FrameOfReferenceUID are also replaced.
(Note: this is not a full anonymization.) Use the low setting if you
want to retain linkage to the originating data set.
Use the medium setting if you don't.
Use the high setting if your TPS goes overboard linking data sets by
PatientID and/or FrameOfReferenceUID.
.SS Default
.IP \[bu] 2
\f[C]"medium"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"low"\f[]
.IP \[bu] 2
\f[C]"medium"\f[]
.IP \[bu] 2
\f[C]"high"\f[]
.SS DCEMRI_IAUC
.SS Description
.PP
This operation will compute the Integrated Area Under the Curve (IAUC)
for any images present.
.SS Notes
.IP \[bu] 2
This operation is not optimized in any way and operates on whole images.
It can be fairly slow, especially if the image volume is huge, so it is
best to crop images if possible.
.SS Parameters
.PP
No registered options.
.SS DCEMRI_Nonparametric_CE
.SS Description
.PP
This operation takes a single DCE\-MRI scan (`measurement') and
generates a \[lq]poor\-mans's\[rq] contrast enhancement signal.
This is accomplished by subtracting the pre\-contrast injection images
average (`baseline') from later images (and then possibly/optionally
averaging relative to the baseline).
.SS Notes
.IP \[bu] 2
Only a single image volume is required.
It is expected to have temporal sampling beyond the contrast injection
timepoint (or some default value \[en] currently around ~30s).
The resulting images retain the baseline portion, so you'll need to trim
yourself if needed.
.IP \[bu] 2
Be aware that this method of deriving contrast enhancement is not valid!
It ignores nuances due to differing T1 or T2 values due to the presence
of contrast agent.
It should only be used for exploratory purposes or cases where the
distinction with reality is irrelevant.
.SS Parameters
.PP
No registered options.
.SS DICOMExportContours
.SS Description
.PP
This operation exports the selected contours to a DICOM
RTSTRUCT\-modality file.
.SS Notes
.IP \[bu] 2
There are various `paranoia' levels that can be used to partially
anonymize the output.
In particular, most metadata and UIDs are replaced, but the files may
still be recognized by a determined individual by comparing the contour
data.
Do NOT rely on this routine to fully anonymize the data!
.SS Parameters
.IP \[bu] 2
Filename
.IP \[bu] 2
ParanoiaLevel
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.SS Filename
.SS Description
.PP
The filename (or full path name) to which the DICOM file should be
written.
.SS Default
.IP \[bu] 2
\f[C]"/tmp/RTSTRUCT.dcm"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"/tmp/RTSTRUCT.dcm"\f[]
.IP \[bu] 2
\f[C]"./RTSTRUCT.dcm"\f[]
.IP \[bu] 2
\f[C]"RTSTRUCT.dcm"\f[]
.SS ParanoiaLevel
.SS Description
.PP
At low paranoia setting, only top\-level UIDs are replaced.
At medium paranoia setting, many UIDs, descriptions, and labels are
replaced, but the PatientID and FrameOfReferenceUID are retained.
The high paranoia setting is the same as the medium setting, but the
PatientID and FrameOfReferenceUID are also replaced.
(Note: this is not a full anonymization.) Use the low setting if you
want to retain linkage to the originating data set.
Use the medium setting if you don't.
Use the high setting if your TPS goes overboard linking data sets by
PatientID and/or FrameOfReferenceUID.
.SS Default
.IP \[bu] 2
\f[C]"medium"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"low"\f[]
.IP \[bu] 2
\f[C]"medium"\f[]
.IP \[bu] 2
\f[C]"high"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS DICOMExportImagesAsCT
.SS Description
.PP
This operation exports the selected Image_Array(s) to DICOM CT\-modality
files.
.SS Notes
.IP \[bu] 2
There are various `paranoia' levels that can be used to partially
anonymize the output.
In particular, most metadata and UIDs are replaced, but the files may
still be recognized by a determined individual by comparing the
coordinate system and pixel values.
Do NOT rely on this routine to fully anonymize the data!
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
Filename
.IP \[bu] 2
ParanoiaLevel
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Filename
.SS Description
.PP
The filename (or full path name) to which the DICOM files should be
written.
The file format is a gzipped\-TAR file containing multiple CT\-modality
files.
.SS Default
.IP \[bu] 2
\f[C]"CTs.tgz"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"/tmp/CTs.tgz"\f[]
.IP \[bu] 2
\f[C]"./CTs.tar.gz"\f[]
.IP \[bu] 2
\f[C]"CTs.tgz"\f[]
.SS ParanoiaLevel
.SS Description
.PP
At low paranoia setting, only top\-level UIDs are replaced.
At medium paranoia setting, many UIDs, descriptions, and labels are
replaced, but the PatientID and FrameOfReferenceUID are retained.
The high paranoia setting is the same as the medium setting, but the
PatientID and FrameOfReferenceUID are also replaced.
(Note: this is not a full anonymization.) Use the low setting if you
want to retain linkage to the originating data set.
Use the medium setting if you don't.
Use the high setting if your TPS goes overboard linking data sets by
PatientID and/or FrameOfReferenceUID.
.SS Default
.IP \[bu] 2
\f[C]"medium"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"low"\f[]
.IP \[bu] 2
\f[C]"medium"\f[]
.IP \[bu] 2
\f[C]"high"\f[]
.SS DICOMExportImagesAsDose
.SS Description
.PP
This operation exports the selected Image_Array to a DICOM dose file.
.SS Notes
.IP \[bu] 2
There are various `paranoia' levels that can be used to partially
anonymize the output.
In particular, most metadata and UIDs are replaced, but the files may
still be recognized by a determined individual by comparing the
coordinate system and pixel values.
Do NOT rely on this routine to fully anonymize the data!
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
Filename
.IP \[bu] 2
ParanoiaLevel
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Filename
.SS Description
.PP
The filename (or full path name) to which the DICOM file should be
written.
.SS Default
.IP \[bu] 2
\f[C]"/tmp/RD.dcm"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"/tmp/RD.dcm"\f[]
.IP \[bu] 2
\f[C]"./RD.dcm"\f[]
.IP \[bu] 2
\f[C]"RD.dcm"\f[]
.SS ParanoiaLevel
.SS Description
.PP
At low paranoia setting, only top\-level UIDs are replaced.
At medium paranoia setting, many UIDs, descriptions, and labels are
replaced, but the PatientID and FrameOfReferenceUID are retained.
The high paranoia setting is the same as the medium setting, but the
PatientID and FrameOfReferenceUID are also replaced.
(Note: this is not a full anonymization.) Use the low setting if you
want to retain linkage to the originating data set.
Use the medium setting if you don't.
Use the high setting if your TPS goes overboard linking data sets by
PatientID and/or FrameOfReferenceUID.
.SS Default
.IP \[bu] 2
\f[C]"medium"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"low"\f[]
.IP \[bu] 2
\f[C]"medium"\f[]
.IP \[bu] 2
\f[C]"high"\f[]
.SS DeDuplicateImages
.SS Description
.PP
This operation de\-duplicates image arrays, identifying sets of
duplicates based on user\-specified criteria and purging all but one of
the duplicates.
.SS Notes
.IP \[bu] 2
This routine is experimental.
.SS Parameters
.IP \[bu] 2
ImageSelection
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS DecayDoseOverTimeHalve
.SS Description
.PP
This operation transforms a dose map (assumed to be delivered some
distant time in the past) to simulate `decay' or `evaporation' or
`forgivance' of radiation dose by simply halving the value.
This model is only appropriate at long time\-scales, but there is no
cut\-off or threshold to denote what is sufficiently `long'.
So use at your own risk.
As a rule of thumb, do not use this routine if fewer than 2\-3y have
elapsed.
.SS Notes
.IP \[bu] 2
This routine will combine spatially\-overlapping images by summing voxel
intensities.
So if you have a time course it may be more sensible to aggregate images
in some way (e.g., spatial averaging) prior to calling this routine.
.IP \[bu] 2
Since this routine is meant to be applied multiple times in succession
for different ROIs (which possibly overlap), all images are imbued with
a second channel that is treated as a mask.
Mask channels are permanently attached so that multiple passes will not
erroneously decay dose.
If this will be problematic, the extra column should be trimmed
immediately after calling this routine.
.SS Parameters
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS DecayDoseOverTimeJones2014
.SS Description
.PP
This operation transforms a dose map (delivered some time in the past)
to account for tissue recovery (i.e., `dose decay,' `dose evaporation,'
or `dose forgivance') using the time\-dependent model of Jones and Grant
(2014; doi:10.1016/j.clon.2014.04.027).
This model is specific to reirradiation of central nervous tissues.
See the Jones and Grant paper or `Nasopharyngeal Carcinoma' by Wai Tong
Ng et al.
(2016; doi:10.1007/174_2016_48) for more information.
.SS Notes
.IP \[bu] 2
This routine will combine spatially\-overlapping images by summing voxel
intensities.
So if you have a time course it may be more sensible to aggregate images
in some way (e.g., spatial averaging) prior to calling this routine.
.IP \[bu] 2
Since this routine is meant to be applied multiple times in succession
for different ROIs (which possibly overlap), all images are imbued with
a second channel that is treated as a mask.
Mask channels are permanently attached so that multiple passes will not
erroneously decay dose.
If this will be problematic, the extra column should be trimmed
immediately after calling this routine.
.SS Parameters
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Course1NumberOfFractions
.IP \[bu] 2
ToleranceTotalDose
.IP \[bu] 2
ToleranceNumberOfFractions
.IP \[bu] 2
TimeGap
.IP \[bu] 2
AlphaBetaRatio
.IP \[bu] 2
UseMoreConservativeRecovery
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Course1NumberOfFractions
.SS Description
.PP
The number of fractions delivered for the first (i.e., previous) course.
If several apply, you can provide a single effective fractionation
scheme's `n'.
.SS Default
.IP \[bu] 2
\f[C]"35"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"15"\f[]
.IP \[bu] 2
\f[C]"25"\f[]
.IP \[bu] 2
\f[C]"30.001"\f[]
.IP \[bu] 2
\f[C]"35.3"\f[]
.SS ToleranceTotalDose
.SS Description
.PP
The dose delivered (in Gray) for a hypothetical `lifetime dose
tolerance' course.
This dose corresponds to a hypothetical radiation course that nominally
corresponds to the toxicity of interest.
For CNS tissues, it will probably be myelopathy or necrosis at some
population\-level onset risk (e.g., 5% risk of myelopathy).
The value provided will be converted to a BED_{a/b} so you can safely
provide a `nominal' value.
Be aware that each voxel is treated independently, rather than treating
OARs/ROIs as a whole.
(Many dose limits reported in the literature use whole\-ROI D_mean or
D_max, and so may be not be directly applicable to per\-voxel risk
estimation!) Note that the QUANTEC 2010 reports almost all assume 2
Gy/fraction.
If several fractionation schemes were used, you should provide a
cumulative BED\-derived dose here.
.SS Default
.IP \[bu] 2
\f[C]"52"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"15"\f[]
.IP \[bu] 2
\f[C]"20"\f[]
.IP \[bu] 2
\f[C]"25"\f[]
.IP \[bu] 2
\f[C]"50"\f[]
.IP \[bu] 2
\f[C]"83.2"\f[]
.SS ToleranceNumberOfFractions
.SS Description
.PP
The number of fractions (`n') for the `lifetime dose tolerance' toxicity
you are interested in.
Note that this is converted to a BED_{a/b} so you can safely provide a
`nominal' value.
If several apply, you can provide a single effective fractionation
scheme's `n'.
.SS Default
.IP \[bu] 2
\f[C]"35"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"15"\f[]
.IP \[bu] 2
\f[C]"25"\f[]
.IP \[bu] 2
\f[C]"30.001"\f[]
.IP \[bu] 2
\f[C]"35.3"\f[]
.SS TimeGap
.SS Description
.PP
The number of years between radiotherapy courses.
Note that this is normally estimated by (1) extracting study/series
dates from the provided dose files and (2) using the current date as the
second course date.
Use this parameter to override the autodetected gap time.
Note: if the provided value is negative, autodetection will be used.
Autodetection can fail if the data has been anonymized with
date\-shifting.
.SS Default
.IP \[bu] 2
\f[C]"\-1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.91"\f[]
.IP \[bu] 2
\f[C]"2.6"\f[]
.IP \[bu] 2
\f[C]"5"\f[]
.SS AlphaBetaRatio
.SS Description
.PP
The ratio alpha/beta (in Gray) to use when converting to a
biologically\-equivalent dose distribution for central nervous tissues.
Jones and Grant (2014) recommend alpha/beta = 2 Gy to be conservative.
It is more commonplace to use alpha/beta = 3 Gy, but this is less
conservative and there is some evidence that it may be erroneous to use
3 Gy.
.SS Default
.IP \[bu] 2
\f[C]"2"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"2.5"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.SS UseMoreConservativeRecovery
.SS Description
.PP
Jones and Grant (2014) provide two ways to estimate the function `r'.
One is fitted to experimental data, and one is a more conservative
estimate of the fitted function.
This parameter controls whether or not the more conservative function is
used.
.SS Default
.IP \[bu] 2
\f[C]"true"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS DecimatePixels
.SS Description
.PP
This operation spatially aggregates blocks of pixels, thereby decimating
them and making the images consume far less memory.
The precise size reduction and spatial aggregate can be set in the
source.
.SS Parameters
.IP \[bu] 2
OutSizeR
.IP \[bu] 2
OutSizeC
.SS OutSizeR
.SS Description
.PP
The number of pixels along the row unit vector to group into an outgoing
pixel.
Must be a multiplicative factor of the incoming image's row count.
No decimation occurs if either this or `OutSizeC' is zero or negative.
.SS Default
.IP \[bu] 2
\f[C]"8"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"4"\f[]
.IP \[bu] 2
\f[C]"8"\f[]
.IP \[bu] 2
\f[C]"16"\f[]
.IP \[bu] 2
\f[C]"32"\f[]
.IP \[bu] 2
\f[C]"64"\f[]
.IP \[bu] 2
\f[C]"128"\f[]
.IP \[bu] 2
\f[C]"256"\f[]
.IP \[bu] 2
\f[C]"512"\f[]
.SS OutSizeC
.SS Description
.PP
The number of pixels along the column unit vector to group into an
outgoing pixel.
Must be a multiplicative factor of the incoming image's column count.
No decimation occurs if either this or `OutSizeR' is zero or negative.
.SS Default
.IP \[bu] 2
\f[C]"8"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"4"\f[]
.IP \[bu] 2
\f[C]"8"\f[]
.IP \[bu] 2
\f[C]"16"\f[]
.IP \[bu] 2
\f[C]"32"\f[]
.IP \[bu] 2
\f[C]"64"\f[]
.IP \[bu] 2
\f[C]"128"\f[]
.IP \[bu] 2
\f[C]"256"\f[]
.IP \[bu] 2
\f[C]"512"\f[]
.SS DeleteImages
.SS Description
.PP
This routine deletes images from memory.
It is most useful when working with positional operations in stages.
.SS Parameters
.IP \[bu] 2
ImageSelection
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS DeleteMeshes
.SS Description
.PP
This routine deletes surface meshes from memory.
It is most useful when working with positional operations in stages.
.SS Parameters
.IP \[bu] 2
MeshSelection
.SS MeshSelection
.SS Description
.PP
Select one or more surface meshes.
Note that a single surface mesh may hold many disconnected mesh
components; they should collectively represent a single logically
cohesive object.
Be aware that it is possible to mix logically unrelated sub\-meshes
together in a single mesh.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth surface
mesh (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last surface mesh.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS DeletePoints
.SS Description
.PP
This routine deletes point clouds from memory.
It is most useful when working with positional operations in stages.
.SS Parameters
.IP \[bu] 2
PointSelection
.SS PointSelection
.SS Description
.PP
Select one or more point clouds.
Note that point clouds can hold a variety of data with varying
attributes, but each point cloud is meant to represent a single
logically cohesive collection of points.
Be aware that it is possible to mix logically unrelated points together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth point
cloud (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last point cloud.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS DetectGrid3D
.SS Description
.PP
This routine fits a 3D grid to a point cloud using a Procrustes analysis
with point\-to\-model correspondence estimated via an iterative closest
point approach.
A RANSAC\-powered loop is used to (1) randomly select a subset of the
grid for coarse iterative closest point grid fitting, and then (2) use
the coarse fit results as a guess for the whole point cloud in a
refinement stage.
.SS Notes
.IP \[bu] 2
Traditional Procrustes analysis requires a priori point\-to\-point
correspondence knowledge.
Because this operation fits a model (with infinite extent),
point\-to\-point correspondence is not known and the model is
effectively an infinite continuum of potential points.
To overcome this problem, correspondence is estimated by projecting each
point in the point cloud onto every grid line and selecting the closest
projected point.
The point cloud point and the project point are then treated as
corresponding points.
Using this phony correspondence, the Procrustes problem is solved and
the grid is reoriented.
This is performed iteratively.
However \f[B]there is no guarantee the procedure will converge\f[] and
furthermore, even if it does converge, \f[B]there is no guarantee that
the grid will be appropriately fit\f[].
The best results will occur when the grid is already closely aligned
with the point cloud (i.e., when the first guess is very close to a
solution).
If this cannot be guaranteed, it may be advantageous to have a nearly
continuous point cloud to avoid gaps in which the iteration can get
stuck in a local minimum.
For this reason, RANSAC is applied to continuously reboot the fitting
procedure.
All but the best fit are discarded.
.IP \[bu] 2
A two\-stage RANSAC inner\-loop iterative closest point fitting
procedure is used.
Coarse grid fitting is first performed with a limited subset of the
whole point cloud.
This is followed with a refinment stage in which the enire point cloud
is fitted using an initial guess carried forward from the coarse fitting
stage.
This guess is expected to be reasonably close to the true grid in cases
where the coarse fitting procedure was not tainted by outliers, but is
only derived from a small portion of the point cloud.
(Thus RANSAC is used to perform this coarse\-fine iterative procedure
multiple times to provide resilience to poor\-quality coarse fits.)
CoarseICPMaxLoops is the maximum number of iterative\-closest point loop
iterations performed during the coarse grid fitting stage (on a subset
of the point cloud), and FineICPMaxLoops is the maximum number of
iterative\-closest point loop iterations performed during the refinement
stage (using the whole point cloud).
Note that, depending on the noise level and number of points considered
(i.e., whether the RANSACDist parameter is sufficiently small to avoid
spatial wrapping of corresponding points into adjacent grid cells, but
sufficiently large to enclose at least one whole grid cell), the coarse
phase should converge within a few iterations.
However, on each loop a single point is selected as the grid's rotation
centre.
This means that a few extra iterations should always be used in case
outliers are selected as rotation centres.
Additionally, if the point cloud is dense or there are lots of outliers
present, increase CoarseICPMaxLoops to ensure there is a reasonable
chance of selecting legitimate rotation points.
On the other hand, be aware that the coarse\-fine iterative procedure is
performed afresh for every RANSAC loop, and RANSAC loops are better able
to ensure the point cloud is sampled ergodically.
It might therefore be more productive to increase the RANSACMaxLoops
parameter and reduce the number of CoarseICPMaxLoops.
FineICPMaxLoops should converge quickly if the coarse fitting stage was
representative of the true grid.
However, as in the coarse stage a rotation centre is nominated in each
loop, so it will be a good idea to keep a sufficient number of loops to
ensure a legitimate and appropriate non\-outlier point is nominated
during this stage.
Given the complicated interplay between parameters and stages, it is
always best to tune using a representative sample of the point cloud you
need to fit!
.SS Parameters
.IP \[bu] 2
PointSelection
.IP \[bu] 2
GridSeparation
.IP \[bu] 2
RANSACDist
.IP \[bu] 2
GridSampling
.IP \[bu] 2
LineThickness
.IP \[bu] 2
RandomSeed
.IP \[bu] 2
RANSACMaxLoops
.IP \[bu] 2
CoarseICPMaxLoops
.IP \[bu] 2
FineICPMaxLoops
.IP \[bu] 2
ResultsSummaryFileName
.IP \[bu] 2
UserComment
.SS PointSelection
.SS Description
.PP
Select one or more point clouds.
Note that point clouds can hold a variety of data with varying
attributes, but each point cloud is meant to represent a single
logically cohesive collection of points.
Be aware that it is possible to mix logically unrelated points together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth point
cloud (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last point cloud.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS GridSeparation
.SS Description
.PP
The separation of the grid (in DICOM units; mm) being fit.
This parameter describes how close adjacent grid lines are to one
another.
Separation is measured from one grid line centre to the nearest adjacent
grid line centre.
.SS Default
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10.0"\f[]
.IP \[bu] 2
\f[C]"15.5"\f[]
.IP \[bu] 2
\f[C]"25.0"\f[]
.IP \[bu] 2
\f[C]"1.23E4"\f[]
.SS RANSACDist
.SS Description
.PP
Every iteration of RANSAC selects a single point from the point cloud.
Only the near\-vicinity of points are retained for
iterative\-closest\-point Procrustes solving.
This parameter determines the maximum radial distance from the RANSAC
point within which point cloud points will be retained; all points
further than this distance away will be pruned for a given round of
RANSAC.
This is needed because corresponding points begin to alias to incorrect
cell faces when the ICP procedure begins with a poor guess.
Pruning points in a spherical neighbourhood with a diameter 2\-4x the
GridSeparation (so a radius 1\-2x GridSeparation) will help mitigate
aliasing even when the initial guess is poor.
However, smaller windows may increase susceptibility to noise/outliers,
and RANSACDist should never be smaller than a grid voxel.
If RANSACDist is not provided, a default of (1.5 * GridSeparation) is
used.
.SS Default
.IP \[bu] 2
\f[C]"nan"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"7.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.IP \[bu] 2
\f[C]"2.46E4"\f[]
.SS GridSampling
.SS Description
.PP
Specifies how the grid data has been sampled.
Use value `1' if only grid cell corners (i.e., `0D' grid intersections)
are sampled.
Use value `2' if grid cell edges (i.e., 1D grid lines) are sampled.
Use value `3' if grid cell faces (i.e., 2D planar faces) are sampled.
.SS Default
.IP \[bu] 2
\f[C]"1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.SS LineThickness
.SS Description
.PP
The thickness of grid lines (in DICOM units; mm).
If zero, lines are treated simply as lines.
If non\-zero, grid lines are treated as hollow cylinders with a diameter
of this thickness.
.SS Default
.IP \[bu] 2
\f[C]"0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"1.5"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.IP \[bu] 2
\f[C]"1.23E4"\f[]
.SS RandomSeed
.SS Description
.PP
A whole number seed value to use for random number generation.
.SS Default
.IP \[bu] 2
\f[C]"1317"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"1113523431"\f[]
.SS RANSACMaxLoops
.SS Description
.PP
The maximum number of iterations of RANSAC.
(See operation notes for further details.)
.SS Default
.IP \[bu] 2
\f[C]"100"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"100"\f[]
.IP \[bu] 2
\f[C]"2000"\f[]
.IP \[bu] 2
\f[C]"1E4"\f[]
.SS CoarseICPMaxLoops
.SS Description
.PP
Coarse grid fitting is performed with a limited subset of the whole
point cloud.
This is followed with a refinment stage in which the enire point is
fitted using an initial guess from the coarse fitting stage.
CoarseICPMaxLoops is the maximum number of iterative\-closest point loop
iterations performed during the coarse grid fitting stage.
(See operation notes for further details.)
.SS Default
.IP \[bu] 2
\f[C]"10"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"100"\f[]
.IP \[bu] 2
\f[C]"1E4"\f[]
.SS FineICPMaxLoops
.SS Description
.PP
Coarse grid fitting is performed with a limited subset of the whole
point cloud.
This is followed with a refinment stage in which the enire point is
fitted using an initial guess from the coarse fitting stage.
FineICPMaxLoops is the maximum number of iterative\-closest point loop
iterations performed during the refinement stage.
(See operation notes for further details.)
.SS Default
.IP \[bu] 2
\f[C]"20"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"50"\f[]
.IP \[bu] 2
\f[C]"100"\f[]
.SS ResultsSummaryFileName
.SS Description
.PP
This file will contain a brief summary of the results.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
If an existing file is present, rows will be appended without writing a
header.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.SS DetectShapes3D
.SS Description
.PP
This operation attempts to detect shapes in image volumes.
.SS Parameters
.IP \[bu] 2
ImageSelection
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS DrawGeometry
.SS Description
.PP
This operation draws shapes and patterns on images.
Drawing is confined to one or more ROIs.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
VoxelValue
.IP \[bu] 2
Overwrite
.IP \[bu] 2
Channel
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
ContourOverlap
.IP \[bu] 2
Inclusivity
.IP \[bu] 2
Shapes
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS VoxelValue
.SS Description
.PP
The value to give voxels which are coincident with a point from the
point cloud.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1.0"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"nan"\f[]
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Overwrite
.SS Description
.PP
Whether to overwrite voxels interior or exterior to the specified
ROI(s).
.SS Default
.IP \[bu] 2
\f[C]"interior"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"interior"\f[]
.IP \[bu] 2
\f[C]"exterior"\f[]
.SS Channel
.SS Description
.PP
The image channel to use.
Zero\-based.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS ContourOverlap
.SS Description
.PP
Controls overlapping contours are treated.
The default `ignore' treats overlapping contours as a single contour,
regardless of contour orientation.
The option `honour_opposite_orientations' makes overlapping contours
with opposite orientation cancel.
Otherwise, orientation is ignored.
The latter is useful for Boolean structures where contour orientation is
significant for interior contours (holes).
The option `overlapping_contours_cancel' ignores orientation and cancels
all contour overlap.
.SS Default
.IP \[bu] 2
\f[C]"ignore"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"ignore"\f[]
.IP \[bu] 2
\f[C]"honour_opposite_orientations"\f[]
.IP \[bu] 2
\f[C]"overlapping_contours_cancel"\f[]
.IP \[bu] 2
\f[C]"honour_opps"\f[]
.IP \[bu] 2
\f[C]"overlap_cancel"\f[]
.SS Inclusivity
.SS Description
.PP
Controls how voxels are deemed to be `within' the interior of the
selected ROI(s).
The default `center' considers only the central\-most point of each
voxel.
There are two corner options that correspond to a 2D projection of the
voxel onto the image plane.
The first, `planar_corner_inclusive', considers a voxel interior if ANY
corner is interior.
The second, `planar_corner_exclusive', considers a voxel interior if ALL
(four) corners are interior.
.SS Default
.IP \[bu] 2
\f[C]"center"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"center"\f[]
.IP \[bu] 2
\f[C]"centre"\f[]
.IP \[bu] 2
\f[C]"planar_corner_inclusive"\f[]
.IP \[bu] 2
\f[C]"planar_inc"\f[]
.IP \[bu] 2
\f[C]"planar_corner_exclusive"\f[]
.IP \[bu] 2
\f[C]"planar_exc"\f[]
.SS Shapes
.SS Description
.PP
This parameter is used to specify the shapes and patterns to consider.
Currently grids, wireframecubes, and solidspheres are available.
Grids have four configurable parameters: two orientation unit vectors,
line thickness, and line separation.
A grid intersecting at the image array's centre, aligned with
(1.0,0.0,0.0) and (0.0,1.0,0.0), with line thickness (i.e., diameter)
3.0 (DICOM units; mm), and separation 15.0 can be specified as
`grid(1.0,0.0,0.0, 0.0,1.0,0.0, 3.0, 15.0)'.
Unit vectors will be Gram\-Schmidt orthogonalized.
Note that currently the grid \f[I]must\f[] intersect the image array's
centre.
Cubes have the same number of configurable parameters, but only a single
cube of the grid is drawn.
The wireframecube is centred at the image centre, rather than
intersecting it.
Solid spheres have two configurable parameters: a centre vector and a
radius.
A solid sphere at (1.0,2.0,3.0) with radius 15.0 (all DICOM units; mm)
can be specified as `solidsphere(1.0,2.0,3.0, 15.0)'.
Grid, wireframecube, and solidsphere shapes only overwrite voxels that
intersect the geometry (i.e., the surface if hollow or the internal
volume if solid) permitting easier composition of multiple shapes or
custom backgrounds.
.SS Default
.IP \[bu] 2
\f[C]"grid(\-0.0941083,0.995562,0,\ 0.992667,0.0938347,0.0762047,\ 3.0,\ 15.0)"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"grid(1.0,0.0,0.0,\ 0.0,1.0,0.0,\ 3.0,\ 15.0)"\f[]
.IP \[bu] 2
\f[C]"wireframecube(1.0,0.0,0.0,\ 0.0,1.0,0.0,\ 3.0,\ 15.0)"\f[]
.IP \[bu] 2
\f[C]"solidsphere(0.0,0.0,0.0,\ 15.0)"\f[]
.SS DroverDebug
.SS Description
.PP
This operation reports basic information on the state of the main Drover
class.
It can be used to report on the state of the data, which can be useful
for debugging.
.SS Parameters
.IP \[bu] 2
IncludeMetadata
.SS IncludeMetadata
.SS Description
.PP
Whether to include metadata in the output.
This data can significantly increase the size of the output.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS DumpAllOrderedImageMetadataToFile
.SS Description
.PP
Dump exactly what order the data will be in for the following analysis.
.SS Parameters
.PP
No registered options.
.SS DumpAnEncompassedPoint
.SS Description
.PP
This operation estimates the number of spatially\-overlapping images.
It finds an arbitrary point within an arbitrary image, and then finds
all other images which encompass the point.
.SS Parameters
.PP
No registered options.
.SS DumpFilesPartitionedByTime
.SS Description
.PP
This operation prints PACS filenames along with the associated time.
It is more focused than the metadata dumpers above.
This data can be used for many things, such as image viewers which are
not DICOM\-aware or deformable registration on time series data.
.SS Parameters
.PP
No registered options.
.SS DumpImageMeshes
.SS Description
.PP
This operation exports images as a 3D surface mesh model (structured
ASCII Wavefront OBJ) that can be manipulated in various ways (e.g.,
stereographic projection).
Note that the mesh will be a 3D depiction of the image(s) as they
naturally are \[en] meshes will always be rectangular.
A companion material library file (MTL) assigns colours to each ROI
based on the voxel intensity.
.SS Notes
.IP \[bu] 2
Each image is processed separately.
Each mesh effectively produces a 2D relief map embedded into a 3D model
that can be easily rendered to produce various effects (e.g.,
perspective, stereoscopy, extrusion, surface smoothing, etc.).
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
OutBase
.IP \[bu] 2
HistogramBins
.IP \[bu] 2
MagnitudeAmplification
.IP \[bu] 2
Normalize
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS OutBase
.SS Description
.PP
A base filename (or full path) in which to (over)write image mesh and
material library files.
File formats are Wavefront Object (obj) and Material Library (mtl).
Every image will receive one unique and sequentially\-numbered obj and
mtl file using this prefix.
.SS Default
.IP \[bu] 2
\f[C]"/tmp/dicomautomaton_dumpimagemeshes_"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"/tmp/image_mesh_"\f[]
.IP \[bu] 2
\f[C]"./"\f[]
.IP \[bu] 2
\f[C]"../model_"\f[]
.SS HistogramBins
.SS Description
.PP
The number of equal\-width bins pixel intensities should be grouped
into.
Binning is performed in order to more easily associate material
properties with pixels.
If pixel intensities were continuous, each pixel would receive its own
material definition.
This could result in enormous MTL files and wasted disk space.
Binning solves this issue.
However, if images are small or must be differentiated precisely
consider using a large number of bins.
Otherwise 150\-1000 bins should suffice for display purposes.
.SS Default
.IP \[bu] 2
\f[C]"255"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"50"\f[]
.IP \[bu] 2
\f[C]"100"\f[]
.IP \[bu] 2
\f[C]"200"\f[]
.IP \[bu] 2
\f[C]"500"\f[]
.SS MagnitudeAmplification
.SS Description
.PP
Pixel magnitudes (i.e., intensities) are scaled according to the image
thickness, but a small gap is left between meshes so that abutting
images do not quite intersect (this can cause non\-manifold scenarios).
However, if stackability is not a concern then pixel magnitudes can be
magnified to exaggerate the relief effect.
A value of 1.0 provides no magnification.
A value of 2.0 provides 2x magnification, but note that the base of each
pixel is slightly offset from the top to avoid top\-bottom face
intersections, even when magnification is 0.0.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.75"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"5.0"\f[]
.IP \[bu] 2
\f[C]"75.6"\f[]
.SS Normalize
.SS Description
.PP
This parameter controls whether the model will be `normalized,' which
effectively makes the outgoing model more consistent for all images.
Currently this means centring the model at (0,0,0), mapping the row and
column directions to (1,0,0) and (0,1,0) respectively, and scaling the
image (respecting the aspect ratio) to fit within a bounding square of
size 100x100 (DICOM units; mm).
If normalization is \f[I]not\f[] used, the image mesh will inherit the
spatial characteristics of the image it is derived from.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS DumpImageMetadataOccurrencesToFile
.SS Description
.PP
Dump all the metadata elements, but group like\-items together and also
print the occurence number.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
FileName
.IP \[bu] 2
UserComment
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS FileName
.SS Description
.PP
A filename (or full path) in which to append metadata reported by this
routine.
The format is tab\-separated values (TSV).
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.tsv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.tsv"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
If left empty, the column will be empty in the output.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.SS DumpPerROIParams_KineticModel_1C2I_5P
.SS Description
.PP
Given a perfusion model, this routine computes parameter estimates for
ROIs.
.SS Parameters
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Filename
.IP \[bu] 2
Separator
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Filename
.SS Description
.PP
A file into which the results should be dumped.
If the filename is empty, the results are dumped to the console only.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"/tmp/results.txt"\f[]
.IP \[bu] 2
\f[C]"/dev/null"\f[]
.IP \[bu] 2
\f[C]"~/output.txt"\f[]
.SS Separator
.SS Description
.PP
The token(s) to place between adjacent columns of output.
Note: because whitespace is trimmed from user parameters, whitespace
separators other than the default are shortened to an empty string.
So non\-default whitespace are not currently supported.
.SS Default
.IP \[bu] 2
\f[C]"\ "\f[]
.SS Examples
.IP \[bu] 2
\f[C]","\f[]
.IP \[bu] 2
\f[C]";"\f[]
.IP \[bu] 2
\f[C]"_a_long_separator_"\f[]
.SS DumpPixelValuesOverTimeForAnEncompassedPoint
.SS Description
.PP
Output the pixel values over time for a generic point.
Currently the point is arbitrarily taken to tbe the centre of the first
image.
This is useful for quickly and programmatically inspecting trends, but
the SFML_Viewer operation is better for interactive exploration.
.SS Parameters
.PP
No registered options.
.SS DumpPlanSummary
.SS Description
.PP
This operation dumps a summary of a radiotherapy plan.
This operation can be used to gain insight into a plan from a
high\-level overview.
.SS Parameters
.IP \[bu] 2
SummaryFileName
.IP \[bu] 2
UserComment
.SS SummaryFileName
.SS Description
.PP
A filename (or full path) in which to append summary data generated by
this routine.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
If left empty, the column will be omitted from the output.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.SS DumpROIContours
.SS Description
.PP
This operation exports contours in a standard surface mesh format
(structured ASCII Wavefront OBJ) in planar polygon format.
A companion material library file (MTL) assigns colours to each ROI to
help differentiate them.
.SS Notes
.IP \[bu] 2
Contours that are grouped together into a contour_collection are treated
as a logical within the output.
For example, all contours in a collection will share a common material
property (e.g., colour).
If more fine\-grained grouping is required, this routine can be called
once for each group which will result in a logical grouping of one ROI
per file.
.SS Parameters
.IP \[bu] 2
DumpFileName
.IP \[bu] 2
MTLFileName
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.SS DumpFileName
.SS Description
.PP
A filename (or full path) in which to (over)write with contour data.
File format is Wavefront obj.
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile.obj"\f[]
.IP \[bu] 2
\f[C]"localfile.obj"\f[]
.IP \[bu] 2
\f[C]"derivative_data.obj"\f[]
.SS MTLFileName
.SS Description
.PP
A filename (or full path) in which to (over)write a Wavefront material
library file.
This file is used to colour the contours to help differentiate them.
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/materials.mtl"\f[]
.IP \[bu] 2
\f[C]"localfile.mtl"\f[]
.IP \[bu] 2
\f[C]"somefile.mtl"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS DumpROIData
.SS Description
.PP
This operation dumps ROI contour information for debugging and quick
inspection purposes.
.SS Parameters
.PP
No registered options.
.SS DumpROISNR
.SS Description
.PP
This operation computes the Signal\-to\-Noise ratio (SNR) for each ROI.
The specific `SNR' computed is SNR = (mean pixel) / (pixel std dev)
which is the inverse of the coefficient of variation.
.SS Notes
.IP \[bu] 2
This routine will combine spatially\-overlapping images by summing voxel
intensities.
So if you have a time course it may be more sensible to aggregate images
in some way (e.g., spatial averaging) prior to calling this routine.
.SS Parameters
.IP \[bu] 2
SNRFileName
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.SS SNRFileName
.SS Description
.PP
A filename (or full path) in which to append SNR data generated by this
routine.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS DumpROISurfaceMeshes
.SS Description
.PP
This operation generates surface meshes from contour volumes.
Output is written to file(s) for viewing with an external viewer (e.g.,
meshlab).
.SS Notes
.IP \[bu] 2
This routine is currently limited.
Many parameters can only be modified via recompilation.
This will be addressed in a future version.
.SS Parameters
.IP \[bu] 2
OutBase
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
GridRows
.IP \[bu] 2
GridColumns
.IP \[bu] 2
ContourOverlap
.IP \[bu] 2
Inclusivity
.SS OutBase
.SS Description
.PP
The prefix of the filename that surface mesh files will be saved as.
If no name is given, unique names will be chosen automatically.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"/tmp/dicomautomaton_dumproisurfacemesh"\f[]
.IP \[bu] 2
\f[C]"../somedir/output"\f[]
.IP \[bu] 2
\f[C]"/path/to/some/mesh"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses grep syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*parotid.*|.*sub.*mand.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid|eyes"\f[]
.SS GridRows
.SS Description
.PP
Controls the spatial resolution of the grid used to approximate the
ROI(s).
Specifically, the number of rows.
Note that the number of slices is fixed by the contour separation.
A larger number will result in a more accurate mesh, but will also
result longer runtimes and higher mesh complexity.
Setting this parameter too high will result in excessive runtime and
memory usage, so consider post\-processing (i.e., subdivision) if a
smooth mesh is needed.
.SS Default
.IP \[bu] 2
\f[C]"256"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"64"\f[]
.IP \[bu] 2
\f[C]"128"\f[]
.IP \[bu] 2
\f[C]"256"\f[]
.IP \[bu] 2
\f[C]"512"\f[]
.IP \[bu] 2
\f[C]"1024"\f[]
.SS GridColumns
.SS Description
.PP
Controls the spatial resolution of the grid used to approximate the
ROI(s).
(Refer to GridRows for more information.)
.SS Default
.IP \[bu] 2
\f[C]"256"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"64"\f[]
.IP \[bu] 2
\f[C]"128"\f[]
.IP \[bu] 2
\f[C]"256"\f[]
.IP \[bu] 2
\f[C]"512"\f[]
.IP \[bu] 2
\f[C]"1024"\f[]
.SS ContourOverlap
.SS Description
.PP
Controls overlapping contours are treated.
The default `ignore' treats overlapping contours as a single contour,
regardless of contour orientation.
The option `honour_opposite_orientations' makes overlapping contours
with opposite orientation cancel.
Otherwise, orientation is ignored.
The latter is useful for Boolean structures where contour orientation is
significant for interior contours (holes).
The option `overlapping_contours_cancel' ignores orientation and cancels
all contour overlap.
.SS Default
.IP \[bu] 2
\f[C]"ignore"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"ignore"\f[]
.IP \[bu] 2
\f[C]"honour_opposite_orientations"\f[]
.IP \[bu] 2
\f[C]"overlapping_contours_cancel"\f[]
.IP \[bu] 2
\f[C]"honour_opps"\f[]
.IP \[bu] 2
\f[C]"overlap_cancel"\f[]
.SS Inclusivity
.SS Description
.PP
Controls how voxels are deemed to be `within' the interior of the
selected ROI(s).
The default `center' considers only the central\-most point of each
voxel.
There are two corner options that correspond to a 2D projection of the
voxel onto the image plane.
The first, `planar_corner_inclusive', considers a voxel interior if ANY
corner is interior.
The second, `planar_corner_exclusive', considers a voxel interior if ALL
(four) corners are interior.
.SS Default
.IP \[bu] 2
\f[C]"center"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"center"\f[]
.IP \[bu] 2
\f[C]"centre"\f[]
.IP \[bu] 2
\f[C]"planar_corner_inclusive"\f[]
.IP \[bu] 2
\f[C]"planar_inc"\f[]
.IP \[bu] 2
\f[C]"planar_corner_exclusive"\f[]
.IP \[bu] 2
\f[C]"planar_exc"\f[]
.SS DumpTPlanMetadataOccurrencesToFile
.SS Description
.PP
Dump all the metadata elements, but group like\-items together and also
print the occurence number.
.SS Parameters
.IP \[bu] 2
TPlanSelection
.IP \[bu] 2
FileName
.IP \[bu] 2
UserComment
.SS TPlanSelection
.SS Description
.PP
Select one or more treatment plans.
Note that a single treatment plan may be composed of multiple beams; if
delivered sequentially, they should collectively represent a single
logically cohesive plan.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth treatment
plan (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last treatment plan.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS FileName
.SS Description
.PP
A filename (or full path) in which to append metadata reported by this
routine.
The format is tab\-separated values (TSV).
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.tsv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.tsv"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
If left empty, the column will be empty in the output.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.SS DumpVoxelDoseInfo
.SS Description
.PP
This operation locates the minimum and maximum dose voxel values.
It is useful for estimating prescription doses.
.SS Notes
.IP \[bu] 2
This implementation makes use of a primitive way of estimating dose.
Please verify it works (or re\-write using the new methods) before using
for anything important.
.SS Parameters
.PP
No registered options.
.SS EQDConvert
.SS Description
.PP
This operation performs a BED\-based conversion to a dose\-equivalent
that would have `d' dose per fraction (e.g., for `EQD2' the dose per
fraction would be 2 Gy).
.SS Notes
.IP \[bu] 2
This operation treats all tissue as either tumourous or not, and allows
specification of a single alpha/beta for each type (i.e., one for
tumourous tissues, one for normal tissues).
Owing to this limitation, use of this operation is generally limited to
single\-OAR or PTV\-only EQD conversions.
.IP \[bu] 2
This operation requires NumberOfFractions and cannot use
DosePerFraction.
The reasoning is that the DosePerFraction would need to be specified for
each individual voxel; the prescription DosePerFraction is NOT the same
as voxels outside the PTV.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
AlphaBetaRatioNormal
.IP \[bu] 2
AlphaBetaRatioTumour
.IP \[bu] 2
NumberOfFractions
.IP \[bu] 2
TargetDosePerFraction
.IP \[bu] 2
PrescriptionDose
.IP \[bu] 2
Model
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS AlphaBetaRatioNormal
.SS Description
.PP
The value to use for alpha/beta in normal (non\-cancerous) tissues.
Generally a value of 3.0 Gy is used.
Tissues that are sensitive to fractionation may warrant smaller ratios,
such as 1.5\-3 Gy for cervical central nervous tissues and 2.3\-4.9 for
lumbar central nervous tissues (consult table 8.1, page 107 in: Joiner
et al., `Fractionation: the linear\-quadratic approach', 4th Ed., 2009,
in the book `Basic Clinical Radiobiology', ISBN: 0340929669).
Note that the selected ROIs denote which tissues are diseased.
The remaining tissues are considered to be normal.
.SS Default
.IP \[bu] 2
\f[C]"3.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"3.0"\f[]
.SS AlphaBetaRatioTumour
.SS Description
.PP
The value to use for alpha/beta in diseased (tumourous) tissues.
Generally a value of 10.0 is used.
Note that the selected ROIs denote which tissues are diseased.
The remaining tissues are considered to be normal.
.SS Default
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS NumberOfFractions
.SS Description
.PP
The number of fractions in which a plan was (or will be) delivered.
Decimal fractions are supported to accommodate previous BED conversions.
.SS Default
.IP \[bu] 2
\f[C]"35"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"20.5"\f[]
.IP \[bu] 2
\f[C]"35"\f[]
.IP \[bu] 2
\f[C]"40.123"\f[]
.SS TargetDosePerFraction
.SS Description
.PP
The desired dose per fraction.
For `EQD2' this value must be 2 Gy.
Note that the specific interpretation of this parameter depends on the
model.
.SS Default
.IP \[bu] 2
\f[C]"2.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.8"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"5.0"\f[]
.IP \[bu] 2
\f[C]"8.0"\f[]
.SS PrescriptionDose
.SS Description
.PP
The prescription dose that was (or will be) delivered to the PTV.
This parameter is only used for the `pinned\-lq\-simple' model.
Note that this is a theoretical dose since the PTV or CTV will only
nominally receive this dose.
Also note that the specified dose need not exist somewhere in the image.
It can be purely theoretical to accommodate previous BED conversions.
.SS Default
.IP \[bu] 2
\f[C]"70"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"15"\f[]
.IP \[bu] 2
\f[C]"22.5"\f[]
.IP \[bu] 2
\f[C]"45.0"\f[]
.IP \[bu] 2
\f[C]"66"\f[]
.IP \[bu] 2
\f[C]"70.001"\f[]
.SS Model
.SS Description
.PP
The EQD model to use.
Current options are `lq\-simple' and `lq\-simple\-pinned'.
The `lq\-simple' model uses a simplistic linear\-quadratic model.
This model disregards time delays, including repopulation.
The `lq\-simple\-pinned' model is an \f[B]experimental\f[] alternative
to the `lq\-simple' model.
The `lq\-simple\-pinned' model implements the `lq\-simple' model, but
avoids having to specify d dose per fraction.
First the prescription dose is transformed to EQD with d dose per
fraction and the effective number of fractions is extracted.
Then, each voxel is transformed assuming this effective number of
fractions rather than a specific dose per fraction.
This model conveniently avoids having to awkwardly specify d dose per
fraction for voxels that receive less than d dose.
It is also idempotent.
Note, however, that the `lq\-simple\-pinned' model produces EQD
estimates that are \f[B]incompatbile\f[] with `lq\-simple' EQD
estimates.
.SS Default
.IP \[bu] 2
\f[C]"lq\-simple"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"lq\-simple"\f[]
.IP \[bu] 2
\f[C]"lq\-simple\-pinned"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider as bounding tumourous
tissues.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*GTV.*"\f[]
.IP \[bu] 2
\f[C]"PTV66"\f[]
.IP \[bu] 2
\f[C]".*PTV.*|.*GTV.**"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider as bounding tumourous
tissues.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*GTV.*"\f[]
.IP \[bu] 2
\f[C]"PTV66"\f[]
.IP \[bu] 2
\f[C]".*PTV.*|.*GTV.**"\f[]
.SS EvaluateDoseVolumeStats
.SS Description
.PP
This operation evaluates a variety of Dose\-Volume statistics.
It is geared toward PTV ROIs.
Currently the following are implemented: (1) Dose Homogeneity Index: H =
(D_{2%} \- D_{98%})/D_{median} | over one or more PTVs, where D_{2%} is
the maximum dose that covers 2% of the volume of the PTV, and D_{98%} is
the minimum dose that covers 98% of the volume of the PTV.
(2) Conformity Number: C = V_{T,pres}^{2} / ( V_{T} * V_{pres} ) where
V_{T,pres} is the PTV volume receiving at least 95% of the PTV
prescription dose, V_{T} is the volume of the PTV, and V_{pres} is
volume of all (tissue) voxels receiving at least 95% of the PTV
prescription dose.
.SS Notes
.IP \[bu] 2
This routine will combine spatially\-overlapping images by summing voxel
intensities.
It will not combine separate image_arrays though.
If needed, you'll have to perform a meld on them beforehand.
.SS Parameters
.IP \[bu] 2
OutFileName
.IP \[bu] 2
PTVPrescriptionDose
.IP \[bu] 2
PTVNormalizedROILabelRegex
.IP \[bu] 2
PTVROILabelRegex
.IP \[bu] 2
BodyNormalizedROILabelRegex
.IP \[bu] 2
BodyROILabelRegex
.IP \[bu] 2
UserComment
.SS OutFileName
.SS Description
.PP
A filename (or full path) in which to append dose statistic data
generated by this routine.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS PTVPrescriptionDose
.SS Description
.PP
The dose prescribed to the PTV of interest (in Gy).
.SS Default
.IP \[bu] 2
\f[C]"70"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"50"\f[]
.IP \[bu] 2
\f[C]"66"\f[]
.IP \[bu] 2
\f[C]"70"\f[]
.IP \[bu] 2
\f[C]"82.5"\f[]
.SS PTVNormalizedROILabelRegex
.SS Description
.PP
A regex matching PTV ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS PTVROILabelRegex
.SS Description
.PP
A regex matching PTV ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*PTV.*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS BodyNormalizedROILabelRegex
.SS Description
.PP
A regex matching body ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS BodyROILabelRegex
.SS Description
.PP
A regex matching PTV ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*body.*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
If left empty, the column will be omitted from the output.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.SS EvaluateNTCPModels
.SS Description
.PP
This operation evaluates a variety of NTCP models for each provided ROI.
The selected ROI should be OARs.
Currently the following are implemented: (1) The LKB model.
(2) The `Fenwick' model for solid tumours (in the lung; for a
whole\-lung OAR).
.SS Notes
.IP \[bu] 2
Generally these models require dose in 2 Gy per fraction equivalents
(`EQD2').
You must pre\-convert the data if the RT plan is not already 2 Gy per
fraction.
There is no easy way to ensure this conversion has taken place or was
unnecessary.
.IP \[bu] 2
This routine will combine spatially\-overlapping images by summing voxel
intensities.
So if you have a time course it may be more sensible to aggregate images
in some way (e.g., spatial averaging) prior to calling this routine.
.IP \[bu] 2
The LKB and mEUD both have their own gEUD `alpha' parameter, but they
are not necessarily shared.
Huang et al.\ 2015 (doi:10.1038/srep18010) used alpha=1 for the LKB
model and alpha=5 for the mEUD model.
.SS Parameters
.IP \[bu] 2
NTCPFileName
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
LKB_TD50
.IP \[bu] 2
LKB_M
.IP \[bu] 2
LKB_Alpha
.IP \[bu] 2
UserComment
.SS NTCPFileName
.SS Description
.PP
A filename (or full path) in which to append NTCP data generated by this
routine.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS LKB_TD50
.SS Description
.PP
The dose (in Gray) needed to deliver to the selected OAR that will
induce the effect in 50% of cases.
.SS Default
.IP \[bu] 2
\f[C]"26.8"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"26.8"\f[]
.SS LKB_M
.SS Description
.PP
No description given\&...
.SS Default
.IP \[bu] 2
\f[C]"0.45"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.45"\f[]
.SS LKB_Alpha
.SS Description
.PP
The weighting factor \f[I]α\f[] that controls the relative weighting of
volume and dose in the generalized Equivalent Uniform Dose (gEUD) model.
When \f[I]α\f[] = 1, the gEUD is equivalent to the mean; when
\f[I]α\f[] = 0, the gEUD is equivalent to the geometric mean.
Wu et al.
(doi:10.1016/S0360\-3016(01)02585\-8) claim that for normal tissues,
\f[I]α\f[] can be related to the Lyman\-Kutcher\-Burman (LKB) model
volume parameter `n' via \f[I]α\f[] = 1/\f[I]n\f[].
Sovik et al.
(doi:10.1016/j.ejmp.2007.09.001) found that gEUD is not strongly
impacted by errors in \f[I]α\f[].
Niemierko et al.
(`A generalized concept of equivalent uniform dose. Med Phys 26:1100,
1999) generated maximum likelihood estimates for 'several tumors and
normal structures' which ranged from \-13.1 for local control of
chordoma tumors to +17.7 for perforation of esophagus.
Gay et al.
(doi:10.1016/j.ejmp.2007.07.001) table 2 lists estimates based on the
work of Emami (doi:10.1016/0360\-3016(91)90171\-Y) for normal tissues
ranging from 1\-31.
Brenner et al.
(doi:10.1016/0360\-3016(93)90189\-3) recommend \-7.2 for breast cancer,
\-10 for melanoma, and \-13 for squamous cell carcinomas.
A 2017 presentation by Ontida Apinorasethkul claims the tumour range
spans [\-40:\-1] and the organs at risk range spans [1:40].
AAPM TG report 166 also provides a listing of recommended values,
suggesting \-10 for PTV and GTV, +1 for parotid, 20 for spinal cord, and
8\-16 for rectum, bladder, brainstem, chiasm, eye, and optic nerve.
Burman (1991) and QUANTEC (2010) also provide estimates.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.IP \[bu] 2
\f[C]"4"\f[]
.IP \[bu] 2
\f[C]"20"\f[]
.IP \[bu] 2
\f[C]"31"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
If left empty, the column will be omitted from the output.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.SS EvaluateTCPModels
.SS Description
.PP
This operation evaluates a variety of TCP models for each provided ROI.
The selected ROI should be the GTV (according to the Fenwick model).
Currently the following are implemented: (1) The `Martel' model.
(2) Equivalent Uniform Dose (EUD) TCP.
(3) The `Fenwick' model for solid tumours.
.SS Notes
.IP \[bu] 2
Generally these models require dose in 2Gy/fractions equivalents
(`EQD2').
You must pre\-convert the data if the RT plan is not already
2Gy/fraction.
There is no easy way to ensure this conversion has taken place or was
unnecessary.
.IP \[bu] 2
This routine will combine spatially\-overlapping images by summing voxel
intensities.
So if you have a time course it may be more sensible to aggregate images
in some way (e.g., spatial averaging) prior to calling this routine.
.IP \[bu] 2
The Fenwick and Martel models share the value of D_{50}.
There may be a slight difference in some cases.
Huang et al.\ 2015 (doi:10.1038/srep18010) used both models and used
84.5 Gy for the Martel model while using 84.6 Gy for the Fenwick model.
(The paper also reported using a Fenwick `m' of 0.329 whereas the
original report by Fenwick reported 0.392, so I don't think this should
be taken as strong evidence of the equality of D_{50}.
However, the difference seems relatively insignificant.)
.SS Parameters
.IP \[bu] 2
TCPFileName
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Gamma50
.IP \[bu] 2
Dose50
.IP \[bu] 2
EUD_Gamma50
.IP \[bu] 2
EUD_TCD50
.IP \[bu] 2
EUD_Alpha
.IP \[bu] 2
Fenwick_C
.IP \[bu] 2
Fenwick_M
.IP \[bu] 2
Fenwick_Vref
.IP \[bu] 2
UserComment
.SS TCPFileName
.SS Description
.PP
A filename (or full path) in which to append TCP data generated by this
routine.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Gamma50
.SS Description
.PP
The unitless `normalized dose\-response gradient' or normalized slope of
the logistic dose\-response model at the half\-maximum point (e.g.,
D_50).
Informally, this parameter controls the steepness of the dose\-response
curve.
(For more specific information, consult a standard reference such as
`Basic Clinical Radiobiology' 4th Edition by Joiner et al., sections
5.3\-5.5.) This parameter is empirically fit and not universal.
Late endpoints for normal tissues have gamma_50 around 2\-6 whereas
gamma_50 nominally varies around 1.5\-2.5 for local control of squamous
cell carcinomas of the head and neck.
.SS Default
.IP \[bu] 2
\f[C]"2.3"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.5"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"2.5"\f[]
.IP \[bu] 2
\f[C]"6"\f[]
.SS Dose50
.SS Description
.PP
The dose (in Gray) needed to achieve 50% probability of local tumour
control according to an empirical logistic dose\-response model (e.g.,
D_50).
Informally, this parameter `shifts' the model along the dose axis.
(For more specific information, consult a standard reference such as
`Basic Clinical Radiobiology' 4th Edition by Joiner et al., sections
5.1\-5.3.) This parameter is empirically fit and not universal.
In `Quantifying the position and steepness of radiation dose\-response
curves' by Bentzen and Tucker in 1994, D_50 of around 60\-65 Gy are
reported for local control of head and neck cancers (pyriform sinus
carcinoma and neck nodes with max diameter <= 3cm).
Martel et al.\ report 84.5 Gy in lung.
.SS Default
.IP \[bu] 2
\f[C]"65"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"37.9"\f[]
.IP \[bu] 2
\f[C]"52"\f[]
.IP \[bu] 2
\f[C]"60"\f[]
.IP \[bu] 2
\f[C]"65"\f[]
.IP \[bu] 2
\f[C]"84.5"\f[]
.SS EUD_Gamma50
.SS Description
.PP
The unitless `normalized dose\-response gradient' or normalized slope of
the gEUD TCP model.
It is defined only for the generalized Equivalent Uniform Dose (gEUD)
model.
This is sometimes referred to as the change in TCP for a unit change in
dose straddled at the TCD_50 dose.
It is a counterpart to the Martel model's `Gamma_50' parameter, but is
not quite the same.
Okunieff et al.
(doi:10.1016/0360\-3016(94)00475\-Z) computed Gamma50 for tumours in
human subjects across multiple institutions; they found a median of 0.8
for gross disease and a median of 1.5 for microscopic disease.
The inter\-quartile range was [0.7:1.8] and [0.7:2.2] respectively.
(Refer to table 3 for site\-specific values.) Additionally, Gay et al.
(doi:10.1016/j.ejmp.2007.07.001) claim that a value of 4.0 for late
effects a value of 2.0 for tumors in `are reasonable initial estimates
in [our] experience.' Their table 2 lists (NTCP) estimates based on the
work of Emami (doi:10.1016/0360\-3016(91)90171\-Y).
.SS Default
.IP \[bu] 2
\f[C]"0.8"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.8"\f[]
.IP \[bu] 2
\f[C]"1.5"\f[]
.SS EUD_TCD50
.SS Description
.PP
The uniform dose (in Gray) needed to deliver to the tumour to achieve
50% probability of local control.
It is defined only for the generalized Equivalent Uniform Dose (gEUD)
model.
It is a counterpart to the Martel model's `Dose_50' parameter, but is
not quite the same (n.b., TCD_50 is a uniform dose whereas D_50 is more
like a per voxel TCP\-weighted mean.) Okunieff et al.
(doi:10.1016/0360\-3016(94)00475\-Z) computed TCD50 for tumours in human
subjects across multiple institutions; they found a median of 51.9 Gy
for gross disease and a median of 37.9 Gy for microscopic disease.
The inter\-quartile range was [38.4:62.8] and [27.0:49.1] respectively.
(Refer to table 3 for site\-specific values.) Gay et al.
(doi:10.1016/j.ejmp.2007.07.001) table 2 lists (NTCP) estimates based on
the work of Emami (doi:10.1016/0360\-3016(91)90171\-Y) ranging from
18\-68 Gy.
.SS Default
.IP \[bu] 2
\f[C]"51.9"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"51.9"\f[]
.IP \[bu] 2
\f[C]"37.9"\f[]
.SS EUD_Alpha
.SS Description
.PP
The weighting factor \f[I]α\f[] that controls the relative weighting of
volume and dose in the generalized Equivalent Uniform Dose (gEUD) model.
When \f[I]α\f[] = 1, the gEUD is equivalent to the mean; when
\f[I]α\f[] = 0, the gEUD is equivalent to the geometric mean.
Wu et al.
(doi:10.1016/S0360\-3016(01)02585\-8) claim that for normal tissues,
\f[I]α\f[] can be related to the Lyman\-Kutcher\-Burman (LKB) model
volume parameter `n' via \f[I]α\f[] = 1/\f[I]n\f[].
Sovik et al.
(doi:10.1016/j.ejmp.2007.09.001) found that gEUD is not strongly
impacted by error in \f[I]α\f[].
Niemierko et al.
(`A generalized concept of equivalent uniform dose. Med Phys 26:1100,
1999) generated maximum likelihood estimates for 'several tumors and
normal structures' which ranged from \-13.1 for local control of
chordoma tumors to +17.7 for perforation of esophagus.
Gay et al.
(doi:10.1016/j.ejmp.2007.07.001) table 2 lists estimates based on the
work of Emami (doi:10.1016/0360\-3016(91)90171\-Y) for normal tissues
ranging from 1\-31.
Brenner et al.
(doi:10.1016/0360\-3016(93)90189\-3) recommend \-7.2 for breast cancer,
\-10 for melanoma, and \-13 for squamous cell carcinomas.
A 2017 presentation by Ontida Apinorasethkul claims the tumour range
spans [\-40:\-1] and the organs at risk range spans [1:40].
AAPM TG report 166 also provides a listing of recommended values,
suggesting \-10 for PTV and GTV, +1 for parotid, 20 for spinal cord, and
8\-16 for rectum, bladder, brainstem, chiasm, eye, and optic nerve.
Burman (1991) and QUANTEC (2010) also provide estimates.
.SS Default
.IP \[bu] 2
\f[C]"\-13.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-40"\f[]
.IP \[bu] 2
\f[C]"\-13.0"\f[]
.IP \[bu] 2
\f[C]"\-10"\f[]
.IP \[bu] 2
\f[C]"\-7.2"\f[]
.IP \[bu] 2
\f[C]"0.3"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.IP \[bu] 2
\f[C]"4"\f[]
.IP \[bu] 2
\f[C]"20"\f[]
.IP \[bu] 2
\f[C]"40"\f[]
.SS Fenwick_C
.SS Description
.PP
This parameter describes the degree that superlinear doses are required
to control large tumours.
In other words, as tumour volume grows, a disproportionate amount of
additional dose is required to maintain the same level of control.
The Fenwick model is semi\-empirical, so this number must be fitted or
used from values reported in the literature.
Fenwick et al.\ 2008 (doi:10.1016/j.clon.2008.12.011) provide values:
9.58 for local progression free survival at 30 months for NSCLC tumours
and 5.00 for head\-and\-neck tumours.
.SS Default
.IP \[bu] 2
\f[C]"9.58"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"9.58"\f[]
.IP \[bu] 2
\f[C]"5.00"\f[]
.SS Fenwick_M
.SS Description
.PP
This parameter describes the dose\-response steepness in the Fenwick
model.
Fenwick et al.\ 2008 (doi:10.1016/j.clon.2008.12.011) provide values:
0.392 for local progression free survival at 30 months for NSCLC tumours
and 0.280 for head\-and\-neck tumours.
.SS Default
.IP \[bu] 2
\f[C]"0.392"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.392"\f[]
.IP \[bu] 2
\f[C]"0.280"\f[]
.SS Fenwick_Vref
.SS Description
.PP
This parameter is the volume (in DICOM units; usually mm^3) of a
reference tumour (i.e., GTV; primary tumour and involved nodes) which
the D_{50} are estimated using.
In other words, this is a `nominal' tumour volume.
Fenwick et al.\ 2008 (doi:10.1016/j.clon.2008.12.011) recommend 148'410
mm^3 (i.e., a sphere of diameter 6.6 cm).
However, an appropriate value depends on the nature of the tumour.
.SS Default
.IP \[bu] 2
\f[C]"148410.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"148410.0"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
If left empty, the column will be omitted from the output.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.SS ExportFITSImages
.SS Description
.PP
This operation writes image arrays to FITS\-formatted image files.
.SS Notes
.IP \[bu] 2
Only pixel information and basic image positioning metadata are
exported.
In particular, contours and arbitrary metadata are \f[B]not\f[] exported
by this routine.
(If a rendering of the image with contours drawn is needed, consult the
PresentationImage operation.)
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
FilenameBase
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS FilenameBase
.SS Description
.PP
The base filename that images will be written to.
A sequentially\-increasing number and file suffix are appended after the
base filename.
Note that the file type is FITS.
.SS Default
.IP \[bu] 2
\f[C]"/tmp/dcma_exportfitsimages"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"../somedir/out"\f[]
.IP \[bu] 2
\f[C]"/path/to/some/dir/file_prefix"\f[]
.SS ExportLineSamples
.SS Description
.PP
This operation writes a line sample to a file.
.SS Parameters
.IP \[bu] 2
LineSelection
.IP \[bu] 2
FilenameBase
.SS LineSelection
.SS Description
.PP
Select one or more line samples.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth line
sample (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last line sample.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS FilenameBase
.SS Description
.PP
The base filename that line samples will be written to.
The file format is a 4\-column text file that can be readily plotted.
The columns are `x dx f df' where dx (df) represents the uncertainty in
x (f) if available.
Metadata is included, but will be base64 encoded if any non\-printable
characters are detected.
If no name is given, the default will be used.
A '_`, a sequentially\-increasing number, and the'.dat' file suffix are
appended after the base filename.
.SS Default
.IP \[bu] 2
\f[C]"/tmp/dcma_exportlinesamples"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"line_sample"\f[]
.IP \[bu] 2
\f[C]"../somedir/data"\f[]
.IP \[bu] 2
\f[C]"/path/to/some/line_sample_to_plot"\f[]
.SS ExportPointClouds
.SS Description
.PP
This operation writes point clouds to file.
.SS Parameters
.IP \[bu] 2
PointSelection
.IP \[bu] 2
FilenameBase
.SS PointSelection
.SS Description
.PP
Select one or more point clouds.
Note that point clouds can hold a variety of data with varying
attributes, but each point cloud is meant to represent a single
logically cohesive collection of points.
Be aware that it is possible to mix logically unrelated points together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth point
cloud (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last point cloud.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS FilenameBase
.SS Description
.PP
The base filename that line samples will be written to.
The file format is `XYZ' \[en] a 3\-column text file containing vector
coordinates of the points.
Metadata is excluded.
A '_`, a sequentially\-increasing number, and the'.xyz' file suffix are
appended after the base filename.
.SS Default
.IP \[bu] 2
\f[C]"/tmp/dcma_exportpointclouds"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"point_cloud"\f[]
.IP \[bu] 2
\f[C]"../somedir/data"\f[]
.IP \[bu] 2
\f[C]"/path/to/some/points"\f[]
.SS ExportSurfaceMeshes
.SS Description
.PP
This operation writes a surface mesh to a file.
.SS Parameters
.IP \[bu] 2
MeshSelection
.IP \[bu] 2
Filename
.SS MeshSelection
.SS Description
.PP
Select one or more surface meshes.
Note that a single surface mesh may hold many disconnected mesh
components; they should collectively represent a single logically
cohesive object.
Be aware that it is possible to mix logically unrelated sub\-meshes
together in a single mesh.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth surface
mesh (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last surface mesh.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Filename
.SS Description
.PP
The filename (or full path name) to which the surface mesh data should
be written.
The file format is an ASCII OFF model.
If no name is given, unique names will be chosen automatically.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"smesh.off"\f[]
.IP \[bu] 2
\f[C]"../somedir/mesh.off"\f[]
.IP \[bu] 2
\f[C]"/path/to/some/surface_mesh.off"\f[]
.SS ExportWarps
.SS Description
.PP
This operation exports a vector\-valued transformation (e.g., a
deformation) to a file.
.SS Parameters
.IP \[bu] 2
TransformSelection
.IP \[bu] 2
Filename
.SS TransformSelection
.SS Description
.PP
The transformation that will be applied.
Select one or more transforms.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth
transformation (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last transformation.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Filename
.SS Description
.PP
The filename (or full path name) to which the transformation should be
written.
Existing files will be overwritten.
The file format is a 4x4 Affine matrix.
If no name is given, a unique name will be chosen automatically.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"transformation.trans"\f[]
.IP \[bu] 2
\f[C]"trans.txt"\f[]
.IP \[bu] 2
\f[C]"/path/to/some/trans.txt"\f[]
.SS ExtractAlphaBeta
.SS Description
.PP
This operation compares two images arrays: either a
biologically\-equivalent dose
(\f[I]B\f[]\f[I]E\f[]\f[I]D\f[]~\f[I]α\f[]/\f[I]β\f[]~) transformed
array or an equivalent dose in \f[I]d\f[] dose per fraction
(\f[I]E\f[]\f[I]Q\f[]\f[I]D\f[]~\f[I]d\f[]~) array and a `reference'
untransformed array.
The \f[I]α\f[]/\f[I]β\f[] used for each voxel are extracted by comparing
corresponding voxels.
Each voxel is overwritten with the value of \f[I]α\f[]/\f[I]β\f[] needed
to accomplish the given transform.
This routine is best used to inspect a given transformation (e.g., for
QA purposes).
.SS Notes
.IP \[bu] 2
Images are overwritten, but ReferenceImages are not.
Multiple Images may be specified, but only one ReferenceImages may be
specified.
.IP \[bu] 2
The reference image array must be rectilinear.
(This is a requirement specific to this implementation, a less
restrictive implementation could overcome the issue.)
.IP \[bu] 2
For the fastest and most accurate results, test and reference image
arrays should spatially align.
However, alignment is \f[B]not\f[] necessary.
If test and reference image arrays are aligned, image adjacency can be
precomputed and the analysis will be faster.
If not, image adjacency must be evaluated for each image slice.
If this also fails, it will be evaluated for every voxel.
.IP \[bu] 2
This operation will make use of interpolation if corresponding voxels do
not exactly overlap.
.SS Parameters
.IP \[bu] 2
TransformedImageSelection
.IP \[bu] 2
ReferenceImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Model
.IP \[bu] 2
Channel
.IP \[bu] 2
TestImgLowerThreshold
.IP \[bu] 2
TestImgUpperThreshold
.IP \[bu] 2
NumberOfFractions
.IP \[bu] 2
NominalDosePerFraction
.SS TransformedImageSelection
.SS Description
.PP
The transformed image array where voxel intensities represent BED or
EQDd.
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"first"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ReferenceImageSelection
.SS Description
.PP
The un\-transformed image array where voxel intensities represent
(non\-BED) dose.
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Model
.SS Description
.PP
The model of BED or EQD transformation to assume.
Currently, only `simple\-lq\-eqd' is available.
The `simple\-lq\-eqd' model does not take into account elapsed time or
any cell repopulation effects.
.SS Default
.IP \[bu] 2
\f[C]"simple\-lq\-eqd"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"simple\-lq\-eqd"\f[]
.SS Channel
.SS Description
.PP
The channel to compare (zero\-based).
Setting to \-1 will compare each channel separately.
Note that both test images and reference images must share this
specifier.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS TestImgLowerThreshold
.SS Description
.PP
Pixel lower threshold for the test images.
Only voxels with values above this threshold (inclusive) will be
altered.
.SS Default
.IP \[bu] 2
\f[C]"\-inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-inf"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"200"\f[]
.SS TestImgUpperThreshold
.SS Description
.PP
Pixel upper threshold for the test images.
Only voxels with values below this threshold (inclusive) will be
altered.
.SS Default
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"inf"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"1000"\f[]
.SS NumberOfFractions
.SS Description
.PP
Number of fractions assumed in the BED or EQDd transformation.
.SS Default
.IP \[bu] 2
\f[C]"35"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"5"\f[]
.IP \[bu] 2
\f[C]"35"\f[]
.SS NominalDosePerFraction
.SS Description
.PP
The nominal dose per fraction (in DICOM units; Gy) assumed by an EQDd
transformation.
This parameter is the `d' in `EQDd'; for EQD2 transformations, this
parameter must be 2 Gy.
.SS Default
.IP \[bu] 2
\f[C]"2.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.8"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"8.0"\f[]
.SS ExtractImageHistograms
.SS Description
.PP
This operation extracts histograms (e.g., dose\-volume \[en] DVH, or
pixel intensity\-volume) for the selected image(s) and ROI(s).
Results are stored as line samples for later analysis or export.
.SS Notes
.IP \[bu] 2
This routine generates differential histograms with unscaled abscissae
and ordinate axes.
It also generates cumulative histograms with unscaled abscissae and
\f[I]both\f[] unscaled and peak\-normalized\-to\-one ordinates.
Unscaled abscissa are reported in DICOM units (typically HU or Gy),
unscaled ordinates are reported in volumetric DICOM units (mm^3^), and
normalized ordinates are reported as a fraction of the given ROI's total
volume.
.IP \[bu] 2
Non\-finite voxels are excluded from analysis and do not contribute to
the volume.
If exact volume is required, ensure all voxels are finite prior to
invoking this routine.
.IP \[bu] 2
This routine can handle contour partitions where the physical layout
(i.e., storage order) differs from the logical layout.
See the `grouping' options for available configuration.
.IP \[bu] 2
This routine will correctly handle non\-overlapping voxels with varying
volumes (i.e., rectilinear image arrays).
It will \f[I]not\f[] correctly handle overlapping voxels (i.e., each
overlapping voxel will be counted without regard for overlap).
If necessary, resample image arrays to be rectilinear.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
Channel
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
ContourOverlap
.IP \[bu] 2
Inclusivity
.IP \[bu] 2
Grouping
.IP \[bu] 2
GroupLabel
.IP \[bu] 2
Lower
.IP \[bu] 2
Upper
.IP \[bu] 2
dDose
.IP \[bu] 2
UserComment
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Channel
.SS Description
.PP
The image channel to use.
Zero\-based.
Use `\-1' to operate on all available channels.
.SS Default
.IP \[bu] 2
\f[C]"\-1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching the ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching the ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS ContourOverlap
.SS Description
.PP
Controls overlapping contours are treated.
The default `ignore' treats overlapping contours as a single contour,
regardless of contour orientation.
The option `honour_opposite_orientations' makes overlapping contours
with opposite orientation cancel.
Otherwise, orientation is ignored.
The latter is useful for Boolean structures where contour orientation is
significant for interior contours (holes).
The option `overlapping_contours_cancel' ignores orientation and cancels
all contour overlap.
.SS Default
.IP \[bu] 2
\f[C]"ignore"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"ignore"\f[]
.IP \[bu] 2
\f[C]"honour_opposite_orientations"\f[]
.IP \[bu] 2
\f[C]"overlapping_contours_cancel"\f[]
.IP \[bu] 2
\f[C]"honour_opps"\f[]
.IP \[bu] 2
\f[C]"overlap_cancel"\f[]
.SS Inclusivity
.SS Description
.PP
Controls how voxels are deemed to be `within' the interior of the
selected ROI(s).
The default `center' considers only the central\-most point of each
voxel.
There are two corner options that correspond to a 2D projection of the
voxel onto the image plane.
The first, `planar_corner_inclusive', considers a voxel interior if ANY
corner is interior.
The second, `planar_corner_exclusive', considers a voxel interior if ALL
(four) corners are interior.
.SS Default
.IP \[bu] 2
\f[C]"center"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"center"\f[]
.IP \[bu] 2
\f[C]"centre"\f[]
.IP \[bu] 2
\f[C]"planar_corner_inclusive"\f[]
.IP \[bu] 2
\f[C]"planar_inc"\f[]
.IP \[bu] 2
\f[C]"planar_corner_exclusive"\f[]
.IP \[bu] 2
\f[C]"planar_exc"\f[]
.SS Grouping
.SS Description
.PP
This routine partitions individual contours using their ROI labels.
This parameter controls whether contours with different names should be
treated as though they belong to distinct logical groups (`separate') or
whether \f[I]all\f[] contours should be treated as though they belong to
a single logical group (`combined').
The `separate' option works best for exploratory analysis, extracting
histograms for many OARs at once, or when you know the `physical'
grouping of contours by label reflects a consistent logical grouping.
The `combined' option works best when the physical and logical groupings
are inconsistent.
For example, when you need a combined histograms from multiple contours
or organs, or when similar structures should be combined (e.g., spinal
cord + canal; or distinct left + right lateral organs that should be
paired, e.g..
`combined parotids').
Note that when the `combined' option is used, the `GroupLabel' parameter
\f[I]must\f[] also be provided.
.SS Default
.IP \[bu] 2
\f[C]"separate"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"separate"\f[]
.IP \[bu] 2
\f[C]"grouped"\f[]
.SS GroupLabel
.SS Description
.PP
If the `Grouping' parameter is set to `combined', the value of the
`GroupLabel' parameter will be used in lieu of any consitituent
ROILabel.
Note that this parameter \f[I]must\f[] be provided when the `Grouping'
parameter is set to'combined'.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"combination"\f[]
.IP \[bu] 2
\f[C]"multiple_rois"\f[]
.IP \[bu] 2
\f[C]"logical_oar"\f[]
.IP \[bu] 2
\f[C]"both_oars"\f[]
.SS Lower
.SS Description
.PP
Disregard all voxel values lower than this value.
This parameter can be used to filter out spurious values.
All voxels with infinite or NaN intensities are excluded regardless of
this parameter.
Note that disregarded values will not contribute any volume.
.SS Default
.IP \[bu] 2
\f[C]"\-inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-inf"\f[]
.IP \[bu] 2
\f[C]"\-100.0"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"1.2"\f[]
.IP \[bu] 2
\f[C]"5.0E23"\f[]
.SS Upper
.SS Description
.PP
Disregard all voxel values greater than this value.
This parameter can be used to filter out spurious values.
All voxels with infinite or NaN intensities are excluded regardless of
this parameter.
Note that disregarded values will not contribute any volume.
.SS Default
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-100.0"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"1.2"\f[]
.IP \[bu] 2
\f[C]"5.0E23"\f[]
.IP \[bu] 2
\f[C]"inf"\f[]
.SS dDose
.SS Description
.PP
The (fixed) bin width, in units of dose (DICOM units; nominally Gy).
Note that this is the \f[I]maximum\f[] bin width, in practice bins may
be smaller to account for slop (i.e., excess caused by the extrema being
separated by a non\-integer number of bins of width
\f[I]d\f[]\f[I]D\f[]\f[I]o\f[]\f[I]s\f[]\f[I]e\f[]).
.SS Default
.IP \[bu] 2
\f[C]"0.1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0001"\f[]
.IP \[bu] 2
\f[C]"0.001"\f[]
.IP \[bu] 2
\f[C]"0.01"\f[]
.IP \[bu] 2
\f[C]"5.0"\f[]
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"50"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
If left empty, the column will be omitted from the output.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.SS ExtractPointsWarp
.SS Description
.PP
This operation uses two point clouds (one `moving' and the other
`stationary' or `reference') to find a transformation (`warp') that will
map the moving point set to the stationary point set.
The resulting transformation encapsulates a `registration' between the
two point sets \[en] however the transformation is generic and can be
later be used to move (i.e., `warp', `deform') other objects, including
the `moving' point set.
.SS Notes
.IP \[bu] 2
The `moving' point cloud is \f[I]not\f[] warped by this operation \[en]
this operation merely identifies a suitable transformation.
Separation of the identification and application of a warp allows the
warp to more easily re\-used and applied to multiple objects.
.IP \[bu] 2
The output of this operation is a transformation that can later be
applied, in principle, to point clouds, surface meshes, images,
arbitrary vector fields, and any other objects in \f[I]R\f[]^3^.
.IP \[bu] 2
There are multiple algorithms implemented.
Some do \f[I]not\f[] provide bijective mappings, meaning that swapping
the inputs will result in an altogether different registration (even
after inverting it).
.SS Parameters
.IP \[bu] 2
MovingPointSelection
.IP \[bu] 2
ReferencePointSelection
.IP \[bu] 2
Method
.IP \[bu] 2
TPSLambda
.IP \[bu] 2
TPSKernelDimension
.IP \[bu] 2
TPSSolver
.IP \[bu] 2
TPSRPMLambdaStart
.IP \[bu] 2
TPSRPMZetaStart
.IP \[bu] 2
TPSRPMDoubleSidedOutliers
.IP \[bu] 2
TPSRPMKernelDimension
.IP \[bu] 2
TPSRPMTStart
.IP \[bu] 2
TPSRPMTEnd
.IP \[bu] 2
TPSRPMTStep
.IP \[bu] 2
TPSRPMStepsPerT
.IP \[bu] 2
TPSRPMSinkhornMaxSteps
.IP \[bu] 2
TPSRPMSinkhornTolerance
.IP \[bu] 2
TPSRPMSeedWithCentroidShift
.IP \[bu] 2
TPSRPMSolver
.IP \[bu] 2
TPSRPMHardConstraints
.IP \[bu] 2
TPSRPMPermitMovingOutliers
.IP \[bu] 2
TPSRPMPermitStationaryOutliers
.IP \[bu] 2
MaxIterations
.IP \[bu] 2
RelativeTolerance
.SS MovingPointSelection
.SS Description
.PP
The point cloud that will serve as input to the warp function.
Select one or more point clouds.
Note that point clouds can hold a variety of data with varying
attributes, but each point cloud is meant to represent a single
logically cohesive collection of points.
Be aware that it is possible to mix logically unrelated points together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth point
cloud (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last point cloud.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ReferencePointSelection
.SS Description
.PP
The stationary point cloud to use as a reference for the moving point
cloud.
Select one or more point clouds.
Note that point clouds can hold a variety of data with varying
attributes, but each point cloud is meant to represent a single
logically cohesive collection of points.
Be aware that it is possible to mix logically unrelated points together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth point
cloud (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last point cloud.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
Note that this point cloud is not modified.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Method
.SS Description
.PP
The alignment algorithm to use.
The following alignment options are available: `centroid', `PCA',
`exhaustive_icp', `TPS', and `TPS\-RPM'.
The `centroid' option finds a rotationless translation the aligns the
centroid (i.e., the centre of mass if every point has the same `mass')
of the moving point cloud with that of the stationary point cloud.
It is susceptible to noise and outliers, and can only be reliably used
when the point cloud has complete rotational symmetry (i.e., a sphere).
On the other hand, `centroid' alignment should never fail, can handle a
large number of points, and can be used in cases of 2D and 1D
degeneracy.
centroid alignment is frequently used as a pre\-processing step for more
advanced algorithms.
The `PCA' option finds an Affine transformation by performing centroid
alignment, performing principle component analysis (PCA) separately on
the reference and moving point clouds, computing third\-order point
distribution moments along each principle axis to establish a consistent
orientation, and then rotates the moving point cloud so the principle
axes of the stationary and moving point clouds coincide.
The `PCA' method may be suitable when: (1) both clouds are not
contaminated with extra noise points (but some Gaussian noise in the
form of point `jitter' should be tolerated) and (2) the clouds are not
perfectly spherical (i.e., so they have valid principle components).
However, note that the `PCA' method is susceptible to outliers and can
not scale a point cloud.
The `PCA' method will generally fail when the distribution of points
shifts across the centroid (i.e., comparing reference and moving point
clouds) since the orientation of the components will be inverted,
however 2D degeneracy is handled in a 3D\-consistent way, and 1D
degeneracy is handled in a 1D\-consistent way (i.e, the components
orthogonal to the common line will be completely ambiguous, so spurious
rotations will result).
The `exhaustive_icp' option finds an Affine transformation by first
performing PCA\-based alignment and then iteratively alternating between
(1) estimating point\-point correspondence and (1) solving for a
least\-squares optimal transformation given this correspondence
estimate.
`ICP' stands for `iterative closest point.' Each iteration uses the
previous transformation \f[I]only\f[] to estimate correspondence; a
least\-squares optimal linear transform is estimated afresh each
iteration.
The `exhaustive_icp' method is most suitable when both point clouds
consist of approximately 50k points or less.
Beyond this, ICP will still work but runtime scales badly.
ICP is susceptible to outliers and will not scale a point cloud.
It can be used for 2D and 1D degenerate problems, but is not guaranteed
to find the `correct' orientation of degenerate or symmetrical point
clouds.
The `TPS' or Thin\-Plate Spline algorithm provides non\-rigid (i.e.,
`deformable') registration between corresponding point sets.
The moving and stationary point sets must have the same number of
points, and the \f[I]n\f[]^th^ moving point is taken to correspond to
the \f[I]n\f[]^th^ stationary point.
The `TPS' method does not scale well due in part to inversion of a large
(NxN) matrix and is therefore most suitable when both point clouds
consist of approximately 10\-20k points or less.
Beyond this, expect slow calculations.
The TPS method is not robust to outliers, however a regularization
parameter can be used to control the smoothness of the warp.
(Setting to zero will cause the warp function to exactly interpolate
every pair, except due to floating point inaccuracies.) Also note that
the TPS method can only, in general, be used for interpolation.
Extrapolation beyond the points clouds will almost certainly result in
wildly inconsistent and unstable transformations.
Consult Bookstein 1989 (doi:10.1109/34.24792) for an overview.
The `TPS\-RPM' or Thin\-Plate Spline Robust Point\-Matching algorithm
provides non\-rigid (i.e., `deformable') registration.
It combines a soft\-assign technique, deterministic annealing, and
thin\-plate splines to iteratively solve for correspondence and spatial
warp.
The `TPS\-RPM' method is (somewhat) robust to outliers in both moving
and stationary point sets, but it suffers from numerical instabilities
when one or more inputs are degenerate or symmetric in such a way that
many potential solutions have the same least\-square cost.
The `TPS\-RPM' method does not scale well due in part to inversion of a
large (NxM) matrix and is therefore most suitable when both point clouds
consist of approximately 1\-5k points or less.
Beyond this, expect slow calculations.
Also note that the underlying TPS method can only, in general, be used
for interpolation.
Extrapolation beyond the extent of the corresponding parts of the points
clouds will almost certainly result in wildly inconsistent and unstable
transformations.
Consult Chui and Rangarajan 2000 (original algorithm;
doi:10.1109/CVPR.2000.854733) and Yang 2011 (clarification and more
robust solution; doi:10.1016/j.patrec.2011.01.015) for more details.
.SS Default
.IP \[bu] 2
\f[C]"centroid"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"centroid"\f[]
.IP \[bu] 2
\f[C]"pca"\f[]
.IP \[bu] 2
\f[C]"exhaustive_icp"\f[]
.IP \[bu] 2
\f[C]"tps"\f[]
.IP \[bu] 2
\f[C]"tps_rpm"\f[]
.SS TPSLambda
.SS Description
.PP
Regularization parameter for the TPS method.
Controls the smoothness of the fitted thin plate spline function.
Setting to zero will ensure that all points are interpolated exactly
(barring numerical imprecision).
Setting higher will allow the spline to `relax' and smooth out.
The specific value to use is heavily dependent on the problem domain and
the amount of noise and outliers in the data.
It relates to the spacing between points.
Note that this parameter is used with the TPS method, but \f[I]not\f[]
in the TPS\-RPM method.
.SS Default
.IP \[bu] 2
\f[C]"0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1E\-4"\f[]
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS TPSKernelDimension
.SS Description
.PP
Dimensionality of the spline function kernel.
The kernel dimensionality \f[I]should\f[] match the dimensionality of
the points (i.e., 3), but doesn't need to.
2 seems to work best, even with points in 3D.
Note that this parameter may affect how the transformation extrapolates.
.SS Default
.IP \[bu] 2
\f[C]"2"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.SS TPSSolver
.SS Description
.PP
The method used to solve the system of linear equtions that defines the
thin plate spline solution.
The pseudoinverse will likely be able to provide a solution when the
system is degenerate, but it might not be reasonable or even sensible.
The LDLT method scales better.
.SS Default
.IP \[bu] 2
\f[C]"LDLT"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"LDLT"\f[]
.IP \[bu] 2
\f[C]"PseudoInverse"\f[]
.SS TPSRPMLambdaStart
.SS Description
.PP
Regularization parameter for the TPS\-RPM method.
Controls the smoothness of the fitted thin plate spline function.
Setting to zero will ensure that all points are interpolated exactly
(barring numerical imprecision).
Setting higher will allow the spline to `relax' and smooth out.
The specific value to use is heavily dependent on the problem domain and
the amount of noise and outliers in the data.
It relates to the spacing between points.
It follows the same annealing schedule as the system temperature does.
Note that this parameter is used with the TPS\-RPM method, but
\f[I]not\f[] in the TPS method.
.SS Default
.IP \[bu] 2
\f[C]"0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"1E\-4"\f[]
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS TPSRPMZetaStart
.SS Description
.PP
Regularization parameter for the TPS\-RPM method.
Controls the likelihood of points being treated as outliers.
Higher values will bias points towards \f[I]not\f[] being considered
outliers.
The specific value to use is heavily dependent on the problem domain and
the amount of noise and outliers in the data.
It relates to the spacing between points.
It follows the same annealing schedule as the system temperature does.
Note that this parameter is used with the TPS\-RPM method, but
\f[I]not\f[] in the TPS method.
.SS Default
.IP \[bu] 2
\f[C]"0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"1E\-4"\f[]
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS TPSRPMDoubleSidedOutliers
.SS Description
.PP
Controls whether the extensions for `double sided outlier handling' as
described by Yang et al.
(2011; doi:10.1016/j.patrec.2011.01.015) are used.
These extensions can improve resilience to outliers, especially in the
moving set.
Yang et al.\ also mention that the inclusion of an extra entropy term in
the cost function can help reduce jitter during the annealing process,
which may result in fewer folds or twists for narrow point clouds.
However, the resulting algorithm is overall less numerically stable and
has a strong dependence on the kernel dimension.
Enabling this parameter adjusts the interpretation of the lambda
regularization parameter, so some fine\-tuning may be required.
Note that this parameter is used with the TPS\-RPM method, but
\f[I]not\f[] in the TPS method.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS TPSRPMKernelDimension
.SS Description
.PP
Dimensionality of the spline function kernel.
The kernel dimensionality \f[I]should\f[] match the dimensionality of
the points (i.e., 3), but doesn't need to.
2 seems to work best, even with points in 3D.
Note that this parameter may affect how the transformation extrapolates.
Note that this parameter is used with the TPS\-RPM method, but
\f[I]not\f[] in the TPS method.
.SS Default
.IP \[bu] 2
\f[C]"2"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.SS TPSRPMTStart
.SS Description
.PP
The deterministic annealing starting temperature.
This parameter is a scaling factor that modifies the temperature
determined via an automatic method.
Larger numbers grant the system more freedom to find large\-scale
deformation; small values \f[I]limit\f[] the freedom to find
large\-scale deformations.
Note that this parameter is used with the TPS\-RPM method, but
\f[I]not\f[] in the TPS method.
.SS Default
.IP \[bu] 2
\f[C]"1.05"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.5"\f[]
.IP \[bu] 2
\f[C]"1.05"\f[]
.IP \[bu] 2
\f[C]"0.8"\f[]
.IP \[bu] 2
\f[C]"0.5"\f[]
.SS TPSRPMTEnd
.SS Description
.PP
The deterministic annealing ending temperature.
Higher numbers will result in a coarser, but faster registration.
This parameter is a scaling factor that modifies the temperature
determined via an automatic method.
Larger numbers limit the freedom of the system to find fine\-detail
deformations; small values may result in overfitting and folding
deformations.
Note that this parameter is used with the TPS\-RPM method, but
\f[I]not\f[] in the TPS method.
.SS Default
.IP \[bu] 2
\f[C]"0.01"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"0.01"\f[]
.SS TPSRPMTStep
.SS Description
.PP
The deterministic annealing ending temperature.
Higher numbers will result in slower annealing.
This parameter is a multiplicative factor, so if set to 0.95 temperature
adjustments will be \f[I]T\f[]^′^ = 0.95\f[I]T\f[].
Note that this parameter is used with the TPS\-RPM method, but
\f[I]not\f[] in the TPS method.
.SS Default
.IP \[bu] 2
\f[C]"0.93"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.99"\f[]
.IP \[bu] 2
\f[C]"0.93"\f[]
.IP \[bu] 2
\f[C]"0.9"\f[]
.SS TPSRPMStepsPerT
.SS Description
.PP
Deterministic annealing parameter controlling the number of
correspondence\-transformation update iterations performed at each
temperature.
Lower numbers will result in faster, but possibly less accurate
registrations.
Note that this parameter is used with the TPS\-RPM method, but
\f[I]not\f[] in the TPS method.
.SS Default
.IP \[bu] 2
\f[C]"5"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"5"\f[]
.IP \[bu] 2
\f[C]"10"\f[]
.SS TPSRPMSinkhornMaxSteps
.SS Description
.PP
Parameter controlling the number of iterations performed during the
Sinkhorn softassign correspondence estimation procedure.
Note that this is the worst\-case number of iterations since the
Sinkhorn procedure completes when tolerance is reached.
Setting this number to the maximum number of iterations acceptable given
your speed requirements should result in satisfactory results.
Note that use of forced correspondence \f[I]may\f[] require a higher
number of steps.
Note that this parameter is used with the TPS\-RPM method, but
\f[I]not\f[] in the TPS method.
.SS Default
.IP \[bu] 2
\f[C]"5000"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"500"\f[]
.IP \[bu] 2
\f[C]"5000"\f[]
.IP \[bu] 2
\f[C]"50000"\f[]
.IP \[bu] 2
\f[C]"500000"\f[]
.SS TPSRPMSinkhornTolerance
.SS Description
.PP
Parameter controlling the permissable deviation from the ideal
softassign correspondence normalization conditions (i.e., that each row
and each column sum to one).
If tolerance is reached then the Sinkhorn procedure is completed early.
However, if the maximum number of iterations is reached and the
tolerance has not been achieved then the algorithm terminates due to
failure.
If registration quality is flexible, setting a higher number can
significantly speed up the computation.
Note that this parameter is used with the TPS\-RPM method, but
\f[I]not\f[] in the TPS method.
.SS Default
.IP \[bu] 2
\f[C]"0.01"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1E\-4"\f[]
.IP \[bu] 2
\f[C]"0.001"\f[]
.IP \[bu] 2
\f[C]"0.01"\f[]
.SS TPSRPMSeedWithCentroidShift
.SS Description
.PP
Controls whether a centroid\-based registration is used to seed the
registration.
Typically this is not needed, since high temperatures give the system
enough freedom to find large\-scale deformations (include centroid
alignment).
However, if the initial alignment is intentional, and point cloud
centroids do not align, then seeding the registration will be
detrimental.
Seeding might be useful if the starting temperature is set low (which
will limit large\-scale deformations like centroid alignment).
Note that this parameter is used with the TPS\-RPM method, but
\f[I]not\f[] in the TPS method.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS TPSRPMSolver
.SS Description
.PP
The method used to solve the system of linear equtions that defines the
thin plate spline solution.
The pseudoinverse will likely be able to provide a solution when the
system is degenerate, but it might not be reasonable or even sensible.
The LDLT method scales better.
Note that this parameter is used with the TPS\-RPM method, but
\f[I]not\f[] in the TPS method.
.SS Default
.IP \[bu] 2
\f[C]"LDLT"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"LDLT"\f[]
.IP \[bu] 2
\f[C]"PseudoInverse"\f[]
.SS TPSRPMHardConstraints
.SS Description
.PP
Forced correspondence between pairs of points (one in the moving set,
one in the stationary set) specified as comma\-separated pairs of
indices into the moving and stationary point sets.
Indices are zero\-based.
Forced correspondences are taken to be exclusive, meaning that no other
points will correspond with either points.
Forced correspondence also begets outlier rejection, so ensure the
points are not tainted by noise or are outliers.
Note that points can be forced to be treated as outliers by indicating a
non\-existent index in the opposite set, such as \-1.
Use of forced correspondence may cause the Sinkhorn method to converge
slowly or possibly fail to converge at all.
Increasing the number of Sinkhorn iterations may be required.
Marking points as outliers has ramifications within the algorithm that
can lead to numerical instabilities (especially in the moving point
set).
If possible, it is best to remove known outlier points \f[I]prior\f[] to
attempting registration.
Note that this parameter is used with the TPS\-RPM method, but
\f[I]not\f[] in the TPS method.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0,10"\f[]
.IP \[bu] 2
\f[C]"23,45,\ 24,46,\ 0,100,\ \-1,50,\ 20,\-1"\f[]
.SS TPSRPMPermitMovingOutliers
.SS Description
.PP
If enabled, this option permits the TPS\-RPM algorithm to automatically
detect and eschew outliers in the moving point set.
A major strength of the TPS\-RPM algorithm is that it can handle
outliers, however there are legitimate cases where outliers are known
\f[I]not\f[] to be present, but the point\-to\-point correspondence is
\f[I]not\f[] known.
Note that outlier detection cannot be used when one or more points are
forced to be outliers.
Similar to forced correspondence (i.e., hard constraints), disabling
outlier detection can modify the Sinkhorn algorithm convergence.
Additionally, Sinkhorn normalization is likely to fail when outliers in
the larger point cloud are disallowed.
Note that this parameter is used with the TPS\-RPM method, but
\f[I]not\f[] in the TPS method.
.SS Default
.IP \[bu] 2
\f[C]"true"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS TPSRPMPermitStationaryOutliers
.SS Description
.PP
If enabled, this option permits the TPS\-RPM algorithm to automatically
detect and eschew outliers in the stationary point set.
A major strength of the TPS\-RPM algorithm is that it can handle
outliers, however there are legitimate cases where outliers are known
\f[I]not\f[] to be present, but the point\-to\-point correspondence is
\f[I]not\f[] known.
Note that outlier detection cannot be used when one or more points are
forced to be outliers.
Similar to forced correspondence (i.e., hard constraints), disabling
outlier detection can modify the Sinkhorn algorithm convergence.
Additionally, Sinkhorn normalization is likely to fail when outliers in
the larger point cloud are disallowed.
Note that this parameter is used with the TPS\-RPM method, but
\f[I]not\f[] in the TPS method.
.SS Default
.IP \[bu] 2
\f[C]"true"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS MaxIterations
.SS Description
.PP
If the method is iterative, only permit this many iterations to occur.
Note that this parameter will not have any effect on non\-iterative
methods.
.SS Default
.IP \[bu] 2
\f[C]"100"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"5"\f[]
.IP \[bu] 2
\f[C]"20"\f[]
.IP \[bu] 2
\f[C]"100"\f[]
.IP \[bu] 2
\f[C]"1000"\f[]
.SS RelativeTolerance
.SS Description
.PP
If the method is iterative, terminate the loop when the cost function
changes between successive iterations by this amount or less.
The magnitude of the cost function will generally depend on the number
of points (in both point clouds), the scale (i.e., `width') of the point
clouds, the amount of noise and outlier points, and any method\-specific
parameters that impact the cost function (if applicable); use of this
tolerance parameter may be impacted by these characteristics.
Verifying that a given tolerance is of appropriate magnitude is
recommended.
Relative tolerance checks can be disabled by setting to non\-finite or
negative value.
Note that this parameter will only have effect on iterative methods that
are not controlled by, e.g., an annealing schedule.
.SS Default
.IP \[bu] 2
\f[C]"nan"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"1E\-2"\f[]
.IP \[bu] 2
\f[C]"1E\-3"\f[]
.IP \[bu] 2
\f[C]"1E\-5"\f[]
.SS ExtractRadiomicFeatures
.SS Description
.PP
This operation extracts radiomic features from the selected images.
Features are implemented as per specification in the Image Biomarker
Standardisation Initiative (IBSI) or pyradiomics documentation if the
IBSI specification is unclear or ambiguous.
.SS Notes
.IP \[bu] 2
This routine is meant to be processed by an external analysis.
.IP \[bu] 2
If this routine is slow, simplifying ROI contours may help speed
surface\-mesh\-based feature extraction.
Often removing the highest\-frequency components of the contour will
help, such as edges that conform tightly to individual voxels.
.SS Parameters
.IP \[bu] 2
UserComment
.IP \[bu] 2
FeaturesFileName
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.SS FeaturesFileName
.SS Description
.PP
Features will be appended to this file.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
If an existing file is present, rows will be appended without writing a
header.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS FVPicketFence
.SS Description
.PP
This operation performs a picket fence QA test using an RTIMAGE file.
.SS Notes
.IP \[bu] 2
This is a `simplified' version of the full picket fence analysis program
that uses defaults that are expected to be reasonable across a wide
range of scenarios.
.SS Parameters
.IP \[bu] 2
ROILabel
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Channel
.IP \[bu] 2
Replacement
.IP \[bu] 2
Replace
.IP \[bu] 2
NeighbourCount
.IP \[bu] 2
AgreementCount
.IP \[bu] 2
MaxDistance
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
DICOMMargin
.IP \[bu] 2
RTIMAGE
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
RowsL
.IP \[bu] 2
RowsH
.IP \[bu] 2
ColumnsL
.IP \[bu] 2
ColumnsH
.IP \[bu] 2
DICOMMargin
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
MLCModel
.IP \[bu] 2
MLCROILabel
.IP \[bu] 2
JunctionROILabel
.IP \[bu] 2
PeakROILabel
.IP \[bu] 2
MinimumJunctionSeparation
.IP \[bu] 2
ThresholdDistance
.IP \[bu] 2
LeafGapsFileName
.IP \[bu] 2
ResultsSummaryFileName
.IP \[bu] 2
UserComment
.IP \[bu] 2
InteractivePlots
.IP \[bu] 2
ScaleFactor
.IP \[bu] 2
ImageFileName
.IP \[bu] 2
ColourMapRegex
.IP \[bu] 2
WindowLow
.IP \[bu] 2
WindowHigh
.SS ROILabel
.SS Description
.PP
A label to attach to the ROI contours.
.SS Default
.IP \[bu] 2
\f[C]"entire_image"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"everything"\f[]
.IP \[bu] 2
\f[C]"whole_images"\f[]
.IP \[bu] 2
\f[C]"unspecified"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"entire_image"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Channel
.SS Description
.PP
The channel to operated on (zero\-based).
Negative values will cause all channels to be operated on.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.SS Replacement
.SS Description
.PP
Controls how replacements are generated.
`Mean' and `median' replacement strategies replace the voxel value with
the mean and median, respectively, from the surrounding neighbourhood.
`Conservative' refers to the so\-called conservative filter that
suppresses isolated peaks; for every voxel considered, the voxel
intensity is clamped to the local neighbourhood's extrema.
This filter works best for removing spurious peak and trough voxels and
performs no averaging.
A numeric value can also be supplied, which will replace all isolated or
well\-connected voxels.
.SS Default
.IP \[bu] 2
\f[C]"conservative"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"mean"\f[]
.IP \[bu] 2
\f[C]"median"\f[]
.IP \[bu] 2
\f[C]"conservative"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1.23"\f[]
.IP \[bu] 2
\f[C]"1E6"\f[]
.IP \[bu] 2
\f[C]"nan"\f[]
.SS Replace
.SS Description
.PP
Controls whether isolated or well\-connected voxels are retained.
.SS Default
.IP \[bu] 2
\f[C]"isolated"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"isolated"\f[]
.IP \[bu] 2
\f[C]"well\-connected"\f[]
.SS NeighbourCount
.SS Description
.PP
Controls the number of neighbours being considered.
For purposes of speed, this option is limited to specific levels of
neighbour adjacency.
.SS Default
.IP \[bu] 2
\f[C]"isolated"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.SS AgreementCount
.SS Description
.PP
Controls the number of neighbours that must be in agreement for a voxel
to be considered `well\-connected.'
.SS Default
.IP \[bu] 2
\f[C]"6"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"25"\f[]
.SS MaxDistance
.SS Description
.PP
The maximum distance (inclusive, in DICOM units: mm) within which
neighbouring voxels will be evaluated.
For spherical neighbourhoods, this distance refers to the radius.
For cubic neighbourhoods, this distance refers to `box radius' or the
distance from the cube centre to the nearest point on each bounding
face.
Voxels separated by more than this distance will not be evaluated
together.
.SS Default
.IP \[bu] 2
\f[C]"2.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"15.0"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS DICOMMargin
.SS Description
.PP
The amount of margin (in the DICOM coordinate system) to spare from
cropping.
.SS Default
.IP \[bu] 2
\f[C]"0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"\-0.5"\f[]
.IP \[bu] 2
\f[C]"20.0"\f[]
.SS RTIMAGE
.SS Description
.PP
If true, attempt to crop the image using information embedded in an
RTIMAGE.
This option cannot be used with the other options.
.SS Default
.IP \[bu] 2
\f[C]"true"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS RowsL
.SS Description
.PP
The number of rows to remove, starting with the first row.
Can be absolute (px), percentage (%), or distance in terms of the DICOM
coordinate system.
Note the DICOM coordinate system can be flipped, so the first row can be
either on the top or bottom of the image.
.SS Default
.IP \[bu] 2
\f[C]"5px"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0px"\f[]
.IP \[bu] 2
\f[C]"10px"\f[]
.IP \[bu] 2
\f[C]"100px"\f[]
.IP \[bu] 2
\f[C]"15%"\f[]
.IP \[bu] 2
\f[C]"15.75%"\f[]
.IP \[bu] 2
\f[C]"123.45"\f[]
.SS RowsH
.SS Description
.PP
The number of rows to remove, starting with the last row.
Can be absolute (px), percentage (%), or distance in terms of the DICOM
coordinate system.
Note the DICOM coordinate system can be flipped, so the first row can be
either on the top or bottom of the image.
.SS Default
.IP \[bu] 2
\f[C]"5px"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0px"\f[]
.IP \[bu] 2
\f[C]"10px"\f[]
.IP \[bu] 2
\f[C]"100px"\f[]
.IP \[bu] 2
\f[C]"15%"\f[]
.IP \[bu] 2
\f[C]"15.75%"\f[]
.IP \[bu] 2
\f[C]"123.45"\f[]
.SS ColumnsL
.SS Description
.PP
The number of columns to remove, starting with the first column.
Can be absolute (px), percentage (%), or distance in terms of the DICOM
coordinate system.
Note the DICOM coordinate system can be flipped, so the first column can
be either on the top or bottom of the image.
.SS Default
.IP \[bu] 2
\f[C]"5px"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0px"\f[]
.IP \[bu] 2
\f[C]"10px"\f[]
.IP \[bu] 2
\f[C]"100px"\f[]
.IP \[bu] 2
\f[C]"15%"\f[]
.IP \[bu] 2
\f[C]"15.75%"\f[]
.IP \[bu] 2
\f[C]"123.45"\f[]
.SS ColumnsH
.SS Description
.PP
The number of columns to remove, starting with the last column.
Can be absolute (px), percentage (%), or distance in terms of the DICOM
coordinate system.
Note the DICOM coordinate system can be flipped, so the first column can
be either on the top or bottom of the image.
.SS Default
.IP \[bu] 2
\f[C]"5px"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0px"\f[]
.IP \[bu] 2
\f[C]"10px"\f[]
.IP \[bu] 2
\f[C]"100px"\f[]
.IP \[bu] 2
\f[C]"15%"\f[]
.IP \[bu] 2
\f[C]"15.75%"\f[]
.IP \[bu] 2
\f[C]"123.45"\f[]
.SS DICOMMargin
.SS Description
.PP
The amount of margin (in the DICOM coordinate system) to spare from
cropping.
.SS Default
.IP \[bu] 2
\f[C]"0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"\-0.5"\f[]
.IP \[bu] 2
\f[C]"20.0"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS MLCModel
.SS Description
.PP
The MLC design geometry to use.
`VarianMillenniumMLC80' has 40 leafs in each bank; leaves are 10mm wide
at isocentre; and the maximum static field size is 40cm x 40cm.
`VarianMillenniumMLC120' has 60 leafs in each bank; the 40 central
leaves are 5mm wide at isocentre; the 20 peripheral leaves are 10mm
wide; and the maximum static field size is 40cm x 40cm.
`VarianHD120' has 60 leafs in each bank; the 32 central leaves are 2.5mm
wide at isocentre; the 28 peripheral leaves are 5mm wide; and the
maximum static field size is 40cm x 22cm.
.SS Default
.IP \[bu] 2
\f[C]"VarianMillenniumMLC120"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"VarianMillenniumMLC80"\f[]
.IP \[bu] 2
\f[C]"VarianMillenniumMLC120"\f[]
.IP \[bu] 2
\f[C]"VarianHD120"\f[]
.SS MLCROILabel
.SS Description
.PP
An ROI imitating the MLC axes of leaf pairs is created.
This is the label to apply to it.
Note that the leaves are modeled with thin contour rectangles of
virtually zero area.
Also note that the outline colour is significant and denotes leaf pair
pass/fail.
.SS Default
.IP \[bu] 2
\f[C]"Leaves"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"MLC_leaves"\f[]
.IP \[bu] 2
\f[C]"MLC"\f[]
.IP \[bu] 2
\f[C]"approx_leaf_axes"\f[]
.SS JunctionROILabel
.SS Description
.PP
An ROI imitating the junction is created.
This is the label to apply to it.
Note that the junctions are modeled with thin contour rectangles of
virtually zero area.
.SS Default
.IP \[bu] 2
\f[C]"Junction"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Junction"\f[]
.IP \[bu] 2
\f[C]"Picket_Fence_Junction"\f[]
.SS PeakROILabel
.SS Description
.PP
ROIs encircling the leaf profile peaks are created.
This is the label to apply to it.
Note that the peaks are modeled with small squares.
.SS Default
.IP \[bu] 2
\f[C]"Peak"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Peak"\f[]
.IP \[bu] 2
\f[C]"Picket_Fence_Peak"\f[]
.SS MinimumJunctionSeparation
.SS Description
.PP
The minimum distance between junctions on the SAD isoplane in DICOM
units (mm).
This number is used to de\-duplicate automatically detected junctions.
Analysis results should not be sensitive to the specific value.
.SS Default
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"5.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.IP \[bu] 2
\f[C]"15.0"\f[]
.IP \[bu] 2
\f[C]"25.0"\f[]
.SS ThresholdDistance
.SS Description
.PP
The threshold distance in DICOM units (mm) above which MLC separations
are considered to `fail'.
Each leaf pair is evaluated separately.
Pass/fail status is also indicated by setting the leaf axis contour
colour (blue for pass, red for fail).
.SS Default
.IP \[bu] 2
\f[C]"0.5"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.SS LeafGapsFileName
.SS Description
.PP
This file will contain gap and nominal\-vs\-actual offset distances for
each leaf pair.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
If an existing file is present, rows will be appended without writing a
header.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS ResultsSummaryFileName
.SS Description
.PP
This file will contain a brief summary of the results.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
If an existing file is present, rows will be appended without writing a
header.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.SS InteractivePlots
.SS Description
.PP
Whether to interactively show plots showing detected edges.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS ScaleFactor
.SS Description
.PP
This factor is applied to the image width and height to magnify (larger
than 1) or shrink (less than 1) the image.
This factor only affects the output image size.
Note that aspect ratio is retained, but rounding for non\-integer
factors may lead to small (1\-2 pixel) discrepancies.
.SS Default
.IP \[bu] 2
\f[C]"1.5"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"5.23"\f[]
.SS ImageFileName
.SS Description
.PP
The file name to use for the image.
If blank, a filename will be generated sequentially.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/an_image.png"\f[]
.IP \[bu] 2
\f[C]"afile.png"\f[]
.SS ColourMapRegex
.SS Description
.PP
The colour mapping to apply to the image if there is a single channel.
The default will match the first available, and if there is no matching
map found, the first available will be selected.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Viridis"\f[]
.IP \[bu] 2
\f[C]"Magma"\f[]
.IP \[bu] 2
\f[C]"Plasma"\f[]
.IP \[bu] 2
\f[C]"Inferno"\f[]
.IP \[bu] 2
\f[C]"Jet"\f[]
.IP \[bu] 2
\f[C]"MorelandBlueRed"\f[]
.IP \[bu] 2
\f[C]"MorelandBlackBody"\f[]
.IP \[bu] 2
\f[C]"MorelandExtendedBlackBody"\f[]
.IP \[bu] 2
\f[C]"KRC"\f[]
.IP \[bu] 2
\f[C]"ExtendedKRC"\f[]
.IP \[bu] 2
\f[C]"Kovesi_LinKRYW_5\-100_c64"\f[]
.IP \[bu] 2
\f[C]"Kovesi_LinKRYW_0\-100_c71"\f[]
.IP \[bu] 2
\f[C]"Kovesi_Cyclic_cet\-c2"\f[]
.IP \[bu] 2
\f[C]"LANLOliveGreentoBlue"\f[]
.IP \[bu] 2
\f[C]"YgorIncandescent"\f[]
.IP \[bu] 2
\f[C]"LinearRamp"\f[]
.SS WindowLow
.SS Description
.PP
If provided, this parameter will override any existing window and level.
All pixels with the intensity value or lower will be assigned the lowest
possible colour according to the colour map.
Not providing a valid number will disable window overrides.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"\-1.23"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1E4"\f[]
.SS WindowHigh
.SS Description
.PP
If provided, this parameter will override any existing window and level.
All pixels with the intensity value or higher will be assigned the
highest possible colour according to the colour map.
Not providing a valid number will disable window overrides.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"10.3E4"\f[]
.SS GenerateCalibrationCurve
.SS Description
.PP
This operation uses two overlapping images volumes to generate a
calibration curve mapping from the first image volume to the second.
Only the region within the specified ROI(s) is considered.
.SS Notes
.IP \[bu] 2
ROI(s) are interpretted relative to the mapped\-to (`reference' or
`fixed') image.
The reason for this is that typically the reference images are
associated with contours (e.g., planning data) and the mapped\-from
images do not (e.g., CBCTs that have been registered).
.IP \[bu] 2
This routine can handle overlapping or duplicate contours.
.SS Parameters
.IP \[bu] 2
Channel
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
RefImageSelection
.IP \[bu] 2
ContourOverlap
.IP \[bu] 2
Inclusivity
.IP \[bu] 2
CalibCurveFileName
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.SS Channel
.SS Description
.PP
The image channel to use.
Zero\-based.
Use `\-1' to operate on all available channels.
.SS Default
.IP \[bu] 2
\f[C]"\-1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
Note that these images are the `mapped\-from' or `moving' images.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS RefImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
Note that these images are the `mapped\-to' or `fixed' images.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ContourOverlap
.SS Description
.PP
Controls overlapping contours are treated.
The default `ignore' treats overlapping contours as a single contour,
regardless of contour orientation.
The option `honour_opposite_orientations' makes overlapping contours
with opposite orientation cancel.
Otherwise, orientation is ignored.
The latter is useful for Boolean structures where contour orientation is
significant for interior contours (holes).
The option `overlapping_contours_cancel' ignores orientation and cancels
all contour overlap.
.SS Default
.IP \[bu] 2
\f[C]"ignore"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"ignore"\f[]
.IP \[bu] 2
\f[C]"honour_opposite_orientations"\f[]
.IP \[bu] 2
\f[C]"overlapping_contours_cancel"\f[]
.IP \[bu] 2
\f[C]"honour_opps"\f[]
.IP \[bu] 2
\f[C]"overlap_cancel"\f[]
.SS Inclusivity
.SS Description
.PP
Controls how voxels are deemed to be `within' the interior of the
selected ROI(s).
The default `center' considers only the central\-most point of each
voxel.
There are two corner options that correspond to a 2D projection of the
voxel onto the image plane.
The first, `planar_corner_inclusive', considers a voxel interior if ANY
corner is interior.
The second, `planar_corner_exclusive', considers a voxel interior if ALL
(four) corners are interior.
.SS Default
.IP \[bu] 2
\f[C]"center"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"center"\f[]
.IP \[bu] 2
\f[C]"centre"\f[]
.IP \[bu] 2
\f[C]"planar_corner_inclusive"\f[]
.IP \[bu] 2
\f[C]"planar_inc"\f[]
.IP \[bu] 2
\f[C]"planar_corner_exclusive"\f[]
.IP \[bu] 2
\f[C]"planar_exc"\f[]
.SS CalibCurveFileName
.SS Description
.PP
The file to which a calibration curve will be written to.
The format is line\-based with 4 numbers per line: (original pixel
value) (uncertainty) (new pixel value) (uncertainty).
Uncertainties refer to the prior number and may be uniformly zero if
unknown.
Lines beginning with `#' are comments.
The curve is meant to be interpolated.
(Later attempts to extrapolate may result in failure.)
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"./calib.dat"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS GenerateSurfaceMask
.SS Description
.PP
This operation generates a surface image mask, which contains
information about whether each voxel is within, on, or outside the
selected ROI(s).
.SS Parameters
.IP \[bu] 2
BackgroundVal
.IP \[bu] 2
InteriorVal
.IP \[bu] 2
SurfaceVal
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.SS BackgroundVal
.SS Description
.PP
The value to give to voxels neither inside nor on the surface of the
ROI(s).
.SS Default
.IP \[bu] 2
\f[C]"0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1.0"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"2.34E26"\f[]
.SS InteriorVal
.SS Description
.PP
The value to give to voxels within the volume of the ROI(s) but not on
the surface.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1.0"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"2.34E26"\f[]
.SS SurfaceVal
.SS Description
.PP
The value to give to voxels on the surface/boundary of ROI(s).
.SS Default
.IP \[bu] 2
\f[C]"2.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1.0"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"2.34E26"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS GenerateSyntheticImages
.SS Description
.PP
This operation generates a synthetic, regular bitmap image array.
It can be used for testing how images are quantified or transformed.
.SS Parameters
.IP \[bu] 2
NumberOfImages
.IP \[bu] 2
NumberOfRows
.IP \[bu] 2
NumberOfColumns
.IP \[bu] 2
NumberOfChannels
.IP \[bu] 2
SliceThickness
.IP \[bu] 2
SpacingBetweenSlices
.IP \[bu] 2
VoxelWidth
.IP \[bu] 2
VoxelHeight
.IP \[bu] 2
ImageAnchor
.IP \[bu] 2
ImagePosition
.IP \[bu] 2
ImageOrientationColumn
.IP \[bu] 2
ImageOrientationRow
.IP \[bu] 2
InstanceNumber
.IP \[bu] 2
AcquisitionNumber
.IP \[bu] 2
VoxelValue
.IP \[bu] 2
StipleValue
.IP \[bu] 2
Metadata
.SS NumberOfImages
.SS Description
.PP
The number of images to create.
.SS Default
.IP \[bu] 2
\f[C]"100"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"100"\f[]
.IP \[bu] 2
\f[C]"1000"\f[]
.SS NumberOfRows
.SS Description
.PP
The number of rows each image should contain.
.SS Default
.IP \[bu] 2
\f[C]"256"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"100"\f[]
.IP \[bu] 2
\f[C]"1000"\f[]
.SS NumberOfColumns
.SS Description
.PP
The number of columns each image should contain.
.SS Default
.IP \[bu] 2
\f[C]"256"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"100"\f[]
.IP \[bu] 2
\f[C]"1000"\f[]
.SS NumberOfChannels
.SS Description
.PP
The number of channels each image should contain.
.SS Default
.IP \[bu] 2
\f[C]"1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"100"\f[]
.SS SliceThickness
.SS Description
.PP
Image slices will be have this thickness (in DICOM units: mm).
For most purposes, SliceThickness should be equal to
SpacingBetweenSlices.
If SpacingBetweenSlices is smaller than SliceThickness, images will
overlap.
If SpacingBetweenSlices is larger than SliceThickness, there will be a
gap between images.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS SpacingBetweenSlices
.SS Description
.PP
Image slice centres will be separated by this distance (in DICOM units:
mm).
For most purposes, SpacingBetweenSlices should be equal to
SliceThickness.
If SpacingBetweenSlices is smaller than SliceThickness, images will
overlap.
If SpacingBetweenSlices is larger than SliceThickness, there will be a
gap between images.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS VoxelWidth
.SS Description
.PP
Voxels will have this (in\-plane) width (in DICOM units: mm).
This means that row\-adjacent voxels centres will be separated by
VoxelWidth).
Each voxel will have dimensions: VoxelWidth x VoxelHeight x
SliceThickness.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS VoxelHeight
.SS Description
.PP
Voxels will have this (in\-plane) height (in DICOM units: mm).
This means that column\-adjacent voxels centres will be separated by
VoxelHeight).
Each voxel will have dimensions: VoxelWidth x VoxelHeight x
SliceThickness.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS ImageAnchor
.SS Description
.PP
A point in 3D space which denotes the origin (in DICOM units: mm).
All other vectors are taken to be relative to this point.
Under most circumstance the anchor should be (0,0,0).
Specify coordinates separated by commas.
.SS Default
.IP \[bu] 2
\f[C]"0.0,\ 0.0,\ 0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0,\ 0.0,\ 0.0"\f[]
.IP \[bu] 2
\f[C]"0.0,0.0,0.0"\f[]
.IP \[bu] 2
\f[C]"1.0,\ \-2.3,\ 45.6"\f[]
.SS ImagePosition
.SS Description
.PP
The centre of the row=0, column=0 voxel in the first image (in DICOM
units: mm).
Specify coordinates separated by commas.
.SS Default
.IP \[bu] 2
\f[C]"0.0,\ 0.0,\ 0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0,\ 0.0,\ 0.0"\f[]
.IP \[bu] 2
\f[C]"100.0,100.0,100.0"\f[]
.IP \[bu] 2
\f[C]"1.0,\ \-2.3,\ 45.6"\f[]
.SS ImageOrientationColumn
.SS Description
.PP
The orientation unit vector that is aligned with image columns.
Care should be taken to ensure ImageOrientationRow and
ImageOrientationColumn are orthogonal.
(A Gram\-Schmidt orthogonalization procedure ensures they are, but the
image orientation may not match the expected orientation.) Note that the
magnitude will also be scaled to unit length for convenience.
Specify coordinates separated by commas.
.SS Default
.IP \[bu] 2
\f[C]"1.0,\ 0.0,\ 0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.0,\ 0.0,\ 0.0"\f[]
.IP \[bu] 2
\f[C]"1.0,\ 1.0,\ 0.0"\f[]
.IP \[bu] 2
\f[C]"0.0,\ 0.0,\ \-1.0"\f[]
.SS ImageOrientationRow
.SS Description
.PP
The orientation unit vector that is aligned with image rows.
Care should be taken to ensure ImageOrientationRow and
ImageOrientationColumn are orthogonal.
(A Gram\-Schmidt orthogonalization procedure ensures they are, but the
image orientation may not match the expected orientation.) Note that the
magnitude will also be scaled to unit length for convenience.
Specify coordinates separated by commas.
.SS Default
.IP \[bu] 2
\f[C]"0.0,\ 1.0,\ 0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0,\ 1.0,\ 0.0"\f[]
.IP \[bu] 2
\f[C]"0.0,\ 1.0,\ 1.0"\f[]
.IP \[bu] 2
\f[C]"\-1.0,\ 0.0,\ 0.0"\f[]
.SS InstanceNumber
.SS Description
.PP
A number affixed to the first image, and then incremented and affixed
for each subsequent image.
.SS Default
.IP \[bu] 2
\f[C]"1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"100"\f[]
.IP \[bu] 2
\f[C]"1234"\f[]
.SS AcquisitionNumber
.SS Description
.PP
A number affixed to all images, meant to indicate membership in a single
acquisition.
.SS Default
.IP \[bu] 2
\f[C]"1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"100"\f[]
.IP \[bu] 2
\f[C]"1234"\f[]
.SS VoxelValue
.SS Description
.PP
The value that is assigned to all voxels, or possibly every other voxel.
Note that if StipleValue is given a finite value, only half the voxels
will be assigned a value of VoxelValue and the other half will be
assigned a value of StipleValue.
This produces a checkerboard pattern.
.SS Default
.IP \[bu] 2
\f[C]"0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"1.0E4"\f[]
.IP \[bu] 2
\f[C]"\-1234"\f[]
.IP \[bu] 2
\f[C]"nan"\f[]
.SS StipleValue
.SS Description
.PP
The value that is assigned to every other voxel.
If StipleValue is given a finite value, half of all voxels will be
assigned a value of VoxelValue and the other half will be assigned a
value of StipleValue.
This produces a checkerboard pattern.
.SS Default
.IP \[bu] 2
\f[C]"nan"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"\-1.0E4"\f[]
.IP \[bu] 2
\f[C]"1234"\f[]
.SS Metadata
.SS Description
.PP
A semicolon\-separated list of `key\@value' metadata to imbue into each
image.
This metadata will overwrite any existing keys with the provided values.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"keyA\@valueA;keyB\@valueB"\f[]
.SS GenerateVirtualDataContourViaThresholdTestV1
.SS Description
.PP
This operation generates data suitable for testing the
ContourViaThreshold operation.
.SS Parameters
.PP
No registered options.
.SS GenerateVirtualDataDoseStairsV1
.SS Description
.PP
This operation generates a dosimetric stairway.
It can be used for testing how dosimetric data is transformed.
.SS Parameters
.PP
No registered options.
.SS GenerateVirtualDataImageSphereV1
.SS Description
.PP
This operation generates a bitmap image of a sphere.
It can be used for testing how images are quantified or transformed.
.SS Parameters
.PP
No registered options.
.SS GenerateVirtualDataPerfusionV1
.SS Description
.PP
This operation generates data suitable for testing perfusion modeling
operations.
There are no specific checks in this code.
Another operation performs the actual validation.
You might be able to manually verify if the perfusion model admits a
simple solution.
.SS Parameters
.PP
No registered options.
.SS GiveWholeImageArrayABoneWindowLevel
.SS Description
.PP
This operation runs the images in an image array through a uniform
window\-and\-leveler instead of per\-slice window\-and\-level or no
window\-and\-level at all.
Data is modified and no copy is made!
.SS Parameters
.PP
No registered options.
.SS GiveWholeImageArrayAHeadAndNeckWindowLevel
.SS Description
.PP
This operation runs the images in an image array through a uniform
window\-and\-leveler instead of per\-slice window\-and\-level or no
window\-and\-level at all.
Data is modified and no copy is made!
.SS Parameters
.PP
No registered options.
.SS GiveWholeImageArrayAThoraxWindowLevel
.SS Description
.PP
This operation runs the images in an image array through a uniform
window\-and\-leveler instead of per\-slice window\-and\-level or no
window\-and\-level at all.
Data is modified and no copy is made!
.SS Parameters
.PP
No registered options.
.SS GiveWholeImageArrayAnAbdominalWindowLevel
.SS Description
.PP
This operation runs the images in an image array through a uniform
window\-and\-leveler instead of per\-slice window\-and\-level or no
window\-and\-level at all.
Data is modified and no copy is made!
.SS Parameters
.PP
No registered options.
.SS GiveWholeImageArrayAnAlphaBetaWindowLevel
.SS Description
.PP
This operation runs the images in an image array through a uniform
window\-and\-leveler instead of per\-slice window\-and\-level or no
window\-and\-level at all.
Data is modified and no copy is made!
.SS Parameters
.PP
No registered options.
.SS GridBasedRayCastDoseAccumulate
.SS Description
.PP
This operation performs a ray casting to estimate the surface dose of an
ROI.
.SS Parameters
.IP \[bu] 2
DoseMapFileName
.IP \[bu] 2
DoseLengthMapFileName
.IP \[bu] 2
LengthMapFileName
.IP \[bu] 2
NormalizedReferenceROILabelRegex
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ReferenceROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
SmallestFeature
.IP \[bu] 2
RaydL
.IP \[bu] 2
GridRows
.IP \[bu] 2
GridColumns
.IP \[bu] 2
SourceDetectorRows
.IP \[bu] 2
SourceDetectorColumns
.IP \[bu] 2
NumberOfImages
.SS DoseMapFileName
.SS Description
.PP
A filename (or full path) for the dose image map.
Note that this file is approximate, and may not be accurate.
There is more information available when you use the length and
dose*length maps instead.
However, this file is useful for viewing and eyeballing tuning settings.
The format is FITS.
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/dose.fits"\f[]
.IP \[bu] 2
\f[C]"localfile.fits"\f[]
.IP \[bu] 2
\f[C]"derivative_data.fits"\f[]
.SS DoseLengthMapFileName
.SS Description
.PP
A filename (or full path) for the (dose)*(length traveled through the
ROI peel) image map.
The format is FITS.
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/doselength.fits"\f[]
.IP \[bu] 2
\f[C]"localfile.fits"\f[]
.IP \[bu] 2
\f[C]"derivative_data.fits"\f[]
.SS LengthMapFileName
.SS Description
.PP
A filename (or full path) for the (length traveled through the ROI peel)
image map.
The format is FITS.
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/surfacelength.fits"\f[]
.IP \[bu] 2
\f[C]"localfile.fits"\f[]
.IP \[bu] 2
\f[C]"derivative_data.fits"\f[]
.SS NormalizedReferenceROILabelRegex
.SS Description
.PP
A regex matching reference ROI labels/names to consider.
The default will match all available ROIs, which is non\-sensical.
The reference ROI is used to orient the cleaving plane to trim the grid
surface mask.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Prostate.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Kidney"\f[]
.IP \[bu] 2
\f[C]"Gross\ Liver"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ReferenceROILabelRegex
.SS Description
.PP
A regex matching reference ROI labels/names to consider.
The default will match all available ROIs, which is non\-sensical.
The reference ROI is used to orient the cleaving plane to trim the grid
surface mask.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*[pP]rostate.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS SmallestFeature
.SS Description
.PP
A length giving an estimate of the smallest feature you want to resolve.
Quantity is in the DICOM coordinate system.
.SS Default
.IP \[bu] 2
\f[C]"0.5"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"5.0"\f[]
.SS RaydL
.SS Description
.PP
The distance to move a ray each iteration.
Should be << img_thickness and << cylinder_radius.
Making too large will invalidate results, causing rays to pass through
the surface without registering any dose accumulation.
Making too small will cause the run\-time to grow and may eventually
lead to truncation or round\-off errors.
Quantity is in the DICOM coordinate system.
.SS Default
.IP \[bu] 2
\f[C]"0.1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"0.05"\f[]
.IP \[bu] 2
\f[C]"0.01"\f[]
.IP \[bu] 2
\f[C]"0.005"\f[]
.SS GridRows
.SS Description
.PP
The number of rows in the surface mask grid images.
.SS Default
.IP \[bu] 2
\f[C]"512"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"50"\f[]
.IP \[bu] 2
\f[C]"128"\f[]
.IP \[bu] 2
\f[C]"1024"\f[]
.SS GridColumns
.SS Description
.PP
The number of columns in the surface mask grid images.
.SS Default
.IP \[bu] 2
\f[C]"512"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"50"\f[]
.IP \[bu] 2
\f[C]"128"\f[]
.IP \[bu] 2
\f[C]"1024"\f[]
.SS SourceDetectorRows
.SS Description
.PP
The number of rows in the resulting images.
Setting too fine relative to the surface mask grid or dose grid is
futile.
.SS Default
.IP \[bu] 2
\f[C]"1024"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"50"\f[]
.IP \[bu] 2
\f[C]"128"\f[]
.IP \[bu] 2
\f[C]"1024"\f[]
.SS SourceDetectorColumns
.SS Description
.PP
The number of columns in the resulting images.
Setting too fine relative to the surface mask grid or dose grid is
futile.
.SS Default
.IP \[bu] 2
\f[C]"1024"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"50"\f[]
.IP \[bu] 2
\f[C]"128"\f[]
.IP \[bu] 2
\f[C]"1024"\f[]
.SS NumberOfImages
.SS Description
.PP
The number of images used for grid\-based surface detection.
Leave negative for computation of a reasonable value; set to something
specific to force an override.
.SS Default
.IP \[bu] 2
\f[C]"\-1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"50"\f[]
.IP \[bu] 2
\f[C]"100"\f[]
.SS GroupImages
.SS Description
.PP
This operation will group individual image slices into partitions
(Image_Arrays) based on the values of the specified metadata tags.
DICOMautomaton operations are usually performed on containers rather
than individual images, and grouping can express connections between
images.
For example a group could contain the scans belonging to a whole study,
one of the series in a study, individual image volumes within a single
series (e.g., a 3D volume in a temporal perfusion scan), or individual
slices.
A group could also contain all the slices that intersect a given plane,
or were taken on a specified StationName.
.SS Notes
.IP \[bu] 2
Images are moved, not copied.
.IP \[bu] 2
Image order within a group is retained (i.e., stable grouping), but
groups are appended to the back of the Image_Array list according to the
default sort for the group's key\-value value.
.IP \[bu] 2
Images that do not contain the specified metadata will be grouped into a
special N/A group at the end.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
KeysCommon
.IP \[bu] 2
Enforce
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS KeysCommon
.SS Description
.PP
Image metadata keys to use for exact\-match groupings.
For each group that is produced, every image will share the same
key\-value pair.
This is generally useful for non\-numeric (or integer, date, etc.)
key\-values.
A `;'\-delimited list can be specified to group on multiple criteria
simultaneously.
An empty string disables metadata\-based grouping.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"SeriesNumber"\f[]
.IP \[bu] 2
\f[C]"BodyPartExamined;StudyDate"\f[]
.IP \[bu] 2
\f[C]"SeriesInstanceUID"\f[]
.IP \[bu] 2
\f[C]"StationName"\f[]
.SS Enforce
.SS Description
.PP
Other specialized grouping operations that involve custom logic.
Currently, only `no\-overlap' is available, but it has two variants.
Both partition based on the spatial extent of images; in each
non\-overlapping partition, no two images will spatially overlap.
`No\-overlap\-as\-is' will effectively insert partitions without
altering the order.
A partition is inserted when an image is found to overlap with an image
already within the partition.
For this grouping to be useful, images must be sorted so that partitions
can be inserted without any necessary reordering.
An example of when this grouping is useful is CT shuttling in which the
ordering of images alternate between increasing and decreasing
SliceNumber.
Note that, depending on the ordering, some partitions may therefore be
incomplete.
`No\-overlap\-adjust' will rearrange images so that the first partition
is always complete.
This is achieved by building a queue of spatially\-overlapping images
and greedily stealing one of each kind when constructing partitions.
An example of when this grouping is useful are 4DCTs which have been
acquired for all phases while the couch remains at a single SliceNumber;
the images are ordered on disk in the acquisition order (i.e., alike
SliceNumbers are bunched together) but the logical analysis order is
that each contiguous volume should represent a single phase.
An empty string disables logic\-based grouping.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"no\-overlap\-as\-is"\f[]
.IP \[bu] 2
\f[C]"no\-overlap\-adjust"\f[]
.SS GrowContours
.SS Description
.PP
This routine will grow (or shrink) 2D contours in their plane by the
specified amount.
Growth is accomplish by translating vertices away from the interior by
the specified amount.
The direction is chosen to be the direction opposite of the in\-plane
normal produced by averaging the line segments connecting the contours.
.SS Parameters
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Distance
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Distance
.SS Description
.PP
The distance to translate contour vertices.
(The direction is outward.)
.SS Default
.IP \[bu] 2
\f[C]"0.00354165798657632"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1E\-5"\f[]
.IP \[bu] 2
\f[C]"0.321"\f[]
.IP \[bu] 2
\f[C]"1.1"\f[]
.IP \[bu] 2
\f[C]"15.3"\f[]
.SS HighlightROIs
.SS Description
.PP
This operation overwrites voxel data inside and/or outside of ROI(s) to
`highlight' them.
It can handle overlapping or duplicate contours.
.SS Parameters
.IP \[bu] 2
Channel
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
ContourOverlap
.IP \[bu] 2
Inclusivity
.IP \[bu] 2
ExteriorVal
.IP \[bu] 2
InteriorVal
.IP \[bu] 2
ExteriorOverwrite
.IP \[bu] 2
InteriorOverwrite
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.SS Channel
.SS Description
.PP
The image channel to use.
Zero\-based.
Use `\-1' to operate on all available channels.
.SS Default
.IP \[bu] 2
\f[C]"\-1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ContourOverlap
.SS Description
.PP
Controls overlapping contours are treated.
The default `ignore' treats overlapping contours as a single contour,
regardless of contour orientation.
The option `honour_opposite_orientations' makes overlapping contours
with opposite orientation cancel.
Otherwise, orientation is ignored.
The latter is useful for Boolean structures where contour orientation is
significant for interior contours (holes).
The option `overlapping_contours_cancel' ignores orientation and cancels
all contour overlap.
.SS Default
.IP \[bu] 2
\f[C]"ignore"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"ignore"\f[]
.IP \[bu] 2
\f[C]"honour_opposite_orientations"\f[]
.IP \[bu] 2
\f[C]"overlapping_contours_cancel"\f[]
.IP \[bu] 2
\f[C]"honour_opps"\f[]
.IP \[bu] 2
\f[C]"overlap_cancel"\f[]
.SS Inclusivity
.SS Description
.PP
Controls how voxels are deemed to be `within' the interior of the
selected ROI(s).
The default `center' considers only the central\-most point of each
voxel.
There are two corner options that correspond to a 2D projection of the
voxel onto the image plane.
The first, `planar_corner_inclusive', considers a voxel interior if ANY
corner is interior.
The second, `planar_corner_exclusive', considers a voxel interior if ALL
(four) corners are interior.
.SS Default
.IP \[bu] 2
\f[C]"center"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"center"\f[]
.IP \[bu] 2
\f[C]"centre"\f[]
.IP \[bu] 2
\f[C]"planar_corner_inclusive"\f[]
.IP \[bu] 2
\f[C]"planar_inc"\f[]
.IP \[bu] 2
\f[C]"planar_corner_exclusive"\f[]
.IP \[bu] 2
\f[C]"planar_exc"\f[]
.SS ExteriorVal
.SS Description
.PP
The value to give to voxels outside the specified ROI(s).
Note that this value will be ignored if exterior overwrites are
disabled.
.SS Default
.IP \[bu] 2
\f[C]"0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1.0"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"2.34E26"\f[]
.SS InteriorVal
.SS Description
.PP
The value to give to voxels within the volume of the specified ROI(s).
Note that this value will be ignored if interior overwrites are
disabled.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1.0"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"2.34E26"\f[]
.SS ExteriorOverwrite
.SS Description
.PP
Whether to overwrite voxels exterior to the specified ROI(s).
.SS Default
.IP \[bu] 2
\f[C]"true"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS InteriorOverwrite
.SS Description
.PP
Whether to overwrite voxels interior to the specified ROI(s).
.SS Default
.IP \[bu] 2
\f[C]"true"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS ImageRoutineTests
.SS Description
.PP
This operation performs a series of sub\-operations that are generally
useful when inspecting an image.
.SS Parameters
.PP
No registered options.
.SS ImprintImages
.SS Description
.PP
This operation creates imprints of point clouds on the selected images.
Images are modified where the points are coindicident.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
PointSelection
.IP \[bu] 2
VoxelValue
.IP \[bu] 2
Channel
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS PointSelection
.SS Description
.PP
Select one or more point clouds.
Note that point clouds can hold a variety of data with varying
attributes, but each point cloud is meant to represent a single
logically cohesive collection of points.
Be aware that it is possible to mix logically unrelated points together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth point
cloud (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last point cloud.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS VoxelValue
.SS Description
.PP
The value to give voxels which are coincident with a point from the
point cloud.
Note that point cloud attributes, if present, may override this value.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1.0"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"nan"\f[]
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Channel
.SS Description
.PP
The image channel to use.
Zero\-based.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS InterpolateSlices
.SS Description
.PP
This operation interpolates the slices of an image array using a
reference image array, effectively performing trilinear interpolation.
This operation is meant to prepare image arrays to be compared or
operated on in a per\-voxel manner.
.SS Notes
.IP \[bu] 2
No images are overwritten by this operation.
The outgoing images will inherit (interpolated) voxel values from the
selected images and image geometry from the reference images.
.IP \[bu] 2
If all images (selected and reference, altogether) are detected to be
rectilinear, this operation will avoid in\-plane interpolation and will
thus be much faster.
There is no \f[B]need\f[] for rectilinearity, however without it
sections of the image that cannot reasonably be interpolated (via
plane\-orthogonal projection onto the reference images) will be invalid
and marked with NaNs.
Non\-rectilearity which amounts to a differing number of rows or columns
will merely be slower to interpolate.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
ReferenceImageSelection
.IP \[bu] 2
Channel
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ReferenceImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Channel
.SS Description
.PP
The channel to compare (zero\-based).
A negative value will result in all channels being interpolated,
otherwise unspecified channels are merely default initialized.
Note that both test images and reference images will share this
specifier.
.SS Default
.IP \[bu] 2
\f[C]"\-1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS IsolatedVoxelFilter
.SS Description
.PP
This routine applies a filter that discriminates between well\-connected
and isolated voxels.
Isolated voxels can either be filtered out or retained.
This operation considers the 3D neighbourhood surrounding a voxel.
.SS Notes
.IP \[bu] 2
The provided image collection must be rectilinear.
.IP \[bu] 2
If the neighbourhood involves voxels that do not exist, they are treated
as NaNs in the same way that voxels with the NaN value are treated.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Channel
.IP \[bu] 2
Replacement
.IP \[bu] 2
Replace
.IP \[bu] 2
NeighbourCount
.IP \[bu] 2
AgreementCount
.IP \[bu] 2
MaxDistance
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Channel
.SS Description
.PP
The channel to operated on (zero\-based).
Negative values will cause all channels to be operated on.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.SS Replacement
.SS Description
.PP
Controls how replacements are generated.
`Mean' and `median' replacement strategies replace the voxel value with
the mean and median, respectively, from the surrounding neighbourhood.
`Conservative' refers to the so\-called conservative filter that
suppresses isolated peaks; for every voxel considered, the voxel
intensity is clamped to the local neighbourhood's extrema.
This filter works best for removing spurious peak and trough voxels and
performs no averaging.
A numeric value can also be supplied, which will replace all isolated or
well\-connected voxels.
.SS Default
.IP \[bu] 2
\f[C]"mean"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"mean"\f[]
.IP \[bu] 2
\f[C]"median"\f[]
.IP \[bu] 2
\f[C]"conservative"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1.23"\f[]
.IP \[bu] 2
\f[C]"1E6"\f[]
.IP \[bu] 2
\f[C]"nan"\f[]
.SS Replace
.SS Description
.PP
Controls whether isolated or well\-connected voxels are retained.
.SS Default
.IP \[bu] 2
\f[C]"isolated"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"isolated"\f[]
.IP \[bu] 2
\f[C]"well\-connected"\f[]
.SS NeighbourCount
.SS Description
.PP
Controls the number of neighbours being considered.
For purposes of speed, this option is limited to specific levels of
neighbour adjacency.
.SS Default
.IP \[bu] 2
\f[C]"isolated"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.SS AgreementCount
.SS Description
.PP
Controls the number of neighbours that must be in agreement for a voxel
to be considered `well\-connected.'
.SS Default
.IP \[bu] 2
\f[C]"6"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"25"\f[]
.SS MaxDistance
.SS Description
.PP
The maximum distance (inclusive, in DICOM units: mm) within which
neighbouring voxels will be evaluated.
For spherical neighbourhoods, this distance refers to the radius.
For cubic neighbourhoods, this distance refers to `box radius' or the
distance from the cube centre to the nearest point on each bounding
face.
Voxels separated by more than this distance will not be evaluated
together.
.SS Default
.IP \[bu] 2
\f[C]"2.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"15.0"\f[]
.SS LoadFiles
.SS Description
.PP
This operation loads files on\-the\-fly.
.SS Notes
.IP \[bu] 2
This operation requires all files provided to it to exist and be
accessible.
Inaccessible files are not silently ignored and will cause this
operation to fail.
.SS Parameters
.IP \[bu] 2
FileName
.SS FileName
.SS Description
.PP
This file will be parsed and loaded.
All file types supported by the DICOMautomaton system can be loaded in
this way.
Currently this includes serialized Drover class files, DICOM files, FITS
image files, and XYZ point cloud files.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"/tmp/image.dcm"\f[]
.IP \[bu] 2
\f[C]"rois.dcm"\f[]
.IP \[bu] 2
\f[C]"dose.dcm"\f[]
.IP \[bu] 2
\f[C]"image.fits"\f[]
.IP \[bu] 2
\f[C]"point_cloud.xyz"\f[]
.SS LogScale
.SS Description
.PP
This operation log\-scales pixels for all available image arrays.
This functionality is often desired for viewing purposes, to make the
pixel level changes appear more linear.
Be weary of using for anything quantitative!
.SS Parameters
.IP \[bu] 2
ImageSelection
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS MakeMeshesManifold
.SS Description
.PP
This operation attempts to make non\-manifold surface meshes into
manifold meshes.
This operation is needed for operations requiring meshes to represent
polyhedra.
.SS Notes
.IP \[bu] 2
This routine will invalidate any imbued special attributes from the
original mesh.
.IP \[bu] 2
It may not be possible to accomplish manifold\-ness.
.IP \[bu] 2
Mesh features (vertices, faces, edges) may disappear in this routine.
.SS Parameters
.IP \[bu] 2
MeshLabel
.IP \[bu] 2
MeshSelection
.SS MeshLabel
.SS Description
.PP
A label to attach to the new manifold mesh.
.SS Default
.IP \[bu] 2
\f[C]"unspecified"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"unspecified"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"air"\f[]
.IP \[bu] 2
\f[C]"bone"\f[]
.IP \[bu] 2
\f[C]"invalid"\f[]
.IP \[bu] 2
\f[C]"above_zero"\f[]
.IP \[bu] 2
\f[C]"below_5.3"\f[]
.SS MeshSelection
.SS Description
.PP
Select one or more surface meshes.
Note that a single surface mesh may hold many disconnected mesh
components; they should collectively represent a single logically
cohesive object.
Be aware that it is possible to mix logically unrelated sub\-meshes
together in a single mesh.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth surface
mesh (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last surface mesh.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS MaxMinPixels
.SS Description
.PP
This operation replaces pixels with the pixel\-wise difference
(max)\-(min).
.SS Parameters
.PP
No registered options.
.SS MeldDose
.SS Description
.PP
This operation melds all available dose image data.
At a high level, dose melding sums overlapping pixel values for
multi\-part dose arrays.
For more information about what this specifically entails, refer to the
appropriate subroutine.
.SS Parameters
.PP
No registered options.
.SS MinkowskiSum3D
.SS Description
.PP
This operation computes a Minkowski sum or symmetric difference of a 3D
surface mesh generated from the selected ROIs with a sphere.
The effect is that a margin is added or subtracted to the ROIs, causing
them to `grow' outward or `shrink' inward.
Exact and inexact routines can be used.
.SS Parameters
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
Operation
.IP \[bu] 2
Distance
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses grep syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*parotid.*|.*sub.*mand.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid|eyes"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
Note that the selected images are used to sample the new contours on.
Image planes need not match the original since a full 3D mesh surface is
generated.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Operation
.SS Description
.PP
The specific operation to perform.
Available options are: `dilate_exact_surface', `dilate_exact_vertex',
`dilate_inexact_isotropic', `erode_inexact_isotropic', and
`shell_inexact_isotropic'.
.SS Default
.IP \[bu] 2
\f[C]"dilate_inexact_isotropic"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"dilate_exact_surface"\f[]
.IP \[bu] 2
\f[C]"dilate_exact_vertex"\f[]
.IP \[bu] 2
\f[C]"dilate_inexact_isotropic"\f[]
.IP \[bu] 2
\f[C]"erode_inexact_isotropic"\f[]
.IP \[bu] 2
\f[C]"shell_inexact_isotropic"\f[]
.SS Distance
.SS Description
.PP
For dilation and erosion operations, this parameter controls the
distance the surface should travel.
For shell operations, this parameter controls the resultant thickness of
the shell.
In all cases DICOM units are assumed.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"3.0"\f[]
.IP \[bu] 2
\f[C]"5.0"\f[]
.SS ModifyContourMetadata
.SS Description
.PP
This operation injects metadata into contours.
.SS Parameters
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
KeyValues
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS KeyValues
.SS Description
.PP
Key\-value pairs in the form of `key1\@value1;key2\@value2' that will be
injected into the selected images.
Existing metadata will be overwritten.
Both keys and values are case\-sensitive.
Note that a semi\-colon separates key\-value pairs, not a colon.
Note that quotation marks are not stripped internally, but may have to
be provided for the shell to properly interpret the argument.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Description\@\[aq]some\ description\[aq]"\f[]
.IP \[bu] 2
\f[C]"\[aq]Description\@some\ description\[aq]"\f[]
.IP \[bu] 2
\f[C]"MinimumSeparation\@1.23"\f[]
.IP \[bu] 2
\f[C]"\[aq]Description\@some\ description;MinimumSeparation\@1.23\[aq]"\f[]
.SS ModifyImageMetadata
.SS Description
.PP
This operation injects metadata into images.
It can also modify image spatial characteristics, which are distinct
from metadata.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
KeyValues
.IP \[bu] 2
SliceThickness
.IP \[bu] 2
VoxelWidth
.IP \[bu] 2
VoxelHeight
.IP \[bu] 2
ImageAnchor
.IP \[bu] 2
ImagePosition
.IP \[bu] 2
ImageOrientationColumn
.IP \[bu] 2
ImageOrientationRow
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS KeyValues
.SS Description
.PP
Key\-value pairs in the form of `key1\@value1;key2\@value2' that will be
injected into the selected images.
Existing metadata will be overwritten.
Both keys and values are case\-sensitive.
Note that a semi\-colon separates key\-value pairs, not a colon.
Note that quotation marks are not stripped internally, but may have to
be provided for the shell to properly interpret the argument.
Also note that updating spatial metadata will not result in the image
characteristics being altered \[en] use the specific parameters provided
to update spatial characteristics.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Description\@\[aq]some\ description\[aq]"\f[]
.IP \[bu] 2
\f[C]"\[aq]Description\@some\ description\[aq]"\f[]
.IP \[bu] 2
\f[C]"MinimumSeparation\@1.23"\f[]
.IP \[bu] 2
\f[C]"\[aq]Description\@some\ description;MinimumSeparation\@1.23\[aq]"\f[]
.SS SliceThickness
.SS Description
.PP
Image slices will be have this thickness (in DICOM units: mm).
For most purposes, SliceThickness should be equal to
SpacingBetweenSlices.
If SpacingBetweenSlices is smaller than SliceThickness, images will
overlap.
If SpacingBetweenSlices is larger than SliceThickness, there will be a
gap between images.
Updating the SliceThickness or image positioning using this operation
will alter the image, but will not update SpacingBetweenSlices.
This gives the user freedom to alter all image planes individually,
allowing construction of non\-rectilinear image volumes.
If SpacingBetweenSlices is known and consistent, it should be reflected
in the image metadata (by the user).
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS VoxelWidth
.SS Description
.PP
Voxels will have this (in\-plane) width (in DICOM units: mm).
This means that row\-adjacent voxels centres will be separated by
VoxelWidth).
Each voxel will have dimensions: VoxelWidth x VoxelHeight x
SliceThickness.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS VoxelHeight
.SS Description
.PP
Voxels will have this (in\-plane) height (in DICOM units: mm).
This means that column\-adjacent voxels centres will be separated by
VoxelHeight).
Each voxel will have dimensions: VoxelWidth x VoxelHeight x
SliceThickness.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.SS ImageAnchor
.SS Description
.PP
A point in 3D space which denotes the origin (in DICOM units: mm).
All other vectors are taken to be relative to this point.
Under most circumstance the anchor should be (0,0,0).
Specify coordinates separated by commas.
.SS Default
.IP \[bu] 2
\f[C]"0.0,\ 0.0,\ 0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0,\ 0.0,\ 0.0"\f[]
.IP \[bu] 2
\f[C]"0.0,0.0,0.0"\f[]
.IP \[bu] 2
\f[C]"1.0,\ \-2.3,\ 45.6"\f[]
.SS ImagePosition
.SS Description
.PP
The centre of the row=0, column=0 voxel in the first image (in DICOM
units: mm).
Specify coordinates separated by commas.
.SS Default
.IP \[bu] 2
\f[C]"0.0,\ 0.0,\ 0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0,\ 0.0,\ 0.0"\f[]
.IP \[bu] 2
\f[C]"100.0,100.0,100.0"\f[]
.IP \[bu] 2
\f[C]"1.0,\ \-2.3,\ 45.6"\f[]
.SS ImageOrientationColumn
.SS Description
.PP
The orientation unit vector that is aligned with image columns.
Care should be taken to ensure ImageOrientationRow and
ImageOrientationColumn are orthogonal.
(A Gram\-Schmidt orthogonalization procedure ensures they are, but the
image orientation may not match the expected orientation.) Note that the
magnitude will also be scaled to unit length for convenience.
Specify coordinates separated by commas.
.SS Default
.IP \[bu] 2
\f[C]"1.0,\ 0.0,\ 0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.0,\ 0.0,\ 0.0"\f[]
.IP \[bu] 2
\f[C]"1.0,\ 1.0,\ 0.0"\f[]
.IP \[bu] 2
\f[C]"0.0,\ 0.0,\ \-1.0"\f[]
.SS ImageOrientationRow
.SS Description
.PP
The orientation unit vector that is aligned with image rows.
Care should be taken to ensure ImageOrientationRow and
ImageOrientationColumn are orthogonal.
(A Gram\-Schmidt orthogonalization procedure ensures they are, but the
image orientation may not match the expected orientation.) Note that the
magnitude will also be scaled to unit length for convenience.
Specify coordinates separated by commas.
.SS Default
.IP \[bu] 2
\f[C]"0.0,\ 1.0,\ 0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0,\ 1.0,\ 0.0"\f[]
.IP \[bu] 2
\f[C]"0.0,\ 1.0,\ 1.0"\f[]
.IP \[bu] 2
\f[C]"\-1.0,\ 0.0,\ 0.0"\f[]
.SS NegatePixels
.SS Description
.PP
This operation negates pixels for the selected image arrays.
This functionality is often desired for processing MR images.
.SS Parameters
.IP \[bu] 2
ImageSelection
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizeLineSamples
.SS Description
.PP
This operation scales line samples according to a user\-provided
normalization criteria.
.SS Notes
.IP \[bu] 2
Each line sample is independently normalized.
.SS Parameters
.IP \[bu] 2
LineSelection
.IP \[bu] 2
Method
.SS LineSelection
.SS Description
.PP
Select one or more line samples.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth line
sample (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last line sample.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Method
.SS Description
.PP
The type of normalization to apply.
The currently supported options are `area' and `peak'.
`Area' ensures that the total integrated area is equal to one by scaling
the ordinate.
`Peak' ensures that the maximum ordinate is one and the minimum ordinate
is zero.
.SS Default
.IP \[bu] 2
\f[C]"area"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"area"\f[]
.IP \[bu] 2
\f[C]"peak"\f[]
.SS NormalizePixels
.SS Description
.PP
This routine normalizes voxel intensities by adjusting them so they
satisfy a `normalization' criteria.
This operation is useful as a pre\-processing step when performing
convolution or thresholding with absolute magnitudes.
.SS Notes
.IP \[bu] 2
This operation considers entire image arrays, not just single images.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Inclusivity
.IP \[bu] 2
ContourOverlap
.IP \[bu] 2
Channel
.IP \[bu] 2
Method
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Inclusivity
.SS Description
.PP
Controls how voxels are deemed to be `within' the interior of the
selected ROI(s).
The default `center' considers only the central\-most point of each
voxel.
There are two corner options that correspond to a 2D projection of the
voxel onto the image plane.
The first, `planar_corner_inclusive', considers a voxel interior if ANY
corner is interior.
The second, `planar_corner_exclusive', considers a voxel interior if ALL
(four) corners are interior.
.SS Default
.IP \[bu] 2
\f[C]"center"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"center"\f[]
.IP \[bu] 2
\f[C]"centre"\f[]
.IP \[bu] 2
\f[C]"planar_corner_inclusive"\f[]
.IP \[bu] 2
\f[C]"planar_inc"\f[]
.IP \[bu] 2
\f[C]"planar_corner_exclusive"\f[]
.IP \[bu] 2
\f[C]"planar_exc"\f[]
.SS ContourOverlap
.SS Description
.PP
Controls overlapping contours are treated.
The default `ignore' treats overlapping contours as a single contour,
regardless of contour orientation.
The option `honour_opposite_orientations' makes overlapping contours
with opposite orientation cancel.
Otherwise, orientation is ignored.
The latter is useful for Boolean structures where contour orientation is
significant for interior contours (holes).
The option `overlapping_contours_cancel' ignores orientation and cancels
all contour overlap.
.SS Default
.IP \[bu] 2
\f[C]"ignore"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"ignore"\f[]
.IP \[bu] 2
\f[C]"honour_opposite_orientations"\f[]
.IP \[bu] 2
\f[C]"overlapping_contours_cancel"\f[]
.IP \[bu] 2
\f[C]"honour_opps"\f[]
.IP \[bu] 2
\f[C]"overlap_cancel"\f[]
.SS Channel
.SS Description
.PP
The channel to operate on (zero\-based).
Negative values will cause all channels to be operated on.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.SS Method
.SS Description
.PP
Controls the specific type of normalization that will be applied.
`Stretch01' will rescale the voxel values so the minima are 0 and the
maxima are 1.
Likewise, `stretch11' will rescale such that the minima are \-1 and the
maxima are 1.
Clamp will ensure all voxel intensities are within [0:1] by setting
those lower than 0 to 0 and those higher than 1 to 1.
(Voxels already within [0:1] will not be altered.) `Sum\-to\-zero' will
shift all voxels so that the sum of all voxel intensities is zero.
(This is useful for convolution kernels.)
.SS Default
.IP \[bu] 2
\f[C]"stretch11"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"clamp"\f[]
.IP \[bu] 2
\f[C]"stretch01"\f[]
.IP \[bu] 2
\f[C]"stretch11"\f[]
.IP \[bu] 2
\f[C]"sum\-to\-zero"\f[]
.SS OptimizeStaticBeams
.SS Description
.PP
This operation takes dose matrices corresponding to single, static RT
beams and attempts to optimize beam weighting to create an optimal plan
subject to various criteria.
.SS Notes
.IP \[bu] 2
This routine is a simplisitic routine that attempts to estimate the
optimal beam weighting.
It should NOT be used for clinical purposes, except maybe as a secondary
check or a means to guess reasonable beam weights prior to optimization
within the clinical TPS.
.IP \[bu] 2
Because beam weights are (generally) not specified in DICOM RTDOSE
files, the beam weights are assumed to all be 1.0.
If they are not all 1.0, the weights reported here will be relative to
whatever the existing weights are.
.IP \[bu] 2
If no PTV ROI is available, the BODY contour may suffice.
If this is not available, dose outside the body should somehow be set to
zero to avoid confusing D_{max} metrics.
For example, bolus D_{max} can be high, but is ultimately irrelevant.
.IP \[bu] 2
By default, this routine uses all available images.
This may be fixed in a future release.
Patches are welcome.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
ResultsSummaryFileName
.IP \[bu] 2
UserComment
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
MaxVoxelSamples
.IP \[bu] 2
NormalizationD
.IP \[bu] 2
NormalizationV
.IP \[bu] 2
RxDose
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ResultsSummaryFileName
.SS Description
.PP
This file will contain a brief summary of the results.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
If an existing file is present, rows will be appended without writing a
header.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS MaxVoxelSamples
.SS Description
.PP
The maximum number of voxels to randomly sample (deterministically)
within the PTV.
Setting lower will result in faster calculation, but lower precision.
A reasonable setting depends on the size of the target structure; small
targets may suffice with a few hundred voxels, but larger targets
probably require several thousand.
.SS Default
.IP \[bu] 2
\f[C]"1000"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"200"\f[]
.IP \[bu] 2
\f[C]"500"\f[]
.IP \[bu] 2
\f[C]"1000"\f[]
.IP \[bu] 2
\f[C]"2000"\f[]
.IP \[bu] 2
\f[C]"5000"\f[]
.SS NormalizationD
.SS Description
.PP
The isodose value that should envelop a given volume in the PTV ROI.
In other words, this parameter is the `D' parameter in a DVH constraint
of the form
\f[I]V\f[]~\f[I]D\f[]~ ≥ \f[I]V\f[]~\f[I]m\f[]\f[I]i\f[]\f[I]n\f[]~.
It should be given as a fraction within [0:1] relative to the
prescription dose.
For example, 95% isodose should be provided as `0.95'.
.SS Default
.IP \[bu] 2
\f[C]"0.95"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.90"\f[]
.IP \[bu] 2
\f[C]"0.95"\f[]
.IP \[bu] 2
\f[C]"0.98"\f[]
.IP \[bu] 2
\f[C]"0.99"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS NormalizationV
.SS Description
.PP
The minimal fractional volume of ROI that should be enclosed within one
or more surfaces that demarcate the given isodose value.
In other words, this parameter is the `Vmin' parameter in a DVH
constraint of the form
\f[I]V\f[]~\f[I]D\f[]~ ≥ \f[I]V\f[]~\f[I]m\f[]\f[I]i\f[]\f[I]n\f[]~.
It should be given as a fraction within [0:1] relative to the volume of
the ROI (typically discretized to the number of voxels in the ROI).
For example, if Vmin = 99%, provide the value `0.99'.
.SS Default
.IP \[bu] 2
\f[C]"0.99"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.90"\f[]
.IP \[bu] 2
\f[C]"0.95"\f[]
.IP \[bu] 2
\f[C]"0.98"\f[]
.IP \[bu] 2
\f[C]"0.99"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS RxDose
.SS Description
.PP
The dose prescribed to the ROI that will be optimized.
The units depend on the DICOM file, but will likely be Gy.
.SS Default
.IP \[bu] 2
\f[C]"70.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"48.0"\f[]
.IP \[bu] 2
\f[C]"60.0"\f[]
.IP \[bu] 2
\f[C]"63.3"\f[]
.IP \[bu] 2
\f[C]"70.0"\f[]
.IP \[bu] 2
\f[C]"100.0"\f[]
.SS OrderImages
.SS Description
.PP
This operation will order individual image slices within collections
(Image_Arrays) based on the values of the specified metadata tags.
.SS Notes
.IP \[bu] 2
Images are moved, not copied.
.IP \[bu] 2
Image groupings are retained, and the order of groupings is not altered.
.IP \[bu] 2
Images that do not contain the specified metadata will be sorted after
the end.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
Key
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Key
.SS Description
.PP
Image metadata key to use for ordering.
Images will be sorted according to the key's value `natural' sorting
order, which compares sub\-strings of numbers and characters separately.
Note this ordering is expected to be stable, but may not always be on
some systems.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"AcquisitionTime"\f[]
.IP \[bu] 2
\f[C]"ContentTime"\f[]
.IP \[bu] 2
\f[C]"SeriesNumber"\f[]
.IP \[bu] 2
\f[C]"SeriesDescription"\f[]
.SS PartitionContours
.SS Description
.PP
This operation partitions the selected contours, producing a number of
sub\-segments that could be re\-combined to re\-create the original
contours.
.SS Parameters
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
PlanarOrientation
.IP \[bu] 2
SubsegmentRootROILabel
.IP \[bu] 2
SubsegMethod
.IP \[bu] 2
NestedCleaveOrder
.IP \[bu] 2
XPartitions
.IP \[bu] 2
YPartitions
.IP \[bu] 2
ZPartitions
.IP \[bu] 2
ReverseXTraversalOrder
.IP \[bu] 2
ReverseYTraversalOrder
.IP \[bu] 2
ReverseZTraversalOrder
.IP \[bu] 2
FractionalTolerance
.IP \[bu] 2
MaxBisects
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS PlanarOrientation
.SS Description
.PP
A string instructing how to orient the cleaving planes.
Currently supported: (1) `axis\-aligned' (i.e., align with the
image/dose grid row and column unit vectors) and (2) `static\-oblique'
(i.e., same as axis\-aligned but rotated 22.5 degrees to reduce
colinearity, which sometimes improves sub\-segment area consistency).
.SS Default
.IP \[bu] 2
\f[C]"axis\-aligned"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"axis\-aligned"\f[]
.IP \[bu] 2
\f[C]"static\-oblique"\f[]
.SS SubsegmentRootROILabel
.SS Description
.PP
The root ROI label to attach to the sub\-segments.
The full name will be this root followed by '_' and the number of the
subsegment.
.SS Default
.IP \[bu] 2
\f[C]"subsegment"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"subsegment"\f[]
.IP \[bu] 2
\f[C]"ss"\f[]
.IP \[bu] 2
\f[C]"partition"\f[]
.SS SubsegMethod
.SS Description
.PP
The method to use for sub\-segmentation.
Nested sub\-segmentation should almost always be preferred unless you
know what you're doing.
It should be faster too.
Compound sub\-segmentation is known to cause problems, e.g., with
zero\-area sub\-segments and spatial dependence in sub\-segment volume.
Nested cleaving will produce sub\-segments of equivalent area (volume)
throughout the entire ROI whereas compound sub\-segmentation will not.
.SS Default
.IP \[bu] 2
\f[C]"nested\-cleave"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"nested\-cleave"\f[]
.IP \[bu] 2
\f[C]"compound\-cleave"\f[]
.SS NestedCleaveOrder
.SS Description
.PP
The order in which to apply nested cleaves.
This routine requires one of `ZYX', `ZXY', `XYZ', `XZY', `YZX', or
`YXZ'.
Cleaves are implemented from left to right using the specified X, Y, and
Z selection criteria.
.SS Default
.IP \[bu] 2
\f[C]"ZXY"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"ZXY"\f[]
.IP \[bu] 2
\f[C]"ZYX"\f[]
.IP \[bu] 2
\f[C]"XYZ"\f[]
.IP \[bu] 2
\f[C]"XZY"\f[]
.IP \[bu] 2
\f[C]"YZX"\f[]
.IP \[bu] 2
\f[C]"YXZ"\f[]
.SS XPartitions
.SS Description
.PP
The number of partitions to find along the `X' axis.
The total number of sub\-segments produced along the `X' axis will be
(1+XPartitions).
A value of zero will disable the partitioning along the `X' axis.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.IP \[bu] 2
\f[C]"5"\f[]
.IP \[bu] 2
\f[C]"50"\f[]
.SS YPartitions
.SS Description
.PP
The number of partitions to find along the `Y' axis.
The total number of sub\-segments produced along the `Y' axis will be
(1+YPartitions).
A value of zero will disable the partitioning along the `Y' axis.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.IP \[bu] 2
\f[C]"5"\f[]
.IP \[bu] 2
\f[C]"50"\f[]
.SS ZPartitions
.SS Description
.PP
The number of partitions to find along the `Z' axis.
The total number of sub\-segments produced along the `Z' axis will be
(1+ZPartitions).
A value of zero will disable the partitioning along the `Z' axis.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.IP \[bu] 2
\f[C]"5"\f[]
.IP \[bu] 2
\f[C]"50"\f[]
.SS ReverseXTraversalOrder
.SS Description
.PP
Controls the order in which sub\-segments are numbered.
If set to `true' the numbering will be reversed along the X axis.
This option is most useful when the `X' axis intersects mirrored ROIs
(e.g., left and right parotid glands).
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"false"\f[]
.IP \[bu] 2
\f[C]"true"\f[]
.SS ReverseYTraversalOrder
.SS Description
.PP
Controls the order in which sub\-segments are numbered.
If set to `true' the numbering will be reversed along the Y axis.
This option is most useful when the `Y' axis intersects mirrored ROIs
(e.g., left and right parotid glands).
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"false"\f[]
.IP \[bu] 2
\f[C]"true"\f[]
.SS ReverseZTraversalOrder
.SS Description
.PP
Controls the order in which sub\-segments are numbered.
If set to `true' the numbering will be reversed along the Z axis.
This option is most useful when the `Z' axis intersects mirrored ROIs
(e.g., left and right parotid glands).
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"false"\f[]
.IP \[bu] 2
\f[C]"true"\f[]
.SS FractionalTolerance
.SS Description
.PP
The tolerance of X, Y, and Z fractional area bisection criteria (see
ZSelection description).
This parameter specifies a stopping condition for the bisection
procedure.
If it is set too high, sub\-segments may be inadequatly rough.
If it is set too low, bisection below the machine precision floor may be
attempted, which will result in instabilities.
Note that the number of permitted iterations will control whether this
tolerance can possibly be reached; if strict adherence is required, set
the maximum number of iterations to be excessively large.
.SS Default
.IP \[bu] 2
\f[C]"0.001"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1E\-2"\f[]
.IP \[bu] 2
\f[C]"1E\-3"\f[]
.IP \[bu] 2
\f[C]"1E\-4"\f[]
.IP \[bu] 2
\f[C]"1E\-5"\f[]
.SS MaxBisects
.SS Description
.PP
The maximum number of iterations the bisection procedure can perform.
This parameter specifies a stopping condition for the bisection
procedure.
If it is set too low, sub\-segments may be inadequatly rough.
If it is set too high, bisection below the machine precision floor may
be attempted, which will result in instabilities.
Note that the fractional tolerance will control whether this tolerance
can possibly be reached; if an exact number of iterations is required,
set the fractional tolerance to be excessively small.
.SS Default
.IP \[bu] 2
\f[C]"20"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"20"\f[]
.IP \[bu] 2
\f[C]"30"\f[]
.SS PlotLineSamples
.SS Description
.PP
This operation plots the selected line samples.
.SS Parameters
.IP \[bu] 2
LineSelection
.IP \[bu] 2
Title
.IP \[bu] 2
AbscissaLabel
.IP \[bu] 2
OrdinateLabel
.SS LineSelection
.SS Description
.PP
Select one or more line samples.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth line
sample (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last line sample.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Title
.SS Description
.PP
The title to display in the plot.
Leave empty to disable.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Line\ Samples"\f[]
.IP \[bu] 2
\f[C]"Time\ Series"\f[]
.IP \[bu] 2
\f[C]"DVH\ for\ XYZ"\f[]
.SS AbscissaLabel
.SS Description
.PP
The label to attach to the abscissa (i.e., the `x' or horizontal
coordinate).
Leave empty to disable.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"(arb.)"\f[]
.IP \[bu] 2
\f[C]"Time\ (s)"\f[]
.IP \[bu] 2
\f[C]"Distance\ (mm)"\f[]
.IP \[bu] 2
\f[C]"Dose\ (Gy)"\f[]
.SS OrdinateLabel
.SS Description
.PP
The label to attach to the ordinate (i.e., the `y' or vertical
coordinate).
Leave empty to disable.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"(arb.)"\f[]
.IP \[bu] 2
\f[C]"Intensity\ (arb.)"\f[]
.IP \[bu] 2
\f[C]"Volume\ (mm^3)"\f[]
.IP \[bu] 2
\f[C]"Fraction\ (arb.)"\f[]
.SS PlotPerROITimeCourses
.SS Description
.PP
Interactively plot time courses for the specified ROI(s).
.SS Parameters
.IP \[bu] 2
ROILabelRegex
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS PointSeparation
.SS Description
.PP
This operation estimates the minimum and maximum point\-to\-point
separation between two point clouds.
It also computes the longest\-nearest (Hausdorff) separation, i.e., the
length of the longest lines from points in selection A to the nearest
point in selection B.
.SS Notes
.IP \[bu] 2
This routine scales like \f[I]O\f[](\f[I]N\f[] * \f[I]M\f[]) where
\f[I]N\f[] and \f[I]M\f[] are the number of points in each point cloud.
No indexing or acceleration is used.
Beware that large point clouds will result in slow computations.
.IP \[bu] 2
This operation can be used to compare points clouds that are nearly
alike.
Such comparisons are useful for quantifying discrepancies after
transformations, reconstructions, simplifications, or any other
scenarios where a point cloud must be reasonable accurately reproduced.
.SS Parameters
.IP \[bu] 2
PointSelectionA
.IP \[bu] 2
PointSelectionB
.IP \[bu] 2
FileName
.IP \[bu] 2
UserComment
.SS PointSelectionA
.SS Description
.PP
Select one or more point clouds.
Note that point clouds can hold a variety of data with varying
attributes, but each point cloud is meant to represent a single
logically cohesive collection of points.
Be aware that it is possible to mix logically unrelated points together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth point
cloud (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last point cloud.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"first"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS PointSelectionB
.SS Description
.PP
Select one or more point clouds.
Note that point clouds can hold a variety of data with varying
attributes, but each point cloud is meant to represent a single
logically cohesive collection of points.
Be aware that it is possible to mix logically unrelated points together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth point
cloud (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last point cloud.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS FileName
.SS Description
.PP
A filename (or full path) in which to append separation data generated
by this routine.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS UserComment
.SS Description
.PP
A string that will be inserted into the output file which will simplify
merging output with differing parameters, from different sources, or
using sub\-selections of the data.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"Using\ XYZ"\f[]
.IP \[bu] 2
\f[C]"Patient\ treatment\ plan\ C"\f[]
.SS PreFilterEnormousCTValues
.SS Description
.PP
This operation runs the data through a per\-pixel filter, censoring
pixels which are too high to legitimately show up in a clinical CT.
Censored pixels are set to NaN.
Data is modified and no copy is made!
.SS Parameters
.PP
No registered options.
.SS PresentationImage
.SS Description
.PP
This operation renders an image with any contours in\-place and colour
mapping using an SFML backend.
.SS Notes
.IP \[bu] 2
By default this operation displays the last available image.
This makes it easier to produce a sequence of images by inserting this
operation into a sequence of operations.
.SS Parameters
.IP \[bu] 2
ScaleFactor
.IP \[bu] 2
ImageFileName
.IP \[bu] 2
ColourMapRegex
.IP \[bu] 2
WindowLow
.IP \[bu] 2
WindowHigh
.SS ScaleFactor
.SS Description
.PP
This factor is applied to the image width and height to magnify (larger
than 1) or shrink (less than 1) the image.
This factor only affects the output image size.
Note that aspect ratio is retained, but rounding for non\-integer
factors may lead to small (1\-2 pixel) discrepancies.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"5.23"\f[]
.SS ImageFileName
.SS Description
.PP
The file name to use for the image.
If blank, a filename will be generated sequentially.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/an_image.png"\f[]
.IP \[bu] 2
\f[C]"afile.png"\f[]
.SS ColourMapRegex
.SS Description
.PP
The colour mapping to apply to the image if there is a single channel.
The default will match the first available, and if there is no matching
map found, the first available will be selected.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Viridis"\f[]
.IP \[bu] 2
\f[C]"Magma"\f[]
.IP \[bu] 2
\f[C]"Plasma"\f[]
.IP \[bu] 2
\f[C]"Inferno"\f[]
.IP \[bu] 2
\f[C]"Jet"\f[]
.IP \[bu] 2
\f[C]"MorelandBlueRed"\f[]
.IP \[bu] 2
\f[C]"MorelandBlackBody"\f[]
.IP \[bu] 2
\f[C]"MorelandExtendedBlackBody"\f[]
.IP \[bu] 2
\f[C]"KRC"\f[]
.IP \[bu] 2
\f[C]"ExtendedKRC"\f[]
.IP \[bu] 2
\f[C]"Kovesi_LinKRYW_5\-100_c64"\f[]
.IP \[bu] 2
\f[C]"Kovesi_LinKRYW_0\-100_c71"\f[]
.IP \[bu] 2
\f[C]"Kovesi_Cyclic_cet\-c2"\f[]
.IP \[bu] 2
\f[C]"LANLOliveGreentoBlue"\f[]
.IP \[bu] 2
\f[C]"YgorIncandescent"\f[]
.IP \[bu] 2
\f[C]"LinearRamp"\f[]
.SS WindowLow
.SS Description
.PP
If provided, this parameter will override any existing window and level.
All pixels with the intensity value or lower will be assigned the lowest
possible colour according to the colour map.
Not providing a valid number will disable window overrides.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"\-1.23"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1E4"\f[]
.SS WindowHigh
.SS Description
.PP
If provided, this parameter will override any existing window and level.
All pixels with the intensity value or higher will be assigned the
highest possible colour according to the colour map.
Not providing a valid number will disable window overrides.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"10.3E4"\f[]
.SS PruneEmptyImageDoseArrays
.SS Description
.PP
This operation deletes Image_Arrays that do not contain any images.
.SS Parameters
.PP
No registered options.
.SS PurgeContours
.SS Description
.PP
This routine purges contours if they satisfy various criteria.
.SS Notes
.IP \[bu] 2
This operation considers individual contours only at the moment.
It could be extended to operate on whole ROIs (i.e.,
contour_collections), or to perform a separate vote within each ROI.
The individual contour approach was taken since filtering out small
contour `islands' is the primary use\-case.
.SS Parameters
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
Invert
.IP \[bu] 2
AreaAbove
.IP \[bu] 2
AreaBelow
.IP \[bu] 2
PerimeterAbove
.IP \[bu] 2
PerimeterBelow
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS Invert
.SS Description
.PP
If false, matching contours will be purged.
If true, matching contours will be retained and non\-matching contours
will be purged.
Enabling this option is equivalent to a `Keep if and only if' operation.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS AreaAbove
.SS Description
.PP
If this option is provided with a valid positive number, contour(s) with
an area greater than the specified value are purged.
Note that the DICOM coordinate space is used.
(Supplying the default, inf, will disable this option.)
.SS Default
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"inf"\f[]
.IP \[bu] 2
\f[C]"100.0"\f[]
.IP \[bu] 2
\f[C]"1000"\f[]
.IP \[bu] 2
\f[C]"10.23E8"\f[]
.SS AreaBelow
.SS Description
.PP
If this option is provided with a valid positive number, contour(s) with
an area less than the specified value are purged.
Note that the DICOM coordinate space is used.
(Supplying the default, \-inf, will disable this option.)
.SS Default
.IP \[bu] 2
\f[C]"\-inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-inf"\f[]
.IP \[bu] 2
\f[C]"100.0"\f[]
.IP \[bu] 2
\f[C]"1000"\f[]
.IP \[bu] 2
\f[C]"10.23E8"\f[]
.SS PerimeterAbove
.SS Description
.PP
If this option is provided with a valid positive number, contour(s) with
a perimeter greater than the specified value are purged.
Note that the DICOM coordinate space is used.
(Supplying the default, inf, will disable this option.)
.SS Default
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"inf"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.IP \[bu] 2
\f[C]"100"\f[]
.IP \[bu] 2
\f[C]"10.23E4"\f[]
.SS PerimeterBelow
.SS Description
.PP
If this option is provided with a valid positive number, contour(s) with
a perimeter less than the specified value are purged.
Note that the DICOM coordinate space is used.
(Supplying the default, \-inf, will disable this option.)
.SS Default
.IP \[bu] 2
\f[C]"\-inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-inf"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.IP \[bu] 2
\f[C]"100"\f[]
.IP \[bu] 2
\f[C]"10.23E4"\f[]
.SS RankPixels
.SS Description
.PP
This operation ranks pixels throughout an image array.
.SS Notes
.IP \[bu] 2
This routine operates on all images in an image array, so pixel value
ranks are valid throughout the array.
However, the window and level of each window is separately determined.
You will need to set a uniform window and level manually if desired.
.IP \[bu] 2
This routine operates on all images in an image array.
If images need to be processed individually, arrays will have to be
exploded prior to calling this routine.
Note that if this functionality is required, it can be implemented as an
operation option easily.
Likewise, if multiple image arrays must be considered simultaneously,
they will need to be combined before invoking this operation.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
Method
.IP \[bu] 2
LowerThreshold
.IP \[bu] 2
UpperThreshold
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Method
.SS Description
.PP
Pixels participating in the ranking process will have their pixel values
replaced.
They can be replaced with either a rank or the corresponding percentile.
Ranks start at zero and percentiles are centre\-weighted (i.e.,
rank\-averaged).
.SS Default
.IP \[bu] 2
\f[C]"Percentile"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Rank"\f[]
.IP \[bu] 2
\f[C]"Percentile"\f[]
.SS LowerThreshold
.SS Description
.PP
The (inclusive) threshold above which pixel values must be in order to
participate in the rank.
.SS Default
.IP \[bu] 2
\f[C]"\-inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-inf"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-900"\f[]
.SS UpperThreshold
.SS Description
.PP
The (inclusive) threshold below which pixel values must be in order to
participate in the rank.
.SS Default
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"inf"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"1500"\f[]
.SS ReduceNeighbourhood
.SS Description
.PP
This routine walks the voxels of a 3D rectilinear image collection,
reducing the distribution of voxels within the local volumetric
neighbourhood to a scalar value, and updating the voxel value with this
scalar.
This routine can be used to implement mean and median filters (amongst
others) that operate over a variety of 3D neighbourhoods.
Besides purely statistical reductions, logical reductions can be
applied.
.SS Notes
.IP \[bu] 2
The provided image collection must be rectilinear.
.IP \[bu] 2
This operation can be used to compute core 3D morphology operations
(erosion and dilation) as well as composite operations like opening
(i.e., erosion followed by dilation), closing (i.e., dilation followed
by erosion), `gradient' (i.e., the difference between dilation and
erosion, which produces an outline), and various other combinations of
core and composite operations.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Channel
.IP \[bu] 2
Neighbourhood
.IP \[bu] 2
Reduction
.IP \[bu] 2
MaxDistance
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Channel
.SS Description
.PP
The channel to operated on (zero\-based).
Negative values will cause all channels to be operated on.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.SS Neighbourhood
.SS Description
.PP
Controls how the neighbourhood surrounding a voxel is defined.
Variable\-size neighbourhoods `spherical' and `cubic' are defined.
An appropriate isotropic extent must be provided for these
neighbourhoods.
(See below; extents must be provided in DICOM units, i.e., mm.)
Fixed\-size neighbourhoods specify a fixed number of adjacent voxels.
Fixed rectagular neighbourhoods are specified like `RxCxI' for row,
column, and image slice extents (as integer number of rows, columns, and
slices).
Fixed spherical neighbourhoods are specified like `Wsphere' where W is
the width (i.e., the number of voxels wide).
In morphological terminology, the neighbourhood is referred to as a
`structuring element.' A similar concept is the convolutional `kernel.'
.SS Default
.IP \[bu] 2
\f[C]"spherical"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"spherical"\f[]
.IP \[bu] 2
\f[C]"cubic"\f[]
.IP \[bu] 2
\f[C]"3x3x3"\f[]
.IP \[bu] 2
\f[C]"5x5x5"\f[]
.IP \[bu] 2
\f[C]"3sphere"\f[]
.IP \[bu] 2
\f[C]"5sphere"\f[]
.IP \[bu] 2
\f[C]"7sphere"\f[]
.IP \[bu] 2
\f[C]"9sphere"\f[]
.IP \[bu] 2
\f[C]"11sphere"\f[]
.IP \[bu] 2
\f[C]"13sphere"\f[]
.IP \[bu] 2
\f[C]"15sphere"\f[]
.SS Reduction
.SS Description
.PP
Controls how the distribution of voxel values from neighbouring voxels
is reduced.
Statistical distribution reducers `min', `mean', `median', and `max' are
defined.
`Min' is also known as the `erosion' operation.
Likewise, `max' is also known as the `dilation' operation.
Note that the morphological `opening' operation can be accomplished by
sequentially performing an erosion and then a dilation using the same
neighbourhood.
Logical reducers `is_min' and `is_max' are also available \[en] is_min
(is_max) replace the voxel value with 1.0 if it was the min (max) in the
neighbourhood and 0.0 otherwise.
Logical reducers `is_min_nan' and `is_max_nan' are variants that replace
the voxel with a NaN instead of 1.0 and otherwise do not overwrite the
original voxel value.
.SS Default
.IP \[bu] 2
\f[C]"median"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"min"\f[]
.IP \[bu] 2
\f[C]"erode"\f[]
.IP \[bu] 2
\f[C]"mean"\f[]
.IP \[bu] 2
\f[C]"median"\f[]
.IP \[bu] 2
\f[C]"max"\f[]
.IP \[bu] 2
\f[C]"dilate"\f[]
.IP \[bu] 2
\f[C]"is_min"\f[]
.IP \[bu] 2
\f[C]"is_max"\f[]
.IP \[bu] 2
\f[C]"is_min_nan"\f[]
.IP \[bu] 2
\f[C]"is_max_nan"\f[]
.SS MaxDistance
.SS Description
.PP
The maximum distance (inclusive, in DICOM units: mm) within which
neighbouring voxels will be evaluated for variable\-size neighbourhoods.
Note that this parameter will be ignored if a fixed\-size neighbourhood
has been specified.
For spherical neighbourhoods, this distance refers to the radius.
For cubic neighbourhoods, this distance refers to `box radius' or the
distance from the cube centre to the nearest point on each bounding
face.
Voxels separated by more than this distance will not be evaluated
together.
.SS Default
.IP \[bu] 2
\f[C]"2.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"2.0"\f[]
.IP \[bu] 2
\f[C]"15.0"\f[]
.SS RemeshSurfaceMeshes
.SS Description
.PP
This operation re\-meshes existing surface meshes according to the
specified criteria, replacing the original meshes with remeshed copies.
.SS Notes
.IP \[bu] 2
Selected surface meshes should represent polyhedra.
.SS Parameters
.IP \[bu] 2
MeshSelection
.IP \[bu] 2
Iterations
.IP \[bu] 2
TargetEdgeLength
.SS MeshSelection
.SS Description
.PP
Select one or more surface meshes.
Note that a single surface mesh may hold many disconnected mesh
components; they should collectively represent a single logically
cohesive object.
Be aware that it is possible to mix logically unrelated sub\-meshes
together in a single mesh.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth surface
mesh (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last surface mesh.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Iterations
.SS Description
.PP
The number of remeshing iterations to perform.
.SS Default
.IP \[bu] 2
\f[C]"5"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.IP \[bu] 2
\f[C]"5"\f[]
.IP \[bu] 2
\f[C]"10"\f[]
.SS TargetEdgeLength
.SS Description
.PP
The desired length of all edges in the remeshed mesh in DICOM units
(mm).
.SS Default
.IP \[bu] 2
\f[C]"1.5"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.2"\f[]
.IP \[bu] 2
\f[C]"0.75"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"1.5"\f[]
.IP \[bu] 2
\f[C]"2.015"\f[]
.SS SFML_Viewer
.SS Description
.PP
Launch an interactive viewer based on SFML.
Using this viewer, it is possible to contour ROIs, generate plots of
pixel intensity along profiles or through time, inspect and compare
metadata, and various other things.
.SS Parameters
.IP \[bu] 2
SingleScreenshot
.IP \[bu] 2
SingleScreenshotFileName
.IP \[bu] 2
FPSLimit
.SS SingleScreenshot
.SS Description
.PP
If `true', a single screenshot is taken and then the viewer is exited.
This option works best for quick visual inspections, and should not be
used for later processing or analysis.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS SingleScreenshotFileName
.SS Description
.PP
Iff invoking the `SingleScreenshot' argument, use this string as the
screenshot filename.
If blank, a filename will be generated sequentially.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/a_screenshot.png"\f[]
.IP \[bu] 2
\f[C]"afile.png"\f[]
.SS FPSLimit
.SS Description
.PP
The upper limit on the frame rate, in seconds as an unsigned integer.
Note that this value may be treated as a suggestion.
.SS Default
.IP \[bu] 2
\f[C]"60"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"60"\f[]
.IP \[bu] 2
\f[C]"30"\f[]
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.SS ScalePixels
.SS Description
.PP
This operation scales pixel (voxel) values confined to one or more ROIs.
.SS Notes
.IP \[bu] 2
This routine could be used to derive, for example, per\-fraction dose
from a total dose image array.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Inclusivity
.IP \[bu] 2
ContourOverlap
.IP \[bu] 2
ScaleFactor
.IP \[bu] 2
Channel
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Inclusivity
.SS Description
.PP
Controls how voxels are deemed to be `within' the interior of the
selected ROI(s).
The default `center' considers only the central\-most point of each
voxel.
There are two corner options that correspond to a 2D projection of the
voxel onto the image plane.
The first, `planar_corner_inclusive', considers a voxel interior if ANY
corner is interior.
The second, `planar_corner_exclusive', considers a voxel interior if ALL
(four) corners are interior.
.SS Default
.IP \[bu] 2
\f[C]"center"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"center"\f[]
.IP \[bu] 2
\f[C]"centre"\f[]
.IP \[bu] 2
\f[C]"planar_corner_inclusive"\f[]
.IP \[bu] 2
\f[C]"planar_inc"\f[]
.IP \[bu] 2
\f[C]"planar_corner_exclusive"\f[]
.IP \[bu] 2
\f[C]"planar_exc"\f[]
.SS ContourOverlap
.SS Description
.PP
Controls overlapping contours are treated.
The default `ignore' treats overlapping contours as a single contour,
regardless of contour orientation.
The option `honour_opposite_orientations' makes overlapping contours
with opposite orientation cancel.
Otherwise, orientation is ignored.
The latter is useful for Boolean structures where contour orientation is
significant for interior contours (holes).
The option `overlapping_contours_cancel' ignores orientation and cancels
all contour overlap.
.SS Default
.IP \[bu] 2
\f[C]"ignore"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"ignore"\f[]
.IP \[bu] 2
\f[C]"honour_opposite_orientations"\f[]
.IP \[bu] 2
\f[C]"overlapping_contours_cancel"\f[]
.IP \[bu] 2
\f[C]"honour_opps"\f[]
.IP \[bu] 2
\f[C]"overlap_cancel"\f[]
.SS ScaleFactor
.SS Description
.PP
The numeric factor to multiply all pixel (voxel) values with.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1.0"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"1.23E\-5"\f[]
.SS Channel
.SS Description
.PP
The image channel to use.
Zero\-based.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS SeamContours
.SS Description
.PP
This routine converts contours that represent `outer' and `inner' via
contour orientation into contours that are uniformly outer but have a
zero\-area seam connecting the inner and outer portions.
.SS Notes
.IP \[bu] 2
This routine currently operates on all available ROIs.
.IP \[bu] 2
This routine operates on one contour_collection at a time.
It will combine contours that are in the same contour_collection and
overlap, even if they have different ROINames.
Consider making a complementary routine that partitions contours into
ROIs based on ROIName (or other metadata) if more rigorous enforcement
is needed.
.IP \[bu] 2
This routine actually computes the XOR Boolean of contours that overlap.
So if contours partially overlap, this routine will treat the
overlapping parts as if they are holes, and the non\-overlapping parts
as if they represent the ROI.
This behaviour may be surprising in some cases.
.IP \[bu] 2
This routine will also treat overlapping contours with like orientation
as if the smaller contour were a hole of the larger contour.
.IP \[bu] 2
This routine will ignore contour orientation if there is only a single
contour.
More specifically, for a given ROI label, planes with a single contour
will be unaltered.
.IP \[bu] 2
Only the common metadata between outer and inner contours is propagated
to the seamed contours.
.IP \[bu] 2
This routine will NOT combine disconnected contours with a seam.
Disconnected contours will remain disconnected.
.SS Parameters
.PP
No registered options.
.SS SelectSlicesIntersectingROI
.SS Description
.PP
This operation applies a whitelist to the most\-recently loaded images.
Images must `slice' through one of the described ROIs in order to make
the whitelist.
This operation is typically used to reduce long computations by trimming
the field of view of extraneous image slices.
.SS Parameters
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS SimplifyContours
.SS Description
.PP
This operation performs simplification on contours by removing or moving
vertices.
This operation is mostly used to reduce the computational complexity of
other operations.
.SS Notes
.IP \[bu] 2
Contours are currently processed individually, not as a volume.
.IP \[bu] 2
Simplification is generally performed most eagerly on regions with
relatively low curvature.
Regions of high curvature are generally simplified only as necessary.
.SS Parameters
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
FractionalAreaTolerance
.IP \[bu] 2
SimplificationMethod
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS FractionalAreaTolerance
.SS Description
.PP
The fraction of area each contour will tolerate during simplified.
This is a measure of how much the contour area can change due to
simplification.
.SS Default
.IP \[bu] 2
\f[C]"0.01"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.001"\f[]
.IP \[bu] 2
\f[C]"0.01"\f[]
.IP \[bu] 2
\f[C]"0.02"\f[]
.IP \[bu] 2
\f[C]"0.05"\f[]
.IP \[bu] 2
\f[C]"0.10"\f[]
.SS SimplificationMethod
.SS Description
.PP
The specific algorithm used to perform contour simplification.
`Vertex removal' is a simple algorithm that removes vertices
one\-by\-one without replacement.
It iteratively ranks vertices and removes the single vertex that has the
least impact on contour area.
It is best suited to removing redundant vertices or whenever new
vertices should not be added.
`Vertex collapse' combines two adjacent vertices into a single vertex at
their midpoint.
It iteratively ranks vertex pairs and removes the single vertex that has
the least total impact on contour area.
Note that small sharp features that alternate inward and outward will
have a small total area cost, so will be pruned early.
Thus this technique acts as a low\-pass filter and will defer
simplification of high\-curvature regions until necessary.
It is more economical compared to vertex removal in that it will usually
simplify contours more for a given tolerance (or, equivalently, can
retain contour fidelity better than vertex removal for the same number
of vertices).
However, vertex collapse performs an averaging that may result in
numerical imprecision.
.SS Default
.IP \[bu] 2
\f[C]"vert\-collapse"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"vertex\-collapse"\f[]
.IP \[bu] 2
\f[C]"vertex\-removal"\f[]
.SS SimplifySurfaceMeshes
.SS Description
.PP
This operation performs mesh simplification on existing surface meshes
according to the specified criteria, replacing the original meshes with
simplified copies.
.SS Notes
.IP \[bu] 2
Selected surface meshes should represent polyhedra.
.SS Parameters
.IP \[bu] 2
MeshSelection
.IP \[bu] 2
EdgeCountLimit
.SS MeshSelection
.SS Description
.PP
Select one or more surface meshes.
Note that a single surface mesh may hold many disconnected mesh
components; they should collectively represent a single logically
cohesive object.
Be aware that it is possible to mix logically unrelated sub\-meshes
together in a single mesh.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth surface
mesh (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last surface mesh.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS EdgeCountLimit
.SS Description
.PP
The maximum number of edges simplified meshes should contain.
.SS Default
.IP \[bu] 2
\f[C]"250000"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"20000"\f[]
.IP \[bu] 2
\f[C]"100000"\f[]
.IP \[bu] 2
\f[C]"500000"\f[]
.IP \[bu] 2
\f[C]"5000000"\f[]
.SS SimulateRadiograph
.SS Description
.PP
This routine uses ray marching and volumetric sampling to simulate
radiographs using a CT image array.
Voxels are assumed to have intensities in HU.
A simplisitic conversion from CT number (in HU) to relative electron
density (see note below) is performed for marched rays.
.SS Notes
.IP \[bu] 2
Images must be regular.
.IP \[bu] 2
This operation currently takes a simplistic approach and should only be
used for purposes where the simulated radiograph contrast can be tuned
and validated (e.g., in a relative way).
.IP \[bu] 2
This operation assumes mass density (in g/cm^3^) and relative electron
density (dimensionless; relative to electron density of water, which is
3.343\f[I]E\f[]23 cm^3^) are numerically equivalent.
This assumption appears to be reasonable for bulk human tissue
(arXiv:1508.00226v1).
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
Filename
.IP \[bu] 2
SourcePosition
.IP \[bu] 2
AttenuationScale
.IP \[bu] 2
ImageModel
.IP \[bu] 2
Rows
.IP \[bu] 2
Columns
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Filename
.SS Description
.PP
The filename (or full path) to which the simulated image will be saved
to.
The format is FITS.
Leaving empty will result in a unique name being generated.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"./img.fits"\f[]
.IP \[bu] 2
\f[C]"sim_radiograph.fits"\f[]
.IP \[bu] 2
\f[C]"/tmp/out.fits"\f[]
.SS SourcePosition
.SS Description
.PP
This parameter controls where the virtual point source is.
Both absolute and relative positioning are available.
A source located at point (1.0, \-2.3, 4.5) in the DICOM coordinate
system of a given image can be specified as `absolute(1.0, \-2.3, 4.5)'.
A source located relative to the image centre by offset (10.0, \-23.4,
45.6) in the DICOM coordinate system of a given image can be specified
as `relative(10.0, \-23.4, 45.6)'.
Relative offsets must be specified relative to the image centre.
Note that DICOM units (i.e., mm) are used for all coordinates.
.SS Default
.IP \[bu] 2
\f[C]"relative(0.0,\ 1000.0,\ 20.0)"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"relative(0.0,\ 1610.0,\ 20.0)"\f[]
.IP \[bu] 2
\f[C]"absolute(\-123.0,\ 123.0,\ 1.23)"\f[]
.SS AttenuationScale
.SS Description
.PP
This parameter globally scales all attenuation factors derived via ray
marching.
Adjusting this parameter will alter the radiograph image contrast the
exponential attenuation model; numbers within (0:1) will result in less
attenuation, whereas numbers within (1:inf) will result in more
attenuation.
Thin or low\-mass subjects might require artifically increased
attenuation, whereas thick or high\-mass subjects might require
artifically decreased attenuation.
Setting this number to 1 will result in no scaling.
This parameter has units 1/length, and the magnitude should
\f[I]roughly\f[] correspond with the inverse of about 3× the length
transited by a typical ray (in mm).
.SS Default
.IP \[bu] 2
\f[C]"0.001"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.0E\-4"\f[]
.IP \[bu] 2
\f[C]"0.001"\f[]
.IP \[bu] 2
\f[C]"0.01"\f[]
.IP \[bu] 2
\f[C]"0.1"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.IP \[bu] 2
\f[C]"1E2"\f[]
.SS ImageModel
.SS Description
.PP
This parameter adjusts how the final image is constructed.
As rays transit a voxel, the approximate transit distance is multiplied
with the voxel's attenuation coefficient (i.e.,
\f[I]μ\f[] ⋅ \f[I]d\f[]\f[I]L\f[]) to give the ray's attenuation.
The sum of all per\-voxel attenuations constitutes the total
attenuation.
There are many ways this information can be converted into an image.
First, the `attenuation\-length' model directly outputs the total
attenuation for each ray.
The simulated image's pixels will contain the total attenuation for one
ray.
It will almost always provide an image since the attenutation is not
performed.
This can be thought of as a log transform of a standard radiograph.
Second, the `exponential' model performs the attenuation assuming the
radiation beam is monoenergetic, narrow, and has the same energy
spectrum as the original imaging device.
This model produces a typical radiograph, where each image pixel
contains 1 − exp  − ∑\f[I]μ\f[] ⋅ \f[I]d\f[]\f[I]L\f[].
Note that the values will all  ∈ [0 : 1] (i.e., Hounsfield units are
\f[I]not\f[] used).
The overall contrast can be adjusted using the AttenuationScale
parameter, however it is easiest to assess a reasonable tuning factor by
inspecting the image produced by the `attenutation\-length' model.
.SS Default
.IP \[bu] 2
\f[C]"attenuation\-length"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"attenuation\-length"\f[]
.IP \[bu] 2
\f[C]"exponential"\f[]
.SS Rows
.SS Description
.PP
The number of rows that the simulated radiograph will contain.
Note that the field of view is determined separately from the number of
rows and columns, so increasing the row count will only result in
increased spatial resolution.
.SS Default
.IP \[bu] 2
\f[C]"512"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"100"\f[]
.IP \[bu] 2
\f[C]"500"\f[]
.IP \[bu] 2
\f[C]"2000"\f[]
.SS Columns
.SS Description
.PP
The number of columns that the simulated radiograph will contain.
Note that the field of view is determined separately from the number of
rows and columns, so increasing the column count will only result in
increased spatial resolution.
.SS Default
.IP \[bu] 2
\f[C]"512"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"100"\f[]
.IP \[bu] 2
\f[C]"500"\f[]
.IP \[bu] 2
\f[C]"2000"\f[]
.SS SpatialBlur
.SS Description
.PP
This operation blurs pixels (within the plane of the image only) using
the specified estimator.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
Estimator
.IP \[bu] 2
GaussianOpenSigma
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Estimator
.SS Description
.PP
Controls the (in\-plane) blur estimator to use.
Options are currently: box_3x3, box_5x5, gaussian_3x3, gaussian_5x5, and
gaussian_open.
The latter (gaussian_open) is adaptive and requires a supplementary
parameter that controls the number of adjacent pixels to consider.
The former (`\&...3x3' and `\&...5x5') are `fixed' estimators that use a
convolution kernel with a fixed size (3x3 or 5x5 pixel neighbourhoods).
All estimators operate in `pixel\-space' and are ignorant about the
image spatial extent.
All estimators are normalized, and thus won't significantly affect the
pixel magnitude scale.
.SS Default
.IP \[bu] 2
\f[C]"gaussian_open"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"box_3x3"\f[]
.IP \[bu] 2
\f[C]"box_5x5"\f[]
.IP \[bu] 2
\f[C]"gaussian_3x3"\f[]
.IP \[bu] 2
\f[C]"gaussian_5x5"\f[]
.IP \[bu] 2
\f[C]"gaussian_open"\f[]
.SS GaussianOpenSigma
.SS Description
.PP
Controls the number of neighbours to consider (only) when using the
gaussian_open estimator.
The number of pixels is computed automatically to accommodate the
specified sigma (currently ignored pixels have 3*sigma or less
weighting).
Be aware this operation can take an enormous amount of time, since the
pixel neighbourhoods quickly grow large.
.SS Default
.IP \[bu] 2
\f[C]"1.5"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"1.5"\f[]
.IP \[bu] 2
\f[C]"2.5"\f[]
.IP \[bu] 2
\f[C]"5.0"\f[]
.SS SpatialDerivative
.SS Description
.PP
This operation estimates various partial derivatives (of pixel values)
within 2D images.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
Estimator
.IP \[bu] 2
Method
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Estimator
.SS Description
.PP
Controls the finite\-difference partial derivative order or estimator
used.
All estimators are centred and use mirror boundary conditions.
First\-order estimators include the basic nearest\-neighbour first
derivative, and Roberts' cross, Prewitt, Sobel, Scharr estimators.
`XxY' denotes the size of the convolution kernel (i.e., the number of
adjacent pixels considered).
The only second\-order estimator is the basic nearest\-neighbour second
derivative.
.SS Default
.IP \[bu] 2
\f[C]"Scharr\-3x3"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"Roberts\-cross\-3x3"\f[]
.IP \[bu] 2
\f[C]"Prewitt\-3x3"\f[]
.IP \[bu] 2
\f[C]"Sobel\-3x3"\f[]
.IP \[bu] 2
\f[C]"Sobel\-5x5"\f[]
.IP \[bu] 2
\f[C]"Scharr\-3x3"\f[]
.IP \[bu] 2
\f[C]"Scharr\-5x5"\f[]
.IP \[bu] 2
\f[C]"second"\f[]
.SS Method
.SS Description
.PP
Controls partial derivative method.
First\-order derivatives can be row\- or column\-aligned, Roberts' cross
can be (+row,+col)\-aligned or (\-row,+col)\-aligned.
Second\-order derivatives can be row\-aligned, column\-aligned, or
`cross' \[en]meaning the compound partial derivative.
All methods support non\-maximum\-suppression for edge thinning, but
currently only the magnitude is output.
All methods support magnitude (addition of orthogonal components in
quadrature) and orientation (in radians; [0,2pi) ).
.SS Default
.IP \[bu] 2
\f[C]"magnitude"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"row\-aligned"\f[]
.IP \[bu] 2
\f[C]"column\-aligned"\f[]
.IP \[bu] 2
\f[C]"prow\-pcol\-aligned"\f[]
.IP \[bu] 2
\f[C]"nrow\-pcol\-aligned"\f[]
.IP \[bu] 2
\f[C]"magnitude"\f[]
.IP \[bu] 2
\f[C]"orientation"\f[]
.IP \[bu] 2
\f[C]"non\-maximum\-suppression"\f[]
.IP \[bu] 2
\f[C]"cross"\f[]
.SS SpatialSharpen
.SS Description
.PP
This operation `sharpens' pixels (within the plane of the image only)
using the specified estimator.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
Estimator
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Estimator
.SS Description
.PP
Controls the (in\-plane) sharpening estimator to use.
Options are currently: sharpen_3x3 and unsharp_mask_5x5.
The latter is based on a 5x5 Gaussian blur estimator.
.SS Default
.IP \[bu] 2
\f[C]"unsharp_mask_5x5"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"sharpen_3x3"\f[]
.IP \[bu] 2
\f[C]"unsharp_mask_5x5"\f[]
.SS SubdivideSurfaceMeshes
.SS Description
.PP
This operation subdivides existing surface meshes according to the
specified criteria, replacing the original meshes with subdivided
copies.
.SS Notes
.IP \[bu] 2
Selected surface meshes should represent polyhedra.
.SS Parameters
.IP \[bu] 2
MeshSelection
.IP \[bu] 2
Iterations
.SS MeshSelection
.SS Description
.PP
Select one or more surface meshes.
Note that a single surface mesh may hold many disconnected mesh
components; they should collectively represent a single logically
cohesive object.
Be aware that it is possible to mix logically unrelated sub\-meshes
together in a single mesh.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth surface
mesh (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last surface mesh.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Iterations
.SS Description
.PP
The number of times subdivision should be performed.
.SS Default
.IP \[bu] 2
\f[C]"2"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"5"\f[]
.SS SubsegmentContours
.SS Description
.PP
This operation sub\-segments the selected contours, resulting in
contours with reduced size.
.SS Parameters
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
PlanarOrientation
.IP \[bu] 2
ReplaceAllWithSubsegment
.IP \[bu] 2
RetainSubsegment
.IP \[bu] 2
SubsegMethod
.IP \[bu] 2
NestedCleaveOrder
.IP \[bu] 2
XSelection
.IP \[bu] 2
YSelection
.IP \[bu] 2
ZSelection
.IP \[bu] 2
FractionalTolerance
.IP \[bu] 2
MaxBisects
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS PlanarOrientation
.SS Description
.PP
A string instructing how to orient the cleaving planes.
Currently supported: (1) `axis\-aligned' (i.e., align with the
image/dose grid row and column unit vectors) and (2) `static\-oblique'
(i.e., same as axis\-aligned but rotated 22.5 degrees to reduce
colinearity, which sometimes improves sub\-segment area consistency).
.SS Default
.IP \[bu] 2
\f[C]"axis\-aligned"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"axis\-aligned"\f[]
.IP \[bu] 2
\f[C]"static\-oblique"\f[]
.SS ReplaceAllWithSubsegment
.SS Description
.PP
Keep the sub\-segment and remove any existing contours from the original
ROIs.
This is most useful for further processing, such as nested
sub\-segmentation.
Note that sub\-segment contours currently have identical metadata to
their parent contours.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS RetainSubsegment
.SS Description
.PP
Keep the sub\-segment as part of the original ROIs.
The contours are appended to the original ROIs, but the contour ROIName
and NormalizedROIName are set to the argument provided.
(If no argument is provided, sub\-segments are not retained.) This is
most useful for inspection of sub\-segments.
Note that sub\-segment contours currently have identical metadata to
their parent contours, except they are renamed accordingly.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"subsegment_01"\f[]
.IP \[bu] 2
\f[C]"subsegment_02"\f[]
.IP \[bu] 2
\f[C]"selected_subsegment"\f[]
.SS SubsegMethod
.SS Description
.PP
The method to use for sub\-segmentation.
Nested sub\-segmentation should almost always be preferred unless you
know what you're doing.
It should be faster too.
Compound sub\-segmentation is known to cause problems, e.g., with
zero\-area sub\-segments and spatial dependence in sub\-segment volume.
.SS Default
.IP \[bu] 2
\f[C]"nested\-cleave"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"nested\-cleave"\f[]
.IP \[bu] 2
\f[C]"compound\-cleave"\f[]
.SS NestedCleaveOrder
.SS Description
.PP
The order in which to apply nested cleaves.
Typically this will be one of `ZXX', `ZYX', `XYZ', `XZY', `YZX', or
`YXZ', but any non\-empty combination of `X', `Y', and `Z' are possible.
Cleaves are implemented from left to right using the specified X, Y, and
Z selection criteria.
Multiple cleaves along the same axis are possible, but note that
currently the same selection criteria are used for each iteration.
.SS Default
.IP \[bu] 2
\f[C]"ZXY"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"ZXY"\f[]
.IP \[bu] 2
\f[C]"ZYX"\f[]
.IP \[bu] 2
\f[C]"X"\f[]
.IP \[bu] 2
\f[C]"XYX"\f[]
.SS XSelection
.SS Description
.PP
(See ZSelection description.) The `X' direction is defined in terms of
movement on an image when the row number increases.
This is generally VERTICAL and DOWNWARD for a patient in head\-first
supine orientation, but it varies with orientation conventions.
All selections are defined in terms of the original ROIs.
.SS Default
.IP \[bu] 2
\f[C]"1.0;0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.50;0.50"\f[]
.IP \[bu] 2
\f[C]"0.50;0.0"\f[]
.IP \[bu] 2
\f[C]"0.30;0.0"\f[]
.IP \[bu] 2
\f[C]"0.30;0.70"\f[]
.SS YSelection
.SS Description
.PP
(See ZSelection description.) The `Y' direction is defined in terms of
movement on an image when the column number increases.
This is generally HORIZONTAL and RIGHTWARD for a patient in head\-first
supine orientation, but it varies with orientation conventions.
All selections are defined in terms of the original ROIs.
.SS Default
.IP \[bu] 2
\f[C]"1.0;0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.50;0.50"\f[]
.IP \[bu] 2
\f[C]"0.50;0.0"\f[]
.IP \[bu] 2
\f[C]"0.30;0.0"\f[]
.IP \[bu] 2
\f[C]"0.30;0.70"\f[]
.SS ZSelection
.SS Description
.PP
The thickness and offset defining the single, continuous extent of the
sub\-segmentation in terms of the fractional area remaining above a
plane.
The planes define the portion extracted and are determined such that
sub\-segmentation will give the desired fractional planar areas.
The numbers specify the thickness and offset from the bottom of the ROI
volume to the bottom of the extent.
The `upper' direction is take from the contour plane orientation and
assumed to be positive if pointing toward the positive\-z direction.
Only a single 3D selection can be made per operation invocation.
Sub\-segmentation can be performed in transverse (`Z'), row_unit (`X'),
and column_unit (`Y') directions (in that order).
All selections are defined in terms of the original ROIs.
Note that impossible selections will likely result in errors, e.g.,
specifying a small constraint when the .
Note that it is possible to perform nested sub\-segmentation (including
passing along the original contours) by opting to replace the original
ROI contours with this sub\-segmentation and invoking this operation
again with the desired sub\-segmentation.
Examples: If you want the middle 50% of an ROI, specify `0.50;0.25'.
If you want the upper 50% then specify `0.50;0.50'.
If you want the lower 50% then specify `0.50;0.0'.
If you want the upper 30% then specify `0.30;0.70'.
If you want the lower 30% then specify `0.30;0.70'.
.SS Default
.IP \[bu] 2
\f[C]"1.0;0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.50;0.50"\f[]
.IP \[bu] 2
\f[C]"0.50;0.0"\f[]
.IP \[bu] 2
\f[C]"0.30;0.0"\f[]
.IP \[bu] 2
\f[C]"0.30;0.70"\f[]
.SS FractionalTolerance
.SS Description
.PP
The tolerance of X, Y, and Z fractional area bisection criteria (see
ZSelection description).
This parameter specifies a stopping condition for the bisection
procedure.
If it is set too high, sub\-segments may be inadequatly rough.
If it is set too low, bisection below the machine precision floor may be
attempted, which will result in instabilities.
Note that the number of permitted iterations will control whether this
tolerance can possibly be reached; if strict adherence is required, set
the maximum number of iterations to be excessively large.
.SS Default
.IP \[bu] 2
\f[C]"0.001"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1E\-2"\f[]
.IP \[bu] 2
\f[C]"1E\-3"\f[]
.IP \[bu] 2
\f[C]"1E\-4"\f[]
.IP \[bu] 2
\f[C]"1E\-5"\f[]
.SS MaxBisects
.SS Description
.PP
The maximum number of iterations the bisection procedure can perform.
This parameter specifies a stopping condition for the bisection
procedure.
If it is set too low, sub\-segments may be inadequatly rough.
If it is set too high, bisection below the machine precision floor may
be attempted, which will result in instabilities.
Note that the fractional tolerance will control whether this tolerance
can possibly be reached; if an exact number of iterations is required,
set the fractional tolerance to be excessively small.
.SS Default
.IP \[bu] 2
\f[C]"20"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"20"\f[]
.IP \[bu] 2
\f[C]"30"\f[]
.SS Subsegment_ComputeDose_VanLuijk
.SS Description
.PP
This operation sub\-segments the selected ROI(s) and computes dose
within the resulting sub\-segments.
.SS Parameters
.IP \[bu] 2
AreaDataFileName
.IP \[bu] 2
DerivativeDataFileName
.IP \[bu] 2
DistributionDataFileName
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
PlanarOrientation
.IP \[bu] 2
ReplaceAllWithSubsegment
.IP \[bu] 2
RetainSubsegment
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
SubsegMethod
.IP \[bu] 2
XSelection
.IP \[bu] 2
YSelection
.IP \[bu] 2
ZSelection
.IP \[bu] 2
FractionalTolerance
.IP \[bu] 2
MaxBisects
.SS AreaDataFileName
.SS Description
.PP
A filename (or full path) in which to append sub\-segment areaa data
generated by this routine.
The format is CSV.
Note that if a sub\-segment has zero area or does not exist, no area
will be printed.
You'll have to manually add sub\-segments with zero area as needed if
this info is relevant to you (e.g., if you are deriving a population
average).
Leave empty to NOT dump anything.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"area_data.csv"\f[]
.SS DerivativeDataFileName
.SS Description
.PP
A filename (or full path) in which to append derivative data generated
by this routine.
The format is CSV.
Leave empty to dump to generate a unique temporary file.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"derivative_data.csv"\f[]
.SS DistributionDataFileName
.SS Description
.PP
A filename (or full path) in which to append raw distribution data
generated by this routine.
The format is one line of description followed by one line for the
distribution; pixel intensities are listed with a single space between
elements; the descriptions contain the patient ID, ROIName, and
subsegment description (guaranteed) and possibly various other data
afterward.
Leave empty to NOT dump anything.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/somefile"\f[]
.IP \[bu] 2
\f[C]"localfile.csv"\f[]
.IP \[bu] 2
\f[C]"distributions.data"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS PlanarOrientation
.SS Description
.PP
A string instructing how to orient the cleaving planes.
Currently only `AxisAligned' (i.e., align with the image/dose grid row
and column unit vectors) and `StaticOblique' (i.e., same as AxisAligned
but rotated 22.5 degrees to reduce colinearity, which sometimes improves
sub\-segment area consistency).
.SS Default
.IP \[bu] 2
\f[C]"AxisAligned"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"AxisAligned"\f[]
.IP \[bu] 2
\f[C]"StaticOblique"\f[]
.SS ReplaceAllWithSubsegment
.SS Description
.PP
Keep the sub\-segment and remove any existing contours from the original
ROIs.
This is most useful for further processing, such as nested
sub\-segmentation.
Note that sub\-segment contours currently have identical metadata to
their parent contours.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS RetainSubsegment
.SS Description
.PP
Keep the sub\-segment as part of the original ROIs.
The contours are appended to the original ROIs, but the contour ROIName
and NormalizedROIName are set to the argument provided.
(If no argument is provided, sub\-segments are not retained.) This is
most useful for inspection of sub\-segments.
Note that sub\-segment contours currently have identical metadata to
their parent contours, except they are renamed accordingly.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]"subsegment_01"\f[]
.IP \[bu] 2
\f[C]"subsegment_02"\f[]
.IP \[bu] 2
\f[C]"selected_subsegment"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS SubsegMethod
.SS Description
.PP
The method to use for sub\-segmentation.
Nested sub\-segmentation should almost always be preferred unless you
know what you're doing.
It should be faster too.
The compound method was used in the van Luijk paper, but it is known to
have serious problems.
.SS Default
.IP \[bu] 2
\f[C]"nested"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"nested"\f[]
.IP \[bu] 2
\f[C]"compound"\f[]
.SS XSelection
.SS Description
.PP
(See ZSelection description.) The \[lq]X\[rq] direction is defined in
terms of movement on an image when the row number increases.
This is generally VERTICAL and DOWNWARD.
All selections are defined in terms of the original ROIs.
.SS Default
.IP \[bu] 2
\f[C]"1.0;0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.50;0.50"\f[]
.IP \[bu] 2
\f[C]"0.50;0.0"\f[]
.IP \[bu] 2
\f[C]"0.30;0.0"\f[]
.IP \[bu] 2
\f[C]"0.30;0.70"\f[]
.SS YSelection
.SS Description
.PP
(See ZSelection description.) The \[lq]Y\[rq] direction is defined in
terms of movement on an image when the column number increases.
This is generally HORIZONTAL and RIGHTWARD.
All selections are defined in terms of the original ROIs.
.SS Default
.IP \[bu] 2
\f[C]"1.0;0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.50;0.50"\f[]
.IP \[bu] 2
\f[C]"0.50;0.0"\f[]
.IP \[bu] 2
\f[C]"0.30;0.0"\f[]
.IP \[bu] 2
\f[C]"0.30;0.70"\f[]
.SS ZSelection
.SS Description
.PP
The thickness and offset defining the single, continuous extent of the
sub\-segmentation in terms of the fractional area remaining above a
plane.
The planes define the portion extracted and are determined such that
sub\-segmentation will give the desired fractional planar areas.
The numbers specify the thickness and offset from the bottom of the ROI
volume to the bottom of the extent.
The `upper' direction is take from the contour plane orientation and
assumed to be positive if pointing toward the positive\-z direction.
Only a single 3D selection can be made per operation invocation.
Sub\-segmentation can be performed in transverse (\[lq]Z\[rq]), row_unit
(\[lq]X\[rq]), and column_unit (\[lq]Y\[rq]) directions (in that order).
All selections are defined in terms of the original ROIs.
Note that it is possible to perform nested sub\-segmentation (including
passing along the original contours) by opting to replace the original
ROI contours with this sub\-segmentation and invoking this operation
again with the desired sub\-segmentation.
If you want the middle 50% of an ROI, specify `0.50;0.25'.
If you want the upper 50% then specify `0.50;0.50'.
If you want the lower 50% then specify `0.50;0.0'.
If you want the upper 30% then specify `0.30;0.70'.
If you want the lower 30% then specify `0.30;0.70'.
.SS Default
.IP \[bu] 2
\f[C]"1.0;0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.50;0.50"\f[]
.IP \[bu] 2
\f[C]"0.50;0.0"\f[]
.IP \[bu] 2
\f[C]"0.30;0.0"\f[]
.IP \[bu] 2
\f[C]"0.30;0.70"\f[]
.SS FractionalTolerance
.SS Description
.PP
The tolerance of X, Y, and Z fractional area bisection criteria (see
ZSelection description).
This parameter specifies a stopping condition for the bisection
procedure.
If it is set too high, sub\-segments may be inadequatly rough.
If it is set too low, bisection below the machine precision floor may be
attempted, which will result in instabilities.
Note that the number of permitted iterations will control whether this
tolerance can possibly be reached; if strict adherence is required, set
the maximum number of iterations to be excessively large.
.SS Default
.IP \[bu] 2
\f[C]"0.001"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1E\-2"\f[]
.IP \[bu] 2
\f[C]"1E\-3"\f[]
.IP \[bu] 2
\f[C]"1E\-4"\f[]
.IP \[bu] 2
\f[C]"1E\-5"\f[]
.SS MaxBisects
.SS Description
.PP
The maximum number of iterations the bisection procedure can perform.
This parameter specifies a stopping condition for the bisection
procedure.
If it is set too low, sub\-segments may be inadequatly rough.
If it is set too high, bisection below the machine precision floor may
be attempted, which will result in instabilities.
Note that the fractional tolerance will control whether this tolerance
can possibly be reached; if an exact number of iterations is required,
set the fractional tolerance to be excessively small.
.SS Default
.IP \[bu] 2
\f[C]"20"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"20"\f[]
.IP \[bu] 2
\f[C]"30"\f[]
.SS SubtractImages
.SS Description
.PP
This routine subtracts images that spatially overlap.
.SS Notes
.IP \[bu] 2
The ReferenceImageSelection is subtracted from the ImageSelection and
the result is stored in ImageSelection.
So this operation implements \f[I]A\f[] = \f[I]A\f[] − \f[I]B\f[] where
A is ImageSelection and B is ReferenceImageSelection.
The ReferenceImageSelection images are not altered.
.IP \[bu] 2
Multiple image volumes can be selected by both ImageSelection and
ReferenceImageSelection.
For each ImageSelection volume, each of the ReferenceImageSelection
volumes are subtracted sequentially.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
ReferenceImageSelection
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ReferenceImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"!last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS SupersampleImageGrid
.SS Description
.PP
This operation scales supersamples images so they have more rows and/or
columns, but the whole image keeps its shape and spatial extent.
This operation is typically used for zooming into images or trying to
ensure a sufficient number of voxels are within small contours.
.SS Notes
.IP \[bu] 2
Be aware that specifying large multipliers (or even small multipliers on
large images) will consume much memory.
It is best to pre\-crop images to a region of interest if possible.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
RowScaleFactor
.IP \[bu] 2
ColumnScaleFactor
.IP \[bu] 2
SliceScaleFactor
.IP \[bu] 2
SamplingMethod
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS RowScaleFactor
.SS Description
.PP
A positive integer specifying how many rows will be in the new images.
The number is relative to the incoming image row count.
Specifying `1' will result in nothing happening.
Specifying `8' will result in 8x as many rows.
.SS Default
.IP \[bu] 2
\f[C]"2"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.IP \[bu] 2
\f[C]"8"\f[]
.SS ColumnScaleFactor
.SS Description
.PP
A positive integer specifying how many columns will be in the new
images.
The number is relative to the incoming image column count.
Specifying `1' will result in nothing happening.
Specifying `8' will result in 8x as many columns.
.SS Default
.IP \[bu] 2
\f[C]"2"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.IP \[bu] 2
\f[C]"8"\f[]
.SS SliceScaleFactor
.SS Description
.PP
A positive integer specifying how many image slices will be in the new
images.
The number is relative to the incoming image slice count.
Specifying `1' will result in nothing happening.
Specifying `8' will result in 8x as many slices.
Note that slice supersampling always happens \f[I]after\f[] in\-plane
supersampling.
Also note that merely setting this factor will not enable 3D
supersampling; you also need to specify a 3D\-aware SamplingMethod.
.SS Default
.IP \[bu] 2
\f[C]"2"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.IP \[bu] 2
\f[C]"8"\f[]
.SS SamplingMethod
.SS Description
.PP
The supersampling method to use.
Note: `inplane\-' methods only consider neighbours in the plane of a
single image \[en] neighbours in adjacent images are not considered and
the supersampled image will contain the same number of image slices as
the inputs.
.SS Default
.IP \[bu] 2
\f[C]"inplane\-bilinear"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"inplane\-bicubic"\f[]
.IP \[bu] 2
\f[C]"inplane\-bilinear"\f[]
.IP \[bu] 2
\f[C]"trilinear"\f[]
.SS SurfaceBasedRayCastDoseAccumulate
.SS Description
.PP
This routine uses rays (actually: line segments) to estimate point\-dose
on the surface of an ROI.
The ROI is approximated by surface mesh and rays are passed through.
Dose is interpolated at the intersection points and intersecting lines
(i.e., where the ray `glances' the surface) are discarded.
The surface reconstruction can be tweaked, but appear to reasonably
approximate the ROI contours; both can be output to compare visually.
Though it is not required by the implementation, only the ray\-surface
intersection nearest to the detector is considered.
All other intersections (i.e., on the far side of the surface mesh) are
ignored.
This routine is fairly fast compared to the slow grid\-based counterpart
previously implemented.
The speedup comes from use of an AABB\-tree to accelerate intersection
queries and avoid having to `walk' rays step\-by\-step through
over/through the geometry.
.SS Parameters
.IP \[bu] 2
TotalDoseMapFileName
.IP \[bu] 2
RefCroppedTotalDoseMapFileName
.IP \[bu] 2
IntersectionCountMapFileName
.IP \[bu] 2
DepthMapFileName
.IP \[bu] 2
RadialDistMapFileName
.IP \[bu] 2
RefIntersectionCountMapFileName
.IP \[bu] 2
ROISurfaceMeshFileName
.IP \[bu] 2
SubdividedROISurfaceMeshFileName
.IP \[bu] 2
RefSurfaceMeshFileName
.IP \[bu] 2
SubdividedRefSurfaceMeshFileName
.IP \[bu] 2
ROICOMCOMLineFileName
.IP \[bu] 2
NormalizedReferenceROILabelRegex
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ReferenceROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
SourceDetectorRows
.IP \[bu] 2
SourceDetectorColumns
.IP \[bu] 2
MeshingSubdivisionIterations
.IP \[bu] 2
MaxRaySurfaceIntersections
.IP \[bu] 2
OnlyGenerateSurface
.SS TotalDoseMapFileName
.SS Description
.PP
A filename (or full path) for the total dose image map (at all
ray\-surface intersection points).
The dose for each ray is summed over all ray\-surface point
intersections.
The format is FITS.
This file is always generated.
Leave the argument empty to generate a unique filename.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"total_dose_map.fits"\f[]
.IP \[bu] 2
\f[C]"/tmp/out.fits"\f[]
.SS RefCroppedTotalDoseMapFileName
.SS Description
.PP
A filename (or full path) for the total dose image map (at all
ray\-surface intersection points).
The dose for each ray is summed over all ray\-surface point
intersections.
Doses in this map are only registered when the ray intersects the
reference ROI mesh.
The format is FITS.
This file is always generated.
Leave the argument empty to generate a unique filename.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"total_dose_map.fits"\f[]
.IP \[bu] 2
\f[C]"/tmp/out.fits"\f[]
.SS IntersectionCountMapFileName
.SS Description
.PP
A filename (or full path) for the (number of ray\-surface intersections)
image map.
Each pixel in this map (and the total dose map) represents a single ray;
the number of times the ray intersects the surface can be useful for
various purposes, but most often it will simply be a sanity check for
the cross\-sectional shape or that a specific number of intersections
were recorded in regions with geometrical folds.
Pixels will all be within [0,MaxRaySurfaceIntersections].
The format is FITS.
Leave empty to dump to generate a unique filename.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"intersection_count_map.fits"\f[]
.IP \[bu] 2
\f[C]"/tmp/out.fits"\f[]
.SS DepthMapFileName
.SS Description
.PP
A filename (or full path) for the distance (depth) of each ray\-surface
intersection point from the detector.
Has DICOM coordinate system units.
This image is potentially multi\-channel with MaxRaySurfaceIntersections
channels (when MaxRaySurfaceIntersections = 1 there is 1 channel).
The format is FITS.
Leaving empty will result in no file being written.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"depth_map.fits"\f[]
.IP \[bu] 2
\f[C]"/tmp/out.fits"\f[]
.SS RadialDistMapFileName
.SS Description
.PP
A filename (or full path) for the distance of each ray\-surface
intersection point from the line joining reference and target ROI
centre\-of\-masses.
This helps quantify position in 3D.
Has DICOM coordinate system units.
This image is potentially multi\-channel with MaxRaySurfaceIntersections
channels (when MaxRaySurfaceIntersections = 1 there is 1 channel).
The format is FITS.
Leaving empty will result in no file being written.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"radial_dist_map.fits"\f[]
.IP \[bu] 2
\f[C]"/tmp/out.fits"\f[]
.SS RefIntersectionCountMapFileName
.SS Description
.PP
A filename (or full path) for the (number of ray\-surface intersections)
for the reference ROIs.
Each pixel in this map (and the total dose map) represents a single ray;
the number of times the ray intersects the surface can be useful for
various purposes, but most often it will simply be a sanity check for
the cross\-sectional shape or that a specific number of intersections
were recorded in regions with geometrical folds.
Note: currently, the number of intersections is limited to 0 or 1! The
format is FITS.
Leave empty to dump to generate a unique filename.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"ref_roi_intersection_count_map.fits"\f[]
.IP \[bu] 2
\f[C]"/tmp/out.fits"\f[]
.SS ROISurfaceMeshFileName
.SS Description
.PP
A filename (or full path) for the (pre\-subdivided) surface mesh that is
contructed from the ROI contours.
The format is OFF.
This file is mostly useful for inspection of the surface or comparison
with contours.
Leaving empty will result in no file being written.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/roi_surface_mesh.off"\f[]
.IP \[bu] 2
\f[C]"roi_surface_mesh.off"\f[]
.SS SubdividedROISurfaceMeshFileName
.SS Description
.PP
A filename (or full path) for the Loop\-subdivided surface mesh that is
contructed from the ROI contours.
The format is OFF.
This file is mostly useful for inspection of the surface or comparison
with contours.
Leaving empty will result in no file being written.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/subdivided_roi_surface_mesh.off"\f[]
.IP \[bu] 2
\f[C]"subdivided_roi_surface_mesh.off"\f[]
.SS RefSurfaceMeshFileName
.SS Description
.PP
A filename (or full path) for the (pre\-subdivided) surface mesh that is
contructed from the reference ROI contours.
The format is OFF.
This file is mostly useful for inspection of the surface or comparison
with contours.
Leaving empty will result in no file being written.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/roi_surface_mesh.off"\f[]
.IP \[bu] 2
\f[C]"roi_surface_mesh.off"\f[]
.SS SubdividedRefSurfaceMeshFileName
.SS Description
.PP
A filename (or full path) for the Loop\-subdivided surface mesh that is
contructed from the reference ROI contours.
The format is OFF.
This file is mostly useful for inspection of the surface or comparison
with contours.
Leaving empty will result in no file being written.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/subdivided_roi_surface_mesh.off"\f[]
.IP \[bu] 2
\f[C]"subdivided_roi_surface_mesh.off"\f[]
.SS ROICOMCOMLineFileName
.SS Description
.PP
A filename (or full path) for the line segment that connected the
centre\-of\-mass (COM) of reference and target ROI.
The format is OFF.
This file is mostly useful for inspection of the surface or comparison
with contours.
Leaving empty will result in no file being written.
.SS Default
.IP \[bu] 2
\f[C]""\f[]
.SS Examples
.IP \[bu] 2
\f[C]""\f[]
.IP \[bu] 2
\f[C]"/tmp/roi_com_com_line.off"\f[]
.IP \[bu] 2
\f[C]"roi_com_com_line.off"\f[]
.SS NormalizedReferenceROILabelRegex
.SS Description
.PP
A regex matching reference ROI labels/names to consider.
The default will match all available ROIs, which is non\-sensical.
The reference ROI is used to orient the cleaving plane to trim the grid
surface mask.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Prostate.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Kidney"\f[]
.IP \[bu] 2
\f[C]"Gross\ Liver"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ReferenceROILabelRegex
.SS Description
.PP
A regex matching reference ROI labels/names to consider.
The default will match all available ROIs, which is non\-sensical.
The reference ROI is used to orient the cleaving plane to trim the grid
surface mask.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*[pP]rostate.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS SourceDetectorRows
.SS Description
.PP
The number of rows in the resulting images, which also defines how many
rays are used.
(Each pixel in the source image represents a single ray.) Setting too
fine relative to the surface mask grid or dose grid is futile.
.SS Default
.IP \[bu] 2
\f[C]"1024"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"100"\f[]
.IP \[bu] 2
\f[C]"128"\f[]
.IP \[bu] 2
\f[C]"1024"\f[]
.IP \[bu] 2
\f[C]"4096"\f[]
.SS SourceDetectorColumns
.SS Description
.PP
The number of columns in the resulting images.
(Each pixel in the source image represents a single ray.) Setting too
fine relative to the surface mask grid or dose grid is futile.
.SS Default
.IP \[bu] 2
\f[C]"1024"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"100"\f[]
.IP \[bu] 2
\f[C]"128"\f[]
.IP \[bu] 2
\f[C]"1024"\f[]
.IP \[bu] 2
\f[C]"4096"\f[]
.SS MeshingSubdivisionIterations
.SS Description
.PP
The number of iterations of Loop's subdivision to apply to the surface
mesh.
The aim of subdivision in this context is to have a smooth surface to
work with, but too many applications will create too many facets.
More facets will not lead to more precise results beyond a certain
(modest) amount of smoothing.
If the geometry is relatively spherical already, and meshing bounds
produce reasonably smooth (but `blocky') surface meshes, then 2\-3
iterations should suffice.
More than 3\-4 iterations will almost always be inappropriate.
.SS Default
.IP \[bu] 2
\f[C]"2"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.IP \[bu] 2
\f[C]"3"\f[]
.SS MaxRaySurfaceIntersections
.SS Description
.PP
The maximum number of ray\-surface intersections to accumulate before
retiring each ray.
Note that intersections are sorted spatially by their distance to the
detector, and those closest to the detector are considered first.
If the ROI surface is opaque, setting this value to 1 will emulate
visibility.
Setting to 2 will permit rays continue through the ROI and pass through
the other side; dose will be the accumulation of dose at each
ray\-surface intersection.
This value should most often be 1 or some very high number (e.g., 1000)
to make the surface either completely opaque or completely transparent.
(A transparent surface may help to visualize geometrical `folds' or
other surface details of interest.)
.SS Default
.IP \[bu] 2
\f[C]"1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"4"\f[]
.IP \[bu] 2
\f[C]"1000"\f[]
.SS OnlyGenerateSurface
.SS Description
.PP
Stop processing after writing the surface and subdivided surface meshes.
This option is primarily used for debugging and visualization.
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS ThresholdImages
.SS Description
.PP
This operation applies thresholds to images.
Both upper and lower thresholds can be specified.
.SS Notes
.IP \[bu] 2
This routine operates on individual images.
When thresholds are specified on a percentile basis, each image is
considered separately and therefore each image may be thresholded with
different values.
.IP \[bu] 2
Both thresholds are inclusive.
To binarize an image, use the same threshold for both upper and lower
threshold parameters.
Voxels that fall on the threshold will currently be treated as if they
exclusively satisfy the upper threshold, but this behaviour is not
guaranteed.
.SS Parameters
.IP \[bu] 2
Lower
.IP \[bu] 2
Low
.IP \[bu] 2
Upper
.IP \[bu] 2
High
.IP \[bu] 2
Channel
.IP \[bu] 2
ImageSelection
.SS Lower
.SS Description
.PP
The lower bound (inclusive).
Pixels with values < this number are replaced with the `low' value.
If this number is followed by a `%', the bound will be scaled between
the min and max pixel values [0\-100%].
If this number is followed by `tile', the bound will be replaced with
the corresponding percentile [0\-100tile].
Note that upper and lower bounds can be specified separately (e.g.,
lower bound is a percentage, but upper bound is a percentile).
.SS Default
.IP \[bu] 2
\f[C]"\-inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1E\-99"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"0.2%"\f[]
.IP \[bu] 2
\f[C]"23tile"\f[]
.IP \[bu] 2
\f[C]"23.123\ tile"\f[]
.SS Low
.SS Description
.PP
The value a pixel will take when below the lower threshold.
.SS Default
.IP \[bu] 2
\f[C]"\-inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1000.0"\f[]
.IP \[bu] 2
\f[C]"\-inf"\f[]
.IP \[bu] 2
\f[C]"nan"\f[]
.SS Upper
.SS Description
.PP
The upper bound (inclusive).
Pixels with values > this number are replaced with the `high' value.
If this number is followed by a `%', the bound will be scaled between
the min and max pixel values [0\-100%].
If this number is followed by `tile', the bound will be replaced with
the corresponding percentile [0\-100tile].
Note that upper and lower bounds can be specified separately (e.g.,
lower bound is a percentage, but upper bound is a percentile).
.SS Default
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"1E\-99"\f[]
.IP \[bu] 2
\f[C]"2.34"\f[]
.IP \[bu] 2
\f[C]"98.12%"\f[]
.IP \[bu] 2
\f[C]"94tile"\f[]
.IP \[bu] 2
\f[C]"94.123\ tile"\f[]
.SS High
.SS Description
.PP
The value a pixel will take when above the upper threshold.
.SS Default
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"1000.0"\f[]
.IP \[bu] 2
\f[C]"inf"\f[]
.IP \[bu] 2
\f[C]"nan"\f[]
.SS Channel
.SS Description
.PP
The image channel to use.
Zero\-based.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ThresholdOtsu
.SS Description
.PP
This routine performs Otsu thresholding (i.e., `binarization') on an
image volume.
The thresholding is limited within ROI(s).
Otsu thresholding works best on images with a well\-defined bimodal
voxel intensity histogram.
It works by finding the threshold that partitions the voxel intensity
histogram into two parts, essentially so that the sum of each
partition's variance is minimal.
The number of histogram bins (i.e., number of distinct voxel magnitude
levels) is configurable.
Voxels are binarized; the replacement values are also configurable.
.SS Notes
.IP \[bu] 2
The Otsu method will not necessarily cleanly separate bimodal peaks in
the voxel intensity histogram.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
HistogramBins
.IP \[bu] 2
ReplacementLow
.IP \[bu] 2
ReplacementHigh
.IP \[bu] 2
OverwriteVoxels
.IP \[bu] 2
Channel
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
ContourOverlap
.IP \[bu] 2
Inclusivity
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS HistogramBins
.SS Description
.PP
The number of equal\-width bins the histogram should have.
Classically, images were 8\-bit integer\-valued and thus 255 bins were
commonly used.
However, because floating\-point numbers are used practically any number
of bins are supported.
What is optimal (or acceptable) depends on the analytical requirements.
If the threshold does not have to be exact, try use the smallest number
of bins you can get away with; 50\-150 should suffice.
This will speed up computation.
If the threshold is being used for analytical purposes, use as many bins
as the data can support \[en] if the voxel values span only 8\-bit
integers, having more than 255 bins will not improve the analysis.
Likewise if voxels are discretized or sparse.
Experiment by gradually increasing the number of bins until the
threshold value converges to a reasonable number, and then use that
number of bins for future analysis.
.SS Default
.IP \[bu] 2
\f[C]"255"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"10"\f[]
.IP \[bu] 2
\f[C]"50"\f[]
.IP \[bu] 2
\f[C]"100"\f[]
.IP \[bu] 2
\f[C]"200"\f[]
.IP \[bu] 2
\f[C]"500"\f[]
.SS ReplacementLow
.SS Description
.PP
The value to give voxels which are below (exclusive) the Otsu threshold
value.
.SS Default
.IP \[bu] 2
\f[C]"0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1.0"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"nan"\f[]
.IP \[bu] 2
\f[C]"inf"\f[]
.SS ReplacementHigh
.SS Description
.PP
The value to give voxels which are above (inclusive) the Otsu threshold
value.
.SS Default
.IP \[bu] 2
\f[C]"1.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1.0"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"nan"\f[]
.IP \[bu] 2
\f[C]"inf"\f[]
.SS OverwriteVoxels
.SS Description
.PP
Controls whether voxels should actually be binarized or not.
Whether or not voxel intensities are overwritten, the Otsu threshold
value is written into the image metadata as `OtsuThreshold' in case
further processing is needed.
.SS Default
.IP \[bu] 2
\f[C]"true"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS Channel
.SS Description
.PP
The image channel to use.
Zero\-based.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS ContourOverlap
.SS Description
.PP
Controls overlapping contours are treated.
The default `ignore' treats overlapping contours as a single contour,
regardless of contour orientation.
The option `honour_opposite_orientations' makes overlapping contours
with opposite orientation cancel.
Otherwise, orientation is ignored.
The latter is useful for Boolean structures where contour orientation is
significant for interior contours (holes).
The option `overlapping_contours_cancel' ignores orientation and cancels
all contour overlap.
.SS Default
.IP \[bu] 2
\f[C]"ignore"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"ignore"\f[]
.IP \[bu] 2
\f[C]"honour_opposite_orientations"\f[]
.IP \[bu] 2
\f[C]"overlapping_contours_cancel"\f[]
.IP \[bu] 2
\f[C]"honour_opps"\f[]
.IP \[bu] 2
\f[C]"overlap_cancel"\f[]
.SS Inclusivity
.SS Description
.PP
Controls how voxels are deemed to be `within' the interior of the
selected ROI(s).
The default `center' considers only the central\-most point of each
voxel.
There are two corner options that correspond to a 2D projection of the
voxel onto the image plane.
The first, `planar_corner_inclusive', considers a voxel interior if ANY
corner is interior.
The second, `planar_corner_exclusive', considers a voxel interior if ALL
(four) corners are interior.
.SS Default
.IP \[bu] 2
\f[C]"center"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"center"\f[]
.IP \[bu] 2
\f[C]"centre"\f[]
.IP \[bu] 2
\f[C]"planar_corner_inclusive"\f[]
.IP \[bu] 2
\f[C]"planar_inc"\f[]
.IP \[bu] 2
\f[C]"planar_corner_exclusive"\f[]
.IP \[bu] 2
\f[C]"planar_exc"\f[]
.SS TransformContours
.SS Description
.PP
This operation transforms contours by translating, scaling, and rotating
vertices.
.SS Notes
.IP \[bu] 2
A single transformation can be specified at a time.
Perform this operation sequentially to enforce order.
.SS Parameters
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
Transform
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS Transform
.SS Description
.PP
This parameter is used to specify the transformation that should be
performed.
A single transformation can be specified for each invocation of this
operation.
Currently translation, scaling, and rotation are available.
Translations have three configurable scalar parameters denoting the
translation along x, y, and z in the DICOM coordinate system.
Translating \f[I]x\f[] = 1.0, \f[I]y\f[] =  − 2.0, and \f[I]z\f[] = 0.3
can be specified as `translate(1.0, \-2.0, 0.3)'.
The scale transformation has four configurable scalar parameters
denoting the scale centre 3\-vector and the magnification factor.
Note that the magnification factor can be negative, which will cause the
mesh to be inverted along x, y, and z axes and magnified.
Take note that face orientations will also become inverted.
Magnifying by 2.7x about (1.23,  − 2.34, 3.45) can be specified as
`scale(1.23, \-2.34, 3.45, 2.7)'.
Rotations around an arbitrary axis line can be accomplished.
The rotation transformation has seven configurable scalar parameters
denoting the rotation centre 3\-vector, the rotation axis 3\-vector, and
the rotation angle in radians.
A rotation of pi radians around the axis line parallel to vector
(1.0, 0.0, 0.0) that intersects the point (4.0, 5.0, 6.0) can be
specified as `rotate(4.0, 5.0, 6.0, 1.0, 0.0, 0.0, 3.141592653)'.
.SS Default
.IP \[bu] 2
\f[C]"translate(0.0,\ 0.0,\ 0.0)"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"translate(1.0,\ \-2.0,\ 0.3)"\f[]
.IP \[bu] 2
\f[C]"scale(1.23,\ \-2.34,\ 3.45,\ 2.7)"\f[]
.IP \[bu] 2
\f[C]"rotate(4.0,\ 5.0,\ 6.0,\ \ 1.0,\ 0.0,\ 0.0,\ \ 3.141592653)"\f[]
.SS TransformMeshes
.SS Description
.PP
This operation transforms meshes by translating, scaling, and rotating
vertices.
.SS Notes
.IP \[bu] 2
A single transformation can be specified at a time.
Perform this operation sequentially to enforce order.
.SS Parameters
.IP \[bu] 2
MeshSelection
.IP \[bu] 2
Transform
.SS MeshSelection
.SS Description
.PP
Select one or more surface meshes.
Note that a single surface mesh may hold many disconnected mesh
components; they should collectively represent a single logically
cohesive object.
Be aware that it is possible to mix logically unrelated sub\-meshes
together in a single mesh.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth surface
mesh (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last surface mesh.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Transform
.SS Description
.PP
This parameter is used to specify the transformation that should be
performed.
A single transformation can be specified for each invocation of this
operation.
Currently translation, scaling, and rotation are available.
Translations have three configurable scalar parameters denoting the
translation along x, y, and z in the DICOM coordinate system.
Translating \f[I]x\f[] = 1.0, \f[I]y\f[] =  − 2.0, and \f[I]z\f[] = 0.3
can be specified as `translate(1.0, \-2.0, 0.3)'.
The scale transformation has four configurable scalar parameters
denoting the scale centre 3\-vector and the magnification factor.
Note that the magnification factor can be negative, which will cause the
mesh to be inverted along x, y, and z axes and magnified.
Take note that face orientations will also become inverted.
Magnifying by 2.7x about (1.23,  − 2.34, 3.45) can be specified as
`scale(1.23, \-2.34, 3.45, 2.7)'.
Rotations around an arbitrary axis line can be accomplished.
The rotation transformation has seven configurable scalar parameters
denoting the rotation centre 3\-vector, the rotation axis 3\-vector, and
the rotation angle in radians.
A rotation of pi radians around the axis line parallel to vector
(1.0, 0.0, 0.0) that intersects the point (4.0, 5.0, 6.0) can be
specified as `rotate(4.0, 5.0, 6.0, 1.0, 0.0, 0.0, 3.141592653)'.
.SS Default
.IP \[bu] 2
\f[C]"translate(0.0,\ 0.0,\ 0.0)"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"translate(1.0,\ \-2.0,\ 0.3)"\f[]
.IP \[bu] 2
\f[C]"scale(1.23,\ \-2.34,\ 3.45,\ 2.7)"\f[]
.IP \[bu] 2
\f[C]"rotate(4.0,\ 5.0,\ 6.0,\ \ 1.0,\ 0.0,\ 0.0,\ \ 3.141592653)"\f[]
.SS TrimROIDose
.SS Description
.PP
This operation provides a simplified interface for overriding the dose
within a ROI.
For example, this operation can be used to modify a base plan by
eliminating dose that coincides with a PTV/CTV/GTV/ROI etc.
.SS Notes
.IP \[bu] 2
This operation performs the opposite of the `Crop' operation, which
trims the dose outside a ROI.
.IP \[bu] 2
The inclusivity of a dose voxel that straddles the ROI boundary can be
specified in various ways.
Refer to the Inclusivity parameter documentation.
.IP \[bu] 2
By default this operation only overrides dose within a ROI.
The opposite, overriding dose outside of a ROI, can be accomplished
using the expert interface.
.SS Parameters
.IP \[bu] 2
Channel
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
ContourOverlap
.IP \[bu] 2
Inclusivity
.IP \[bu] 2
ExteriorVal
.IP \[bu] 2
InteriorVal
.IP \[bu] 2
ExteriorOverwrite
.IP \[bu] 2
InteriorOverwrite
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
Filename
.IP \[bu] 2
ParanoiaLevel
.SS Channel
.SS Description
.PP
The image channel to use.
Zero\-based.
Use `\-1' to operate on all available channels.
.SS Default
.IP \[bu] 2
\f[C]"\-1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.IP \[bu] 2
\f[C]"2"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS ContourOverlap
.SS Description
.PP
Controls overlapping contours are treated.
The default `ignore' treats overlapping contours as a single contour,
regardless of contour orientation.
The option `honour_opposite_orientations' makes overlapping contours
with opposite orientation cancel.
Otherwise, orientation is ignored.
The latter is useful for Boolean structures where contour orientation is
significant for interior contours (holes).
The option `overlapping_contours_cancel' ignores orientation and cancels
all contour overlap.
.SS Default
.IP \[bu] 2
\f[C]"ignore"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"ignore"\f[]
.IP \[bu] 2
\f[C]"honour_opposite_orientations"\f[]
.IP \[bu] 2
\f[C]"overlapping_contours_cancel"\f[]
.IP \[bu] 2
\f[C]"honour_opps"\f[]
.IP \[bu] 2
\f[C]"overlap_cancel"\f[]
.SS Inclusivity
.SS Description
.PP
Controls how voxels are deemed to be `within' the interior of the
selected ROI(s).
The default `center' considers only the central\-most point of each
voxel.
There are two corner options that correspond to a 2D projection of the
voxel onto the image plane.
The first, `planar_corner_inclusive', considers a voxel interior if ANY
corner is interior.
The second, `planar_corner_exclusive', considers a voxel interior if ALL
(four) corners are interior.
.SS Default
.IP \[bu] 2
\f[C]"planar_inc"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"center"\f[]
.IP \[bu] 2
\f[C]"centre"\f[]
.IP \[bu] 2
\f[C]"planar_corner_inclusive"\f[]
.IP \[bu] 2
\f[C]"planar_inc"\f[]
.IP \[bu] 2
\f[C]"planar_corner_exclusive"\f[]
.IP \[bu] 2
\f[C]"planar_exc"\f[]
.SS ExteriorVal
.SS Description
.PP
The value to give to voxels outside the specified ROI(s).
Note that this value will be ignored if exterior overwrites are
disabled.
.SS Default
.IP \[bu] 2
\f[C]"0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1.0"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"2.34E26"\f[]
.SS InteriorVal
.SS Description
.PP
The value to give to voxels within the volume of the specified ROI(s).
Note that this value will be ignored if interior overwrites are
disabled.
.SS Default
.IP \[bu] 2
\f[C]"0.0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"\-1.0"\f[]
.IP \[bu] 2
\f[C]"1.23"\f[]
.IP \[bu] 2
\f[C]"2.34E26"\f[]
.SS ExteriorOverwrite
.SS Description
.PP
Whether to overwrite voxels exterior to the specified ROI(s).
.SS Default
.IP \[bu] 2
\f[C]"false"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS InteriorOverwrite
.SS Description
.PP
Whether to overwrite voxels interior to the specified ROI(s).
.SS Default
.IP \[bu] 2
\f[C]"true"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"true"\f[]
.IP \[bu] 2
\f[C]"false"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"all"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS Filename
.SS Description
.PP
The filename (or full path name) to which the DICOM file should be
written.
.SS Default
.IP \[bu] 2
\f[C]"/tmp/RD.dcm"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"/tmp/RD.dcm"\f[]
.IP \[bu] 2
\f[C]"./RD.dcm"\f[]
.IP \[bu] 2
\f[C]"RD.dcm"\f[]
.SS ParanoiaLevel
.SS Description
.PP
At low paranoia setting, only top\-level UIDs are replaced.
At medium paranoia setting, many UIDs, descriptions, and labels are
replaced, but the PatientID and FrameOfReferenceUID are retained.
The high paranoia setting is the same as the medium setting, but the
PatientID and FrameOfReferenceUID are also replaced.
(Note: this is not a full anonymization.) Use the low setting if you
want to retain linkage to the originating data set.
Use the medium setting if you don't.
Use the high setting if your TPS goes overboard linking data sets by
PatientID and/or FrameOfReferenceUID.
.SS Default
.IP \[bu] 2
\f[C]"medium"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"low"\f[]
.IP \[bu] 2
\f[C]"medium"\f[]
.IP \[bu] 2
\f[C]"high"\f[]
.SS UBC3TMRI_DCE
.SS Description
.PP
This operation is used to generate dynamic contrast\-enhanced MRI
contrast enhancement maps.
.SS Parameters
.PP
No registered options.
.SS UBC3TMRI_DCE_Differences
.SS Description
.PP
This operation is used to generate dynamic contrast\-enhanced MRI
contrast enhancement maps.
.SS Notes
.IP \[bu] 2
This routine generates difference maps using both long DCE scans.
Thus it takes up a LOT of memory! Try avoid unnecessary copies of large
(temporally long) arrays.
.SS Parameters
.PP
No registered options.
.SS UBC3TMRI_DCE_Experimental
.SS Description
.PP
This operation is an experimental operation for processing dynamic
contrast\-enhanced MR images.
.SS Parameters
.PP
No registered options.
.SS UBC3TMRI_IVIM_ADC
.SS Description
.PP
This operation is an experimental operation for processing IVIM MR
images into ADC maps.
.SS Parameters
.PP
No registered options.
.SS VolumetricCorrelationDetector
.SS Description
.PP
This operation can assess 3D correlations by sampling the neighbourhood
surrounding each voxel and assigning a similarity score.
This routine is useful for detecting repetitive (regular) patterns that
are known in advance.
.SS Notes
.IP \[bu] 2
The provided image collection must be rectilinear.
.IP \[bu] 2
At the moment this routine can only be modified via recompilation.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Low
.IP \[bu] 2
High
.IP \[bu] 2
Channel
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Low
.SS Description
.PP
The low percentile.
.SS Default
.IP \[bu] 2
\f[C]"0.05"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.05"\f[]
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"0.99"\f[]
.SS High
.SS Description
.PP
The high percentile.
.SS Default
.IP \[bu] 2
\f[C]"0.95"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"0.95"\f[]
.IP \[bu] 2
\f[C]"0.5"\f[]
.IP \[bu] 2
\f[C]"0.05"\f[]
.SS Channel
.SS Description
.PP
The channel to operated on (zero\-based).
Negative values will cause all channels to be operated on.
.SS Default
.IP \[bu] 2
\f[C]"\-1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.SS VolumetricSpatialBlur
.SS Description
.PP
This operation performs blurring of voxel values within 3D rectilinear
image arrays.
.SS Notes
.IP \[bu] 2
The provided image collection must be rectilinear.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Channel
.IP \[bu] 2
Estimator
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Channel
.SS Description
.PP
The channel to operated on (zero\-based).
Negative values will cause all channels to be operated on.
.SS Default
.IP \[bu] 2
\f[C]"\-1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.SS Estimator
.SS Description
.PP
Controls which type of blur is computed.
Currently, `Gaussian' refers to a fixed sigma=1 (in pixel coordinates,
not DICOM units) Gaussian blur that extends for 3*sigma thus providing a
7x7x7 window.
Note that applying this kernel N times will approximate a Gaussian with
sigma=N.
Also note that boundary voxels will cause accessible voxels within the
same window to be more heavily weighted.
Try avoid boundaries or add extra margins if possible.
.SS Default
.IP \[bu] 2
\f[C]"Gaussian"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"Gaussian"\f[]
.SS VolumetricSpatialDerivative
.SS Description
.PP
This operation estimates various spatial partial derivatives (of pixel
values) within 3D rectilinear image arrays.
.SS Notes
.IP \[bu] 2
The provided image collection must be rectilinear.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
Channel
.IP \[bu] 2
Estimator
.IP \[bu] 2
Method
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS Channel
.SS Description
.PP
The channel to operated on (zero\-based).
Negative values will cause all channels to be operated on.
.SS Default
.IP \[bu] 2
\f[C]"\-1"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.SS Estimator
.SS Description
.PP
Controls the finite\-difference partial derivative order or estimator
used.
All estimators are centred and use mirror boundary conditions.
First\-order estimators include the basic nearest\-neighbour first
derivative and Sobel estimators.
`XxYxZ' denotes the size of the convolution kernel (i.e., the number of
adjacent pixels considered).
.SS Default
.IP \[bu] 2
\f[C]"Sobel\-3x3x3"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"Sobel\-3x3x3"\f[]
.SS Method
.SS Description
.PP
Controls partial derivative method.
First\-order derivatives can be row\-, column\-, or image\-aligned, All
methods also support magnitude (addition of orthogonal components in
quadrature).
.SS Default
.IP \[bu] 2
\f[C]"magnitude"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"row\-aligned"\f[]
.IP \[bu] 2
\f[C]"column\-aligned"\f[]
.IP \[bu] 2
\f[C]"image\-aligned"\f[]
.IP \[bu] 2
\f[C]"magnitude"\f[]
.IP \[bu] 2
\f[C]"non\-maximum\-suppression"\f[]
.SS VoxelRANSAC
.SS Description
.PP
This routine performs RANSAC fitting using voxel positions as inputs.
The search can be confined within ROIs and a range of voxel intensities.
.SS Notes
.IP \[bu] 2
This operation does not make use of voxel intensities during the RANSAC
procedure.
Voxel intensities are only used to identify which voxel positions are
considered.
.SS Parameters
.IP \[bu] 2
ImageSelection
.IP \[bu] 2
NormalizedROILabelRegex
.IP \[bu] 2
ROILabelRegex
.IP \[bu] 2
ContourOverlap
.IP \[bu] 2
Inclusivity
.IP \[bu] 2
Channel
.IP \[bu] 2
Lower
.IP \[bu] 2
Upper
.IP \[bu] 2
GridSeparation
.SS ImageSelection
.SS Description
.PP
Select one or more image arrays.
Note that image arrays can hold anything, but will typically represent a
single contiguous 3D volume (i.e., a volumetric CT scan) or `4D'
time\-series.
Be aware that it is possible to mix logically unrelated images together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth image
array (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last image array.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS NormalizedROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*Body.*"\f[]
.IP \[bu] 2
\f[C]"Body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*Left.*Parotid.*|.*Right.*Parotid.*|.*Eye.*"\f[]
.IP \[bu] 2
\f[C]"Left\ Parotid|Right\ Parotid"\f[]
.SS ROILabelRegex
.SS Description
.PP
A regex matching ROI labels/names to consider.
The default will match all available ROIs.
Be aware that input spaces are trimmed to a single space.
If your ROI name has more than two sequential spaces, use regex to avoid
them.
All ROIs have to match the single regex, so use the `or' token if
needed.
Regex is case insensitive and uses extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]".*"\f[]
.SS Examples
.IP \[bu] 2
\f[C]".*"\f[]
.IP \[bu] 2
\f[C]".*body.*"\f[]
.IP \[bu] 2
\f[C]"body"\f[]
.IP \[bu] 2
\f[C]"Gross_Liver"\f[]
.IP \[bu] 2
\f[C]".*left.*parotid.*|.*right.*parotid.*|.*eyes.*"\f[]
.IP \[bu] 2
\f[C]"left_parotid|right_parotid"\f[]
.SS ContourOverlap
.SS Description
.PP
Controls overlapping contours are treated.
The default `ignore' treats overlapping contours as a single contour,
regardless of contour orientation.
The option `honour_opposite_orientations' makes overlapping contours
with opposite orientation cancel.
Otherwise, orientation is ignored.
The latter is useful for Boolean structures where contour orientation is
significant for interior contours (holes).
The option `overlapping_contours_cancel' ignores orientation and cancels
all contour overlap.
.SS Default
.IP \[bu] 2
\f[C]"ignore"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"ignore"\f[]
.IP \[bu] 2
\f[C]"honour_opposite_orientations"\f[]
.IP \[bu] 2
\f[C]"overlapping_contours_cancel"\f[]
.IP \[bu] 2
\f[C]"honour_opps"\f[]
.IP \[bu] 2
\f[C]"overlap_cancel"\f[]
.SS Inclusivity
.SS Description
.PP
Controls how voxels are deemed to be `within' the interior of the
selected ROI(s).
The default `center' considers only the central\-most point of each
voxel.
There are two corner options that correspond to a 2D projection of the
voxel onto the image plane.
The first, `planar_corner_inclusive', considers a voxel interior if ANY
corner is interior.
The second, `planar_corner_exclusive', considers a voxel interior if ALL
(four) corners are interior.
.SS Default
.IP \[bu] 2
\f[C]"center"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"center"\f[]
.IP \[bu] 2
\f[C]"centre"\f[]
.IP \[bu] 2
\f[C]"planar_corner_inclusive"\f[]
.IP \[bu] 2
\f[C]"planar_inc"\f[]
.IP \[bu] 2
\f[C]"planar_corner_exclusive"\f[]
.IP \[bu] 2
\f[C]"planar_exc"\f[]
.SS Channel
.SS Description
.PP
The channel to operated on (zero\-based).
Negative values will cause all channels to be operated on.
.SS Default
.IP \[bu] 2
\f[C]"0"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-1"\f[]
.IP \[bu] 2
\f[C]"0"\f[]
.IP \[bu] 2
\f[C]"1"\f[]
.SS Lower
.SS Description
.PP
Lower threshold (inclusive) below which voxels will be ignored by this
routine.
.SS Default
.IP \[bu] 2
\f[C]"\-inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"\-inf"\f[]
.IP \[bu] 2
\f[C]"0.0"\f[]
.IP \[bu] 2
\f[C]"1024"\f[]
.SS Upper
.SS Description
.PP
Upper threshold (inclusive) above which voxels will be ignored by this
routine.
.SS Default
.IP \[bu] 2
\f[C]"inf"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"inf"\f[]
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"2048"\f[]
.SS GridSeparation
.SS Description
.PP
The known separation of the grid (in DICOM units; mm) being sought.
.SS Default
.IP \[bu] 2
\f[C]"nan"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"1.0"\f[]
.IP \[bu] 2
\f[C]"1.5"\f[]
.IP \[bu] 2
\f[C]"10.0"\f[]
.IP \[bu] 2
\f[C]"1.23E4"\f[]
.SS WarpPoints
.SS Description
.PP
This operation applies a vector\-valued transformation (e.g., a
deformation) to a point cloud.
.SS Notes
.IP \[bu] 2
Transformations are not (generally) restricted to the coordinate frame
of reference that they were derived from.
This permits a single transformation to be applicable to point clouds,
surface meshes, images, and contours.
.SS Parameters
.IP \[bu] 2
PointSelection
.IP \[bu] 2
TransformSelection
.SS PointSelection
.SS Description
.PP
The point cloud that will be transformed.
Select one or more point clouds.
Note that point clouds can hold a variety of data with varying
attributes, but each point cloud is meant to represent a single
logically cohesive collection of points.
Be aware that it is possible to mix logically unrelated points together.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth point
cloud (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last point cloud.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SS TransformSelection
.SS Description
.PP
The transformation that will be applied.
Select one or more transforms.
Selection specifiers can be of two types: positional or metadata\-based
key\@value regex.
Positional specifiers can be `first', `last', `none', or `all' literals.
Additionally `#N' for some positive integer N selects the Nth
transformation (with zero\-based indexing).
Likewise, `#\-N' selects the Nth\-from\-last transformation.
Positional specifiers can be inverted by prefixing with a `!'.
Metadata\-based key\@value expressions are applied by matching the keys
verbatim and the values with regex.
In order to invert metadata\-based selectors, the regex logic must be
inverted (i.e., you can \f[I]not\f[] prefix metadata\-based selectors
with a `!').
Multiple criteria can be specified by separating them with a `;' and are
applied in the order specified.
Both positional and metadata\-based criteria can be mixed together.
Note regexes are case insensitive and should use extended POSIX syntax.
.SS Default
.IP \[bu] 2
\f[C]"last"\f[]
.SS Examples
.IP \[bu] 2
\f[C]"last"\f[]
.IP \[bu] 2
\f[C]"first"\f[]
.IP \[bu] 2
\f[C]"all"\f[]
.IP \[bu] 2
\f[C]"none"\f[]
.IP \[bu] 2
\f[C]"#0"\f[]
.IP \[bu] 2
\f[C]"#\-0"\f[]
.IP \[bu] 2
\f[C]"!last"\f[]
.IP \[bu] 2
\f[C]"!#\-3"\f[]
.IP \[bu] 2
\f[C]"key\@.*value.*"\f[]
.IP \[bu] 2
\f[C]"key1\@.*value1.*;key2\@^value2$;first"\f[]
.SH Known Issues and Limitations
.SS Hanging on Debian
.PP
The SFML_Viewer operation hangs on some systems after viewing a plot
with Gnuplot.
This stems from a known issue in Ygor.
.SS Build Requirements
.PP
DICOMautomaton depends on several heavily templated libraries and
external projects.
It requires a considerable amount of memory to build.
.SS DICOM\-RT Support Incomplete
.PP
Support for the DICOM Radiotherapy extensions are limited.
In particular, only RTDOSE files can currently be exported, and RTPLAN
files are not supported at all.
Read support for DICOM image modalities and RTSTRUCTS are generally
supported well.
Broader DICOM support is planned for a future release.
